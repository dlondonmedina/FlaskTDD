{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TDD in Flask This book is a supplement to Test-Driven Development with Python: Obey the Testing Goat: Using Django, Selenium, and Javascript . In this version, much of the content is not copied over. Instead this provides modified exercises and examples using Flask instead of Django. If you have a bit more experience with Python or want to use a more robust framework, I encourage you to take a look at Percival's book. If you want to learn about test-driven development but find Flask suits your purposes better, this is a supplement for you. This book is being built for a course offered at Seattle University, and therefore will contain some additional content for that course. In the future, perhaps video lectures and exercises will become available. For the exercises, starter-code is available. Please feel free to clone it here . About the Author I direct the Web, Application, and Technology Studies program at Seattle University\u2019s School of New and Continuing Studies. My research and pedagogy are deeply invested learning and its application to future contexts. My MA and PhD research focuses on how students acquire and deploy rhetorical strategies and skills within the social, material, and technological landscapes in which they work. I teach in the areas of social theory, social science research, writing, web development, and Python. At heart, I am a maker and have devoted a great deal of energy to creating projects and programs to address problems I see in the world around me. This lead me to develop a transition workshop for service members, which I taught for four years at Joint Base Lewis-McChord. I also lead a team developing Cluster\u2014a suite of tools that work like a personal writing trainer. In the summer, I teach a Python camp for underrepresented kids. Acknowledgements This book is written by Dylan Medina and is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License . It is a Flask supplement for Test-Driven Development with Python by Harry J.W. Percival. Please visit his site and consider purchasing his excellent book. This book ports the exercises from Django to Flask.","title":"Home"},{"location":"#tdd-in-flask","text":"This book is a supplement to Test-Driven Development with Python: Obey the Testing Goat: Using Django, Selenium, and Javascript . In this version, much of the content is not copied over. Instead this provides modified exercises and examples using Flask instead of Django. If you have a bit more experience with Python or want to use a more robust framework, I encourage you to take a look at Percival's book. If you want to learn about test-driven development but find Flask suits your purposes better, this is a supplement for you. This book is being built for a course offered at Seattle University, and therefore will contain some additional content for that course. In the future, perhaps video lectures and exercises will become available. For the exercises, starter-code is available. Please feel free to clone it here .","title":"TDD in Flask"},{"location":"#about-the-author","text":"I direct the Web, Application, and Technology Studies program at Seattle University\u2019s School of New and Continuing Studies. My research and pedagogy are deeply invested learning and its application to future contexts. My MA and PhD research focuses on how students acquire and deploy rhetorical strategies and skills within the social, material, and technological landscapes in which they work. I teach in the areas of social theory, social science research, writing, web development, and Python. At heart, I am a maker and have devoted a great deal of energy to creating projects and programs to address problems I see in the world around me. This lead me to develop a transition workshop for service members, which I taught for four years at Joint Base Lewis-McChord. I also lead a team developing Cluster\u2014a suite of tools that work like a personal writing trainer. In the summer, I teach a Python camp for underrepresented kids.","title":"About the Author"},{"location":"#acknowledgements","text":"This book is written by Dylan Medina and is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License . It is a Flask supplement for Test-Driven Development with Python by Harry J.W. Percival. Please visit his site and consider purchasing his excellent book. This book ports the exercises from Django to Flask.","title":"Acknowledgements"},{"location":"ch1/","text":"Getting Flask Set Up and Your First Functional Test The first functional test checks three things: Is the selenium library installed and can we import webdriver Is there a server serving listening and responding at localhost on port 5000 This is different from the Django. Is that server responding with the page_source attribute set to \"Flask\" Here is the code: from selenium import webdriver browser = webdriver.Firefox() browser.get('http://localhost:5000') assert 'Flask' in browser.page_source functional_tests.py As I follow along with this, I get this error: $ python functional_tests.py Traceback (most recent call last): File \"functional_tests.py\", line 1, in <module> from selenium import webdriver ModuleNotFoundError: No module named 'selenium' Notice that the test failed, but not in the way we expected. Should I have written a separate test that selenium was installed? I could have, but since Python throws an import error anyway, it's not that big of a problem to not have a separate test for it. If you're getting this error as well, then the following should fix things up: (env) $ pip install selenium After Selenium is installed, then you should get the expected error message. We should expect a connection error because we haven't set up Flask yet, so there's no server listening. Getting Flask Up and Running I know I haven't installed Flask in this virtual environment, yet, so I know I'll need to do that first. Django has a CLI to help you build your core site, but since Flask is a lightweight Framework with few moving parts, we don't get that. At the same time, we have far fewer files to deal with and far fewer moving parts, so it's a toss up. Flask is a great tool for smaller projects. Step One: Install Flask Installing Flask is pretty easy. Using pip package manager we just need to install Flask. Make sure that your virtual environment is activated (env) $ pip install Flask At this point, it would also be valuable to create a requirements.txt file. This file allows you to easily set up your app on a different machine without having to move all of the dependencies. You will be using the \"freeze\" command that is build into pip. This command echos the list of dependencies that have been installed in this virtual environment using pip install. Try it out in the terminal and you'll see something like this: (env) $ pip freeze Click==7.0 Flask==1.1.1 itsdangerous==1.1.0 Jinja2==2.11.1 MarkupSafe==1.1.1 selenium==3.141.0 urllib3==1.25.8 Werkzeug==1.0.0 When I installed Flask, I also installed its dependencies (Click, itsdangerous, Jinja2, urllib3, werkzeug). You don't need to do this every time, this was just to show you how pip freeze works. Now you'll need to somehow write the output of pip freeze into a text file called requirements.txt You could copy and past from the terminal, but that's too much work. Instead, you can use the > or >> symbol to write the output of a command directly to a file like so: (env) $ pip freeze > requirements.txt If I use the > symbol, it will either create or overwrite the file to the right of the symbol. NOTICE: if you overwrite data will be lost This is the correct choice in this case because each time we update our requirements.txt file, we want to overwrite it. If we were appending to a file for some other reason, then we would use >> which either creates or appends to the file to the right of the symbol. Step Two: Set Up Your Directory Understanding where your files live is crucial in programming. If the files are not in the right place or if your directory is misshapen, you'll have lots of problems. Django's CLI tool does much of this for you. In Flask, we're on our own. Right now your folder structure within your flask directory should look like this: |--functional_tests.py |--geckodriver.log |--requirements.txt |--env (Virtual Environment Directory) | |--[...] We need to create a directory and three files. We need to create a directory called \"app\" and a file called superlists.py that are both siblings of functional_tests.py. This means they are direct children of our flask directory. We also need to create two files called __init__.py and routes.py that is a child of the \"app\" directory. Here are the commands in the terminal. (env) $ mkdir app && touch superlists.py app/__init__.py app/routes.py You can also enter them as three separate commands if you wish. If this was successful, your flask directory should look like this: |--functional_tests.py |--geckodriver.log |--requirements.txt |--superlists.py |--app | |--__init__.py | |--routes.py |--env (Virtual Environment Directory) | |--[...] If your directory doesn't look exactly like this then go back and check for mistakes before you move on. Now that those files are all created, you can start coding so that the tests will pass. You will be editing superlists.py, __init__.py and routes.py. The first is the script that launches the Flask application. from app import app superlists.py The second is the core of the app (for now). from flask import Flask app = Flask(__name__) from app import routes __init__.py The third is a file that manages the routes. from app import app @app.route('/') @app.route('/index') def index(): return \"Hello, Flask!\" We'll be discussing all of these later on in great detail. Once you've created all of these files, you'll need to start your Flask app so that you can run your tests again. This will require you to have 2 terminals open. In the first terminal, start the Flask app: (env) $ flask run and in the second terminal (make sure you've navigated to your project directory and activated your virtual environment): (env) $ python functional_tests.py At this point, the functional tests will open a new browser and call the Flask app. As soon as that loads, you can close the browser. In your terminal, you should get no error messages. If that's the case, you've successfully completed this. If not, you'll need to go through and revise your code until it works. Make sure to read any error messages for a clue as to what to fix. Now, you'll want to initialize your flask project directory as a git repository. Create a gitignore file that contains at least the following: # Byte-compiled / optimized / DLL files __pycache__/ # Unit test / coverage reports .pytest_cache/ # Flask stuff: db.sqlite3 db.sqlite3-journal instance/ .webassets-cache # Environments env/ # Visual Studio Code .vscode/ .gitignore Then create a new github repository and push your local repository to github. You're done with getting started!","title":"One"},{"location":"ch1/#getting-flask-set-up-and-your-first-functional-test","text":"The first functional test checks three things: Is the selenium library installed and can we import webdriver Is there a server serving listening and responding at localhost on port 5000 This is different from the Django. Is that server responding with the page_source attribute set to \"Flask\" Here is the code: from selenium import webdriver browser = webdriver.Firefox() browser.get('http://localhost:5000') assert 'Flask' in browser.page_source functional_tests.py As I follow along with this, I get this error: $ python functional_tests.py Traceback (most recent call last): File \"functional_tests.py\", line 1, in <module> from selenium import webdriver ModuleNotFoundError: No module named 'selenium' Notice that the test failed, but not in the way we expected. Should I have written a separate test that selenium was installed? I could have, but since Python throws an import error anyway, it's not that big of a problem to not have a separate test for it. If you're getting this error as well, then the following should fix things up: (env) $ pip install selenium After Selenium is installed, then you should get the expected error message. We should expect a connection error because we haven't set up Flask yet, so there's no server listening.","title":"Getting Flask Set Up and Your First Functional Test"},{"location":"ch1/#getting-flask-up-and-running","text":"I know I haven't installed Flask in this virtual environment, yet, so I know I'll need to do that first. Django has a CLI to help you build your core site, but since Flask is a lightweight Framework with few moving parts, we don't get that. At the same time, we have far fewer files to deal with and far fewer moving parts, so it's a toss up. Flask is a great tool for smaller projects.","title":"Getting Flask Up and Running"},{"location":"ch1/#step-one-install-flask","text":"Installing Flask is pretty easy. Using pip package manager we just need to install Flask. Make sure that your virtual environment is activated (env) $ pip install Flask At this point, it would also be valuable to create a requirements.txt file. This file allows you to easily set up your app on a different machine without having to move all of the dependencies. You will be using the \"freeze\" command that is build into pip. This command echos the list of dependencies that have been installed in this virtual environment using pip install. Try it out in the terminal and you'll see something like this: (env) $ pip freeze Click==7.0 Flask==1.1.1 itsdangerous==1.1.0 Jinja2==2.11.1 MarkupSafe==1.1.1 selenium==3.141.0 urllib3==1.25.8 Werkzeug==1.0.0 When I installed Flask, I also installed its dependencies (Click, itsdangerous, Jinja2, urllib3, werkzeug). You don't need to do this every time, this was just to show you how pip freeze works. Now you'll need to somehow write the output of pip freeze into a text file called requirements.txt You could copy and past from the terminal, but that's too much work. Instead, you can use the > or >> symbol to write the output of a command directly to a file like so: (env) $ pip freeze > requirements.txt If I use the > symbol, it will either create or overwrite the file to the right of the symbol. NOTICE: if you overwrite data will be lost This is the correct choice in this case because each time we update our requirements.txt file, we want to overwrite it. If we were appending to a file for some other reason, then we would use >> which either creates or appends to the file to the right of the symbol.","title":"Step One: Install Flask"},{"location":"ch1/#step-two-set-up-your-directory","text":"Understanding where your files live is crucial in programming. If the files are not in the right place or if your directory is misshapen, you'll have lots of problems. Django's CLI tool does much of this for you. In Flask, we're on our own. Right now your folder structure within your flask directory should look like this: |--functional_tests.py |--geckodriver.log |--requirements.txt |--env (Virtual Environment Directory) | |--[...] We need to create a directory and three files. We need to create a directory called \"app\" and a file called superlists.py that are both siblings of functional_tests.py. This means they are direct children of our flask directory. We also need to create two files called __init__.py and routes.py that is a child of the \"app\" directory. Here are the commands in the terminal. (env) $ mkdir app && touch superlists.py app/__init__.py app/routes.py You can also enter them as three separate commands if you wish. If this was successful, your flask directory should look like this: |--functional_tests.py |--geckodriver.log |--requirements.txt |--superlists.py |--app | |--__init__.py | |--routes.py |--env (Virtual Environment Directory) | |--[...] If your directory doesn't look exactly like this then go back and check for mistakes before you move on. Now that those files are all created, you can start coding so that the tests will pass. You will be editing superlists.py, __init__.py and routes.py. The first is the script that launches the Flask application. from app import app superlists.py The second is the core of the app (for now). from flask import Flask app = Flask(__name__) from app import routes __init__.py The third is a file that manages the routes. from app import app @app.route('/') @app.route('/index') def index(): return \"Hello, Flask!\" We'll be discussing all of these later on in great detail. Once you've created all of these files, you'll need to start your Flask app so that you can run your tests again. This will require you to have 2 terminals open. In the first terminal, start the Flask app: (env) $ flask run and in the second terminal (make sure you've navigated to your project directory and activated your virtual environment): (env) $ python functional_tests.py At this point, the functional tests will open a new browser and call the Flask app. As soon as that loads, you can close the browser. In your terminal, you should get no error messages. If that's the case, you've successfully completed this. If not, you'll need to go through and revise your code until it works. Make sure to read any error messages for a clue as to what to fix. Now, you'll want to initialize your flask project directory as a git repository. Create a gitignore file that contains at least the following: # Byte-compiled / optimized / DLL files __pycache__/ # Unit test / coverage reports .pytest_cache/ # Flask stuff: db.sqlite3 db.sqlite3-journal instance/ .webassets-cache # Environments env/ # Visual Studio Code .vscode/ .gitignore Then create a new github repository and push your local repository to github. You're done with getting started!","title":"Step Two: Set Up Your Directory"},{"location":"ch2/","text":"Introducing the unittest Module A note to begin: One thing to notice before we go much further is that we have a number of tools running at the same time to do our tests. Our Flask server that is launched when we type flask run in our terminal. This web server runs on your local machine, is not visible to the outside world, and listens at the IP address 127.0.0.1 on port 5000. In the URL bar, this will look like 127.0.0.1:5000 . Our Flask app that the Flask server calls when it receives requests. Our functional_test.py script, which opens a web browser to send particular requests to the Flask server, and evaluates the server's responses. I recommend, perhaps, diagramming these for yourself in some fashion if it helps you keep things in order. Unittests Our last iteration of our app was extremely simple. It didn't even use any HTML and didn't properly return a web-page; just the string \"Hello, Flask!\" That's not particularly useful if we're trying to build a little web-app, but it's a start. Now we're moving on to bigger and better things. You'll actually have a proper webpage. Our first step will be to modify our functional test so that it looks for a title property. We'll alo add the story that Percival mentions So let's go to the functional test: from selenium import webdriver browser = webdriver.Firefox() # Edith (our test) has heard about a cool new online to-do app. She goes # to check out its homepage browser.get('http://127.0.0.1:5000') # or http://localhost:5000 # She notices the page title and header mention to-do lists assert 'To-Do' in browser.title # She is invited to enter a to-do item straight away # She types \"Buy peacock feathers\" into a text box (Edith's hobby # is tying fly-fishing lures) # When she hits enter, the page updates, and now the page lists # \"1: Buy peacock feathers\" as an item in a to-do list # There is still a text box inviting her to add another item. She # enters \"Use peacock feathers to make a fly\" (Edith is very methodical) # The page updates again, and now shows both items on her list # Edith wonders whether the site will remember her list. Then she sees # that the site has generated a unique URL for her -- there is some # explanatory text to that effect. # She visits that URL - her to-do list is still there. # Satisfied, she goes back to sleep browser.quit() functional_tests.py Comments There are lot of opinions when it comes to how we add comments to our code. In a traditional CS program, we'd expect students to write extensive comments. This is to help the instructor see what you believe you are doing with a particular line of code or function. Likewise, the practice of writing such comments is useful for you to become conscious of what your code is doing. Comments can also be used as a sort of pseudocode to describe what functions your code will need to accomplish (as in the above example). In professional settings, there is a debate as to how many comments are necessary. On the one hand, some argue that your code should be clearly written enough that you don't need any comments. If your code needs comments to explain what's going on, you probably have a problem with your code. They also argue that if you change your code in the future without changing your comments, the comments can become misleading and more of a hinderance for future developers. On the other hand, some argue that comments provide crucial insight to you and other developers about what the code is supposed to do. They give future developers a sense of what you were thinking when you were writing the code. They are also important if you are writing an API or other code that future developers will extend. Additionally, comments are frequently used to generate documentation. For instance Sphinx and other documentation generation tools can automatically create docs based on the comments. Beyond all of this, if you're working for a company, that company will likely have its own approach to comments, and probably a majority of your first period there will be reading the code and comments that you will later be working on. This is all to say, you'll have to decide how much you want to comment your code based on the project. A general rule of thumb is that if the code doesn't obviously tell you what is happening, it's worth commenting. For example the first comment is probably not needed, but the second is (I also probably wouldn't write that generator just to save a few lines of code anyway): # Increment age by 1 age += 1 n = int(input(\"How many players? \")) # prompt users for name and age for each player age_map = {input(\"Name?\"): int(input(\"Age?\")) for i in range(n)} Back to our Tests If we start up our Flask server: (env) $ flask run and in another shell run our functional tests, you'll get an error like this: (env) $ python functional_tests.py Traceback (most recent call last): File \"functional_tests.py\", line 6, in <module> assert 'To-Do' in browser.title AssertionError We are getting the error that we are expecting! However, we want to move over to the unittest framework to make our test a little bit more robust. After all, we'll be building an entire testing suite for our application: every operation we want should be tested. This will be very similar to the test in Percival's book, but before that, take a moment to consider the unittest library. unittest The unittest library is a framework for writing unit tests. A unit test is an automated test that checks the functionality of one unit of a particular application. For instance, one unit of our webpage is the title that shows up on the browser tab. A unit test will test that that is as it should be. Likewise, it might test a single function of our application. When writing a unit test, we need to provide all of the conditions or dependencies except the one variable that is being tested. So our browser title test needs to just test that the browser title contains particular content. It shouldn't check that the browser starts up or anything that appears on the page or that the URL is correct. A functional test is a test that checks a particular functionality of our application. For instance, a functional test might check that we can input a new item into a list and when we do so the item gets added to the database. Unlike a unit test that might have distinct tests for user input and writing to the database, the functional test tries to see that the components work together properly. Another way to think of this: unit tests check a discrete section of code. Functional tests simulate user experience. So, now lets update our functional_tests.py file. You'll notice that this is a functional test because it tests a component of our application as a user would encounter it. We'll write unittests later. from selenium import webdriver import unittest class NewVisitorTest(unittest.TestCase): def setUp(self): self.browser = webdriver.Firefox() def tearDown(self): self.browser.quit() def test_can_start_a_list_and_retrieve_it_later(self): # Call homepage self.browser.get('http://127.0.0.1:5000') # Old way: # assert 'To-Do' in browser.title # Using unittest methods self.assertIn('To-Do', self.browser.title) self.fail('Finish writing the test!') # She is invited to enter a to-do item straight away # She types \"Buy peacock feathers\" into a text box (Edith's hobby # is tying fly-fishing lures) # When she hits enter, the page updates, and now the page lists # \"1: Buy peacock feathers\" as an item in a to-do list # There is still a text box inviting her to add another item. She # enters \"Use peacock feathers to make a fly\" (Edith is very methodical) # The page updates again, and now shows both items on her list # Edith wonders whether the site will remember her list. Then she sees # that the site has generated a unique URL for her -- there is some # explanatory text to that effect. # She visits that URL - her to-do list is still there. # Satisfied, she goes back to sleep if __name__ in '__main__': unittest.main(warnings='ignore') Once again, we want to test it. If you stopped your Flask server, launch it again. Then let's run our functional tests and see the results: (env) $ python functional_tests.py F ====================================================================== FAIL: test_can_start_a_list_and_retrieve_it_later (__main__.NewVisitorTest) ---------------------------------------------------------------------- Traceback (most recent call last): File \"functional_tests.py\", line 20, in test_can_start_a_list_and_retrieve_it_later self.assertIn('To-Do', self.browser.title) AssertionError: 'To-Do' not found in '' ---------------------------------------------------------------------- Ran 1 test in 37.913s FAILED (failures=1) Woo! Our tests are failing as they should be. Notice, we haven't added anything to our app in this chapter, and that's intentional. We now have a test that will pass once our app is returning a page that has the correct title and that will be our next step. For now, it would be a good moment to commit your project and push it to github.","title":"Two"},{"location":"ch2/#introducing-the-unittest-module","text":"","title":"Introducing the unittest Module"},{"location":"ch2/#a-note-to-begin","text":"One thing to notice before we go much further is that we have a number of tools running at the same time to do our tests. Our Flask server that is launched when we type flask run in our terminal. This web server runs on your local machine, is not visible to the outside world, and listens at the IP address 127.0.0.1 on port 5000. In the URL bar, this will look like 127.0.0.1:5000 . Our Flask app that the Flask server calls when it receives requests. Our functional_test.py script, which opens a web browser to send particular requests to the Flask server, and evaluates the server's responses. I recommend, perhaps, diagramming these for yourself in some fashion if it helps you keep things in order.","title":"A note to begin:"},{"location":"ch2/#unittests","text":"Our last iteration of our app was extremely simple. It didn't even use any HTML and didn't properly return a web-page; just the string \"Hello, Flask!\" That's not particularly useful if we're trying to build a little web-app, but it's a start. Now we're moving on to bigger and better things. You'll actually have a proper webpage. Our first step will be to modify our functional test so that it looks for a title property. We'll alo add the story that Percival mentions So let's go to the functional test: from selenium import webdriver browser = webdriver.Firefox() # Edith (our test) has heard about a cool new online to-do app. She goes # to check out its homepage browser.get('http://127.0.0.1:5000') # or http://localhost:5000 # She notices the page title and header mention to-do lists assert 'To-Do' in browser.title # She is invited to enter a to-do item straight away # She types \"Buy peacock feathers\" into a text box (Edith's hobby # is tying fly-fishing lures) # When she hits enter, the page updates, and now the page lists # \"1: Buy peacock feathers\" as an item in a to-do list # There is still a text box inviting her to add another item. She # enters \"Use peacock feathers to make a fly\" (Edith is very methodical) # The page updates again, and now shows both items on her list # Edith wonders whether the site will remember her list. Then she sees # that the site has generated a unique URL for her -- there is some # explanatory text to that effect. # She visits that URL - her to-do list is still there. # Satisfied, she goes back to sleep browser.quit() functional_tests.py","title":"Unittests"},{"location":"ch2/#comments","text":"There are lot of opinions when it comes to how we add comments to our code. In a traditional CS program, we'd expect students to write extensive comments. This is to help the instructor see what you believe you are doing with a particular line of code or function. Likewise, the practice of writing such comments is useful for you to become conscious of what your code is doing. Comments can also be used as a sort of pseudocode to describe what functions your code will need to accomplish (as in the above example). In professional settings, there is a debate as to how many comments are necessary. On the one hand, some argue that your code should be clearly written enough that you don't need any comments. If your code needs comments to explain what's going on, you probably have a problem with your code. They also argue that if you change your code in the future without changing your comments, the comments can become misleading and more of a hinderance for future developers. On the other hand, some argue that comments provide crucial insight to you and other developers about what the code is supposed to do. They give future developers a sense of what you were thinking when you were writing the code. They are also important if you are writing an API or other code that future developers will extend. Additionally, comments are frequently used to generate documentation. For instance Sphinx and other documentation generation tools can automatically create docs based on the comments. Beyond all of this, if you're working for a company, that company will likely have its own approach to comments, and probably a majority of your first period there will be reading the code and comments that you will later be working on. This is all to say, you'll have to decide how much you want to comment your code based on the project. A general rule of thumb is that if the code doesn't obviously tell you what is happening, it's worth commenting. For example the first comment is probably not needed, but the second is (I also probably wouldn't write that generator just to save a few lines of code anyway): # Increment age by 1 age += 1 n = int(input(\"How many players? \")) # prompt users for name and age for each player age_map = {input(\"Name?\"): int(input(\"Age?\")) for i in range(n)}","title":"Comments"},{"location":"ch2/#back-to-our-tests","text":"If we start up our Flask server: (env) $ flask run and in another shell run our functional tests, you'll get an error like this: (env) $ python functional_tests.py Traceback (most recent call last): File \"functional_tests.py\", line 6, in <module> assert 'To-Do' in browser.title AssertionError We are getting the error that we are expecting! However, we want to move over to the unittest framework to make our test a little bit more robust. After all, we'll be building an entire testing suite for our application: every operation we want should be tested. This will be very similar to the test in Percival's book, but before that, take a moment to consider the unittest library.","title":"Back to our Tests"},{"location":"ch2/#unittest","text":"The unittest library is a framework for writing unit tests. A unit test is an automated test that checks the functionality of one unit of a particular application. For instance, one unit of our webpage is the title that shows up on the browser tab. A unit test will test that that is as it should be. Likewise, it might test a single function of our application. When writing a unit test, we need to provide all of the conditions or dependencies except the one variable that is being tested. So our browser title test needs to just test that the browser title contains particular content. It shouldn't check that the browser starts up or anything that appears on the page or that the URL is correct. A functional test is a test that checks a particular functionality of our application. For instance, a functional test might check that we can input a new item into a list and when we do so the item gets added to the database. Unlike a unit test that might have distinct tests for user input and writing to the database, the functional test tries to see that the components work together properly. Another way to think of this: unit tests check a discrete section of code. Functional tests simulate user experience. So, now lets update our functional_tests.py file. You'll notice that this is a functional test because it tests a component of our application as a user would encounter it. We'll write unittests later. from selenium import webdriver import unittest class NewVisitorTest(unittest.TestCase): def setUp(self): self.browser = webdriver.Firefox() def tearDown(self): self.browser.quit() def test_can_start_a_list_and_retrieve_it_later(self): # Call homepage self.browser.get('http://127.0.0.1:5000') # Old way: # assert 'To-Do' in browser.title # Using unittest methods self.assertIn('To-Do', self.browser.title) self.fail('Finish writing the test!') # She is invited to enter a to-do item straight away # She types \"Buy peacock feathers\" into a text box (Edith's hobby # is tying fly-fishing lures) # When she hits enter, the page updates, and now the page lists # \"1: Buy peacock feathers\" as an item in a to-do list # There is still a text box inviting her to add another item. She # enters \"Use peacock feathers to make a fly\" (Edith is very methodical) # The page updates again, and now shows both items on her list # Edith wonders whether the site will remember her list. Then she sees # that the site has generated a unique URL for her -- there is some # explanatory text to that effect. # She visits that URL - her to-do list is still there. # Satisfied, she goes back to sleep if __name__ in '__main__': unittest.main(warnings='ignore') Once again, we want to test it. If you stopped your Flask server, launch it again. Then let's run our functional tests and see the results: (env) $ python functional_tests.py F ====================================================================== FAIL: test_can_start_a_list_and_retrieve_it_later (__main__.NewVisitorTest) ---------------------------------------------------------------------- Traceback (most recent call last): File \"functional_tests.py\", line 20, in test_can_start_a_list_and_retrieve_it_later self.assertIn('To-Do', self.browser.title) AssertionError: 'To-Do' not found in '' ---------------------------------------------------------------------- Ran 1 test in 37.913s FAILED (failures=1) Woo! Our tests are failing as they should be. Notice, we haven't added anything to our app in this chapter, and that's intentional. We now have a test that will pass once our app is returning a page that has the correct title and that will be our next step. For now, it would be a good moment to commit your project and push it to github.","title":"unittest"}]}