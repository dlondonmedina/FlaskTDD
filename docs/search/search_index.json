{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TDD in Flask This book is a supplement to Test-Driven Development with Python: Obey the Testing Goat: Using Django, Selenium, and Javascript . In this version, much of the content is not copied over. Instead this provides modified exercises and examples using Flask instead of Django. If you have a bit more experience with Python or want to use a more robust framework, I encourage you to take a look at Percival's book. If you want to learn about test-driven development but find Flask suits your purposes better, this is a supplement for you. This book is being built for a course offered at Seattle University, and therefore will contain some additional content for that course. In the future, perhaps video lectures and exercises will become available. For the exercises, starter-code is available. Please feel free to clone it here . About the Author I direct the Web, Application, and Technology Studies program at Seattle University\u2019s School of New and Continuing Studies. My research and pedagogy are deeply invested learning and its application to future contexts. My MA and PhD research focuses on how students acquire and deploy rhetorical strategies and skills within the social, material, and technological landscapes in which they work. I teach in the areas of social theory, social science research, writing, web development, and Python. At heart, I am a maker and have devoted a great deal of energy to creating projects and programs to address problems I see in the world around me. This lead me to develop a transition workshop for service members, which I taught for four years at Joint Base Lewis-McChord. I also lead a team developing Cluster\u2014a suite of tools that work like a personal writing trainer. In the summer, I teach a Python camp for underrepresented kids. Acknowledgements This book is written by Dylan Medina and is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License . It is a Flask supplement for Test-Driven Development with Python by Harry J.W. Percival. Please visit his site and consider purchasing his excellent book. This book ports the exercises from Django to Flask.","title":"Home"},{"location":"#tdd-in-flask","text":"This book is a supplement to Test-Driven Development with Python: Obey the Testing Goat: Using Django, Selenium, and Javascript . In this version, much of the content is not copied over. Instead this provides modified exercises and examples using Flask instead of Django. If you have a bit more experience with Python or want to use a more robust framework, I encourage you to take a look at Percival's book. If you want to learn about test-driven development but find Flask suits your purposes better, this is a supplement for you. This book is being built for a course offered at Seattle University, and therefore will contain some additional content for that course. In the future, perhaps video lectures and exercises will become available. For the exercises, starter-code is available. Please feel free to clone it here .","title":"TDD in Flask"},{"location":"#about-the-author","text":"I direct the Web, Application, and Technology Studies program at Seattle University\u2019s School of New and Continuing Studies. My research and pedagogy are deeply invested learning and its application to future contexts. My MA and PhD research focuses on how students acquire and deploy rhetorical strategies and skills within the social, material, and technological landscapes in which they work. I teach in the areas of social theory, social science research, writing, web development, and Python. At heart, I am a maker and have devoted a great deal of energy to creating projects and programs to address problems I see in the world around me. This lead me to develop a transition workshop for service members, which I taught for four years at Joint Base Lewis-McChord. I also lead a team developing Cluster\u2014a suite of tools that work like a personal writing trainer. In the summer, I teach a Python camp for underrepresented kids.","title":"About the Author"},{"location":"#acknowledgements","text":"This book is written by Dylan Medina and is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License . It is a Flask supplement for Test-Driven Development with Python by Harry J.W. Percival. Please visit his site and consider purchasing his excellent book. This book ports the exercises from Django to Flask.","title":"Acknowledgements"},{"location":"ch1/","text":"Introduction to TDD There are many different approaches to developing software. One of the major ones that is used, especially in enterprise scale projects, is Test-Driven Development (TDD). TDD means that before we write any code we write a test that will determine if our code is functioning the way we want it to. For instance, let's say I want to build a function that returns a list of prime factors of an integer passed into the function. Let's also say, I want that function to return None if the value passed to the function is not an integer. If we are not using a TDD approach we might start by writing our function directly. However, we'll spend a lot of time debugging and running into issues if we do so. Instead, let's think about the things that we need to test: The easiest case is when the input is incorrect. We can set up a test that will call the function with a value that is not an integer and test that we receive None as the return. We need to test that the function returns a list when it is passed an integer. We need to test that the list contains the prime factors of the input integer. A simple and dirty way to test this is to write a driver that tests all of the functionality above. It might look something like this: if __name__ == \"__main__\": out1 = prime_factors(\"apple\") if out1 is None: print(\"Out is None. Pass\") else: print(\"Does not return None. Fail\") out2 = prime_factors(315) if isinstance(out2, list): print(\"Returns a list. Pass\") if out2 == [3, 5, 7]: print(\"Out is 3, 5, 7. Pass\") else: print(\"Does not return the right list. Fail\") else: print(\"Does not return a list. Fail) From there, I'd write out my function and make sure it's called prime_factors(). If you'd like, you can try using this method, and see if you can get it working. For a small, toy task like this, you might be able to sufficiently test your program with a driver, but you end up with a messy driver at the bottom of your program that you'll want to delete later on, and it's an awful lot of lines. Doctest Fortunately, Python includes a number of test tools that can help us do TDD more easily and make our tests more effective. The first of which is doctest , and it comes built-in with Python. Doctest allows you to write your tests into the docstring of your function. If you recall, a docstring is the bit of documentation this is included in triple double quotes when you define a function. The same tests as above would look like this: def prime_factors(n): \"\"\"Return list of prime factors of n or None if not integer >>> prime_factors(\"apple\") None It must return a list type object >>> out = prime_factors(315) >>> isinstance(out, list) True It must return the right list >>> prime_factors(315) [3, 5, 7] \"\"\" Please do take a moment to explore the doctest library. We have two options to run the test. First we can include this driver at the bottom of our module. if __name__ == \"__main__\": import doctest doctest.testmod() and then run the program from our terminal: (env) $ python prime_factors.py or we can leave the driver off and call the doctest module from the terminal (this won't work if there are many imports): (env) $ python -m doctest -v prime_factors.py I generally prefer to use the second route so that I don't have extra cruft in my program. That being said, I generally use unittest instead of doctest, so I don't spend a lot of time with this library. It is a good one, though. This time, go ahead and try this out. Unittest Another tool we use in TDD is testing suites. unittest is one such testing suite, and it includes various tools that help us write automated tests for our projects. Other options for automated testing that are very popular are pytest and nose. We will be using unittest in this class, but I do encourage you to explore some of the other options. I'll write up the same set of tests using unittest now. Please note that I will have two different files, one for my code, and one for my tests: prime_factors_tests.py import unittest import prime_factors as target #1 class TestPrimeFactors(unittest.TestCase): #2 def test_bad_input(self): #3 self.assertIsNone(target.prime_factors(\"apple\")) def test_returns_list(self): l = target.prime_factors(315) self.assertIsInstance(l, list) def test_returns_correct_list(self): l = target.prime_factors(315) self.assertEqual([3, 5, 7], l) Here are a few things to pay attention to: 1. We're importing our code to be tested, so we need to make sure it is in a file called prime_factors and is in the same directory as our test suite. 2. We create a new object to run the collection of tests. The rule is that our test class name must begin with the word Test and it must extend the unittest.TestCase class. We'll talk about inheritance next week with Objects. 3. Each test function should test one discrete case that could occur when the code runs (if we're doing unittests). See the bulleted list above. Also, notice that all of the test functions begin with the word \"test\" followed by some description of what the test is looking for in snake case. If you're following along, you should have two files in your directory. One with the tests and one that is empty for our code. If so, let's try to run our tests: $ python -m unittest prime_factors_tests.py EEE ====================================================================== ERROR: test_bad_input (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 8, in test_bad_input self.assertIsNone(target.prime_factors(\"apple\")) AttributeError: module 'prime_factors' has no attribute 'prime_factors' ====================================================================== ERROR: test_returns_correct_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 15, in test_returns_correct_list l = target.prime_factors(315) AttributeError: module 'prime_factors' has no attribute 'prime_factors' ====================================================================== ERROR: test_returns_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 11, in test_returns_list l = target.prime_factors(315) AttributeError: module 'prime_factors' has no attribute 'prime_factors' ---------------------------------------------------------------------- Ran 3 tests in 0.000s FAILED (errors=3) You'll notice that the tests failed, but they failed because of errors. This is because our file for the code is empty. We can remedy this by beginning to code: prime_factors.py def prime_factors(n): pass Notice that I'm working very incrementally and slowly. So I am expecting now all my tests will fail instead of throw errors. Here we go: $ python -m unittest prime_factors_tests.py .FF ====================================================================== FAIL: test_returns_correct_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 15, in test_returns_correct_list self.assertEqual([3, 5, 7], l) AssertionError: [3, 5, 7] != None ====================================================================== FAIL: test_returns_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 11, in test_returns_list self.assertIsInstance(l, list) AssertionError: None is not an instance of <class 'list'> ---------------------------------------------------------------------- Ran 3 tests in 0.000s FAILED (failures=2) We have to failures. You'll notice the first test is not failing. This is because our function currently is not returning anything, and no return is the same as None. So the test passes. I'm going to alter the code slightly just to get to the point where everything is failing. prime_factors.py def prime_factors(n): return -1 So we try one more time and we get three failures as expected: $ python -m unittest prime_factors_tests.py FFF ====================================================================== FAIL: test_bad_input (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 7, in test_bad_input self.assertIsNone(target.prime_factors(\"apple\")) AssertionError: -1 is not None ====================================================================== FAIL: test_returns_correct_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 15, in test_returns_correct_list self.assertEqual([3, 5, 7], l) AssertionError: [3, 5, 7] != -1 ====================================================================== FAIL: test_returns_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 11, in test_returns_list self.assertIsInstance(l, list) AssertionError: -1 is not an instance of <class 'list'> ---------------------------------------------------------------------- Ran 3 tests in 0.000s FAILED (failures=3) Failed tests are a good thing. First, we know that once all of my tests pass, if I did a good job designing them, then the code will be working properly and will be less likely to have bugs. Second, I can see that these are all failing exactly as I am expecting to, so the tests are working. I just need to write my code so it satisfies the tests. My first test is checking to make sure that the function returns none if the input is not an integer. So let's get that one ot pass: prime_factors.py def prime_factors(n): if isinstance(n, int): return -1 return None This change means that the only case in which the function will not return None is if n is an integer. Let's run our tests and see: $ python -m unittest prime_factors_tests.py .FF ====================================================================== FAIL: test_returns_correct_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 15, in test_returns_correct_list self.assertEqual([3, 5, 7], l) AssertionError: [3, 5, 7] != -1 ====================================================================== FAIL: test_returns_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 11, in test_returns_list self.assertIsInstance(l, list) AssertionError: -1 is not an instance of <class 'list'> ---------------------------------------------------------------------- Ran 3 tests in 0.000s FAILED (failures=2) You'll notice that our tests still fail, but the first test passed. That's great and means progress! Now we just need to get our other tests to pass. We could have the function return an empty list to get the second test to pass, but I'm just going to finish off the code and get both tests passing at the same time. There might be some debate as to whether we should test both that the function returns a list and returns the correct list. We could say if we're testing for the correct list, we don't need to also test that the function returns a list. prime_factors.py import math def prime_factors(n): if isinstance(n, int): out = [] if n % 2 == 0: out.append(2) while n % 2 == 0: n = n / 2 for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: out.append(i) while n % i == 0: n = n / i if n > 2: out.append(n) return out return None Success! We're done! $ python -m unittest prime_factors_tests.py ... ---------------------------------------------------------------------- Ran 3 tests in 0.000s OK In the next chapter we'll be discussing different types of tests (End to End, Functional, and Unit Tests).","title":"Intro to TDD"},{"location":"ch1/#introduction-to-tdd","text":"There are many different approaches to developing software. One of the major ones that is used, especially in enterprise scale projects, is Test-Driven Development (TDD). TDD means that before we write any code we write a test that will determine if our code is functioning the way we want it to. For instance, let's say I want to build a function that returns a list of prime factors of an integer passed into the function. Let's also say, I want that function to return None if the value passed to the function is not an integer. If we are not using a TDD approach we might start by writing our function directly. However, we'll spend a lot of time debugging and running into issues if we do so. Instead, let's think about the things that we need to test: The easiest case is when the input is incorrect. We can set up a test that will call the function with a value that is not an integer and test that we receive None as the return. We need to test that the function returns a list when it is passed an integer. We need to test that the list contains the prime factors of the input integer. A simple and dirty way to test this is to write a driver that tests all of the functionality above. It might look something like this: if __name__ == \"__main__\": out1 = prime_factors(\"apple\") if out1 is None: print(\"Out is None. Pass\") else: print(\"Does not return None. Fail\") out2 = prime_factors(315) if isinstance(out2, list): print(\"Returns a list. Pass\") if out2 == [3, 5, 7]: print(\"Out is 3, 5, 7. Pass\") else: print(\"Does not return the right list. Fail\") else: print(\"Does not return a list. Fail) From there, I'd write out my function and make sure it's called prime_factors(). If you'd like, you can try using this method, and see if you can get it working. For a small, toy task like this, you might be able to sufficiently test your program with a driver, but you end up with a messy driver at the bottom of your program that you'll want to delete later on, and it's an awful lot of lines.","title":"Introduction to TDD"},{"location":"ch1/#doctest","text":"Fortunately, Python includes a number of test tools that can help us do TDD more easily and make our tests more effective. The first of which is doctest , and it comes built-in with Python. Doctest allows you to write your tests into the docstring of your function. If you recall, a docstring is the bit of documentation this is included in triple double quotes when you define a function. The same tests as above would look like this: def prime_factors(n): \"\"\"Return list of prime factors of n or None if not integer >>> prime_factors(\"apple\") None It must return a list type object >>> out = prime_factors(315) >>> isinstance(out, list) True It must return the right list >>> prime_factors(315) [3, 5, 7] \"\"\" Please do take a moment to explore the doctest library. We have two options to run the test. First we can include this driver at the bottom of our module. if __name__ == \"__main__\": import doctest doctest.testmod() and then run the program from our terminal: (env) $ python prime_factors.py or we can leave the driver off and call the doctest module from the terminal (this won't work if there are many imports): (env) $ python -m doctest -v prime_factors.py I generally prefer to use the second route so that I don't have extra cruft in my program. That being said, I generally use unittest instead of doctest, so I don't spend a lot of time with this library. It is a good one, though. This time, go ahead and try this out.","title":"Doctest"},{"location":"ch1/#unittest","text":"Another tool we use in TDD is testing suites. unittest is one such testing suite, and it includes various tools that help us write automated tests for our projects. Other options for automated testing that are very popular are pytest and nose. We will be using unittest in this class, but I do encourage you to explore some of the other options. I'll write up the same set of tests using unittest now. Please note that I will have two different files, one for my code, and one for my tests: prime_factors_tests.py import unittest import prime_factors as target #1 class TestPrimeFactors(unittest.TestCase): #2 def test_bad_input(self): #3 self.assertIsNone(target.prime_factors(\"apple\")) def test_returns_list(self): l = target.prime_factors(315) self.assertIsInstance(l, list) def test_returns_correct_list(self): l = target.prime_factors(315) self.assertEqual([3, 5, 7], l) Here are a few things to pay attention to: 1. We're importing our code to be tested, so we need to make sure it is in a file called prime_factors and is in the same directory as our test suite. 2. We create a new object to run the collection of tests. The rule is that our test class name must begin with the word Test and it must extend the unittest.TestCase class. We'll talk about inheritance next week with Objects. 3. Each test function should test one discrete case that could occur when the code runs (if we're doing unittests). See the bulleted list above. Also, notice that all of the test functions begin with the word \"test\" followed by some description of what the test is looking for in snake case. If you're following along, you should have two files in your directory. One with the tests and one that is empty for our code. If so, let's try to run our tests: $ python -m unittest prime_factors_tests.py EEE ====================================================================== ERROR: test_bad_input (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 8, in test_bad_input self.assertIsNone(target.prime_factors(\"apple\")) AttributeError: module 'prime_factors' has no attribute 'prime_factors' ====================================================================== ERROR: test_returns_correct_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 15, in test_returns_correct_list l = target.prime_factors(315) AttributeError: module 'prime_factors' has no attribute 'prime_factors' ====================================================================== ERROR: test_returns_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 11, in test_returns_list l = target.prime_factors(315) AttributeError: module 'prime_factors' has no attribute 'prime_factors' ---------------------------------------------------------------------- Ran 3 tests in 0.000s FAILED (errors=3) You'll notice that the tests failed, but they failed because of errors. This is because our file for the code is empty. We can remedy this by beginning to code: prime_factors.py def prime_factors(n): pass Notice that I'm working very incrementally and slowly. So I am expecting now all my tests will fail instead of throw errors. Here we go: $ python -m unittest prime_factors_tests.py .FF ====================================================================== FAIL: test_returns_correct_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 15, in test_returns_correct_list self.assertEqual([3, 5, 7], l) AssertionError: [3, 5, 7] != None ====================================================================== FAIL: test_returns_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 11, in test_returns_list self.assertIsInstance(l, list) AssertionError: None is not an instance of <class 'list'> ---------------------------------------------------------------------- Ran 3 tests in 0.000s FAILED (failures=2) We have to failures. You'll notice the first test is not failing. This is because our function currently is not returning anything, and no return is the same as None. So the test passes. I'm going to alter the code slightly just to get to the point where everything is failing. prime_factors.py def prime_factors(n): return -1 So we try one more time and we get three failures as expected: $ python -m unittest prime_factors_tests.py FFF ====================================================================== FAIL: test_bad_input (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 7, in test_bad_input self.assertIsNone(target.prime_factors(\"apple\")) AssertionError: -1 is not None ====================================================================== FAIL: test_returns_correct_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 15, in test_returns_correct_list self.assertEqual([3, 5, 7], l) AssertionError: [3, 5, 7] != -1 ====================================================================== FAIL: test_returns_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 11, in test_returns_list self.assertIsInstance(l, list) AssertionError: -1 is not an instance of <class 'list'> ---------------------------------------------------------------------- Ran 3 tests in 0.000s FAILED (failures=3) Failed tests are a good thing. First, we know that once all of my tests pass, if I did a good job designing them, then the code will be working properly and will be less likely to have bugs. Second, I can see that these are all failing exactly as I am expecting to, so the tests are working. I just need to write my code so it satisfies the tests. My first test is checking to make sure that the function returns none if the input is not an integer. So let's get that one ot pass: prime_factors.py def prime_factors(n): if isinstance(n, int): return -1 return None This change means that the only case in which the function will not return None is if n is an integer. Let's run our tests and see: $ python -m unittest prime_factors_tests.py .FF ====================================================================== FAIL: test_returns_correct_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 15, in test_returns_correct_list self.assertEqual([3, 5, 7], l) AssertionError: [3, 5, 7] != -1 ====================================================================== FAIL: test_returns_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 11, in test_returns_list self.assertIsInstance(l, list) AssertionError: -1 is not an instance of <class 'list'> ---------------------------------------------------------------------- Ran 3 tests in 0.000s FAILED (failures=2) You'll notice that our tests still fail, but the first test passed. That's great and means progress! Now we just need to get our other tests to pass. We could have the function return an empty list to get the second test to pass, but I'm just going to finish off the code and get both tests passing at the same time. There might be some debate as to whether we should test both that the function returns a list and returns the correct list. We could say if we're testing for the correct list, we don't need to also test that the function returns a list. prime_factors.py import math def prime_factors(n): if isinstance(n, int): out = [] if n % 2 == 0: out.append(2) while n % 2 == 0: n = n / 2 for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: out.append(i) while n % i == 0: n = n / i if n > 2: out.append(n) return out return None Success! We're done! $ python -m unittest prime_factors_tests.py ... ---------------------------------------------------------------------- Ran 3 tests in 0.000s OK In the next chapter we'll be discussing different types of tests (End to End, Functional, and Unit Tests).","title":"Unittest"},{"location":"ch10/","text":"Introducing the unittest Module A note to begin: One thing to notice before we go much further is that we have a number of tools running at the same time to do our tests. Our Flask server that is launched when we type flask run in our terminal. This web server runs on your local machine, is not visible to the outside world, and listens at the IP address 127.0.0.1 on port 5000. In the URL bar, this will look like 127.0.0.1:5000 . Our Flask app that the Flask server calls when it receives requests. Our functional_test.py script, which opens a web browser to send particular requests to the Flask server, and evaluates the server's responses. I recommend, perhaps, diagramming these for yourself in some fashion if it helps you keep things in order. Unittests Our last iteration of our app was extremely simple. It didn't even use any HTML and didn't properly return a web-page; just the string \"Hello, Flask!\" That's not particularly useful if we're trying to build a little web-app, but it's a start. Now we're moving on to bigger and better things. You'll actually have a proper webpage. Our first step will be to modify our functional test so that it looks for a title property. We'll alo add the story that Percival mentions So let's go to the functional test: from selenium import webdriver browser = webdriver.Firefox() # Edith (our test) has heard about a cool new online to-do app. She goes # to check out its homepage browser.get('http://127.0.0.1:5000') # or http://localhost:5000 # She notices the page title and header mention to-do lists assert 'To-Do' in browser.title # She is invited to enter a to-do item straight away # She types \"Buy peacock feathers\" into a text box (Edith's hobby # is tying fly-fishing lures) # When she hits enter, the page updates, and now the page lists # \"1: Buy peacock feathers\" as an item in a to-do list # There is still a text box inviting her to add another item. She # enters \"Use peacock feathers to make a fly\" (Edith is very methodical) # The page updates again, and now shows both items on her list # Edith wonders whether the site will remember her list. Then she sees # that the site has generated a unique URL for her -- there is some # explanatory text to that effect. # She visits that URL - her to-do list is still there. # Satisfied, she goes back to sleep browser.quit() functional_tests.py Comments There are lot of opinions when it comes to how we add comments to our code. In a traditional CS program, we'd expect students to write extensive comments. This is to help the instructor see what you believe you are doing with a particular line of code or function. Likewise, the practice of writing such comments is useful for you to become conscious of what your code is doing. Comments can also be used as a sort of pseudocode to describe what functions your code will need to accomplish (as in the above example). In professional settings, there is a debate as to how many comments are necessary. On the one hand, some argue that your code should be clearly written enough that you don't need any comments. If your code needs comments to explain what's going on, you probably have a problem with your code. They also argue that if you change your code in the future without changing your comments, the comments can become misleading and more of a hinderance for future developers. On the other hand, some argue that comments provide crucial insight to you and other developers about what the code is supposed to do. They give future developers a sense of what you were thinking when you were writing the code. They are also important if you are writing an API or other code that future developers will extend. Additionally, comments are frequently used to generate documentation. For instance Sphinx and other documentation generation tools can automatically create docs based on the comments. Beyond all of this, if you're working for a company, that company will likely have its own approach to comments, and probably a majority of your first period there will be reading the code and comments that you will later be working on. This is all to say, you'll have to decide how much you want to comment your code based on the project. A general rule of thumb is that if the code doesn't obviously tell you what is happening, it's worth commenting. For example the first comment is probably not needed, but the second is (I also probably wouldn't write that generator just to save a few lines of code anyway): # Increment age by 1 age += 1 n = int(input(\"How many players? \")) # prompt users for name and age for each player age_map = {input(\"Name?\"): int(input(\"Age?\")) for i in range(n)} Back to our Tests If we start up our Flask server: (env) $ flask run and in another shell run our functional tests, you'll get an error like this: (env) $ python functional_tests.py Traceback (most recent call last): File \"functional_tests.py\", line 6, in <module> assert 'To-Do' in browser.title AssertionError We are getting the error that we are expecting! However, we want to move over to the unittest framework to make our test a little bit more robust. After all, we'll be building an entire testing suite for our application: every operation we want should be tested. This will be very similar to the test in Percival's book, but before that, take a moment to consider the unittest library. unittest The unittest library is a framework for writing unit tests. A unit test is an automated test that checks the functionality of one unit of a particular application. For instance, one unit of our webpage is the title that shows up on the browser tab. A unit test will test that that is as it should be. Likewise, it might test a single function of our application. When writing a unit test, we need to provide all of the conditions or dependencies except the one variable that is being tested. So our browser title test needs to just test that the browser title contains particular content. It shouldn't check that the browser starts up or anything that appears on the page or that the URL is correct. A functional test is a test that checks a particular functionality of our application. For instance, a functional test might check that we can input a new item into a list and when we do so the item gets added to the database. Unlike a unit test that might have distinct tests for user input and writing to the database, the functional test tries to see that the components work together properly. Another way to think of this: unit tests check a discrete section of code. Functional tests simulate user experience. So, now lets update our functional_tests.py file. You'll notice that this is a functional test because it tests a component of our application as a user would encounter it. We'll write unittests later. from selenium import webdriver import unittest class NewVisitorTest(unittest.TestCase): def setUp(self): self.browser = webdriver.Firefox() def tearDown(self): self.browser.quit() def test_can_start_a_list_and_retrieve_it_later(self): # Call homepage self.browser.get('http://127.0.0.1:5000') # Old way: # assert 'To-Do' in browser.title # Using unittest methods self.assertIn('To-Do', self.browser.title) self.fail('Finish writing the test!') # She is invited to enter a to-do item straight away # She types \"Buy peacock feathers\" into a text box (Edith's hobby # is tying fly-fishing lures) # When she hits enter, the page updates, and now the page lists # \"1: Buy peacock feathers\" as an item in a to-do list # There is still a text box inviting her to add another item. She # enters \"Use peacock feathers to make a fly\" (Edith is very methodical) # The page updates again, and now shows both items on her list # Edith wonders whether the site will remember her list. Then she sees # that the site has generated a unique URL for her -- there is some # explanatory text to that effect. # She visits that URL - her to-do list is still there. # Satisfied, she goes back to sleep if __name__ in '__main__': unittest.main(warnings='ignore') Once again, we want to test it. If you stopped your Flask server, launch it again. Then let's run our functional tests and see the results: (env) $ python functional_tests.py F ====================================================================== FAIL: test_can_start_a_list_and_retrieve_it_later (__main__.NewVisitorTest) ---------------------------------------------------------------------- Traceback (most recent call last): File \"functional_tests.py\", line 20, in test_can_start_a_list_and_retrieve_it_later self.assertIn('To-Do', self.browser.title) AssertionError: 'To-Do' not found in '' ---------------------------------------------------------------------- Ran 1 test in 37.913s FAILED (failures=1) Woo! Our tests are failing as they should be. Notice, we haven't added anything to our app in this chapter, and that's intentional. We now have a test that will pass once our app is returning a page that has the correct title and that will be our next step. For now, it would be a good moment to commit your project and push it to github.","title":"Introducing the unittest Module"},{"location":"ch10/#introducing-the-unittest-module","text":"","title":"Introducing the unittest Module"},{"location":"ch10/#a-note-to-begin","text":"One thing to notice before we go much further is that we have a number of tools running at the same time to do our tests. Our Flask server that is launched when we type flask run in our terminal. This web server runs on your local machine, is not visible to the outside world, and listens at the IP address 127.0.0.1 on port 5000. In the URL bar, this will look like 127.0.0.1:5000 . Our Flask app that the Flask server calls when it receives requests. Our functional_test.py script, which opens a web browser to send particular requests to the Flask server, and evaluates the server's responses. I recommend, perhaps, diagramming these for yourself in some fashion if it helps you keep things in order.","title":"A note to begin:"},{"location":"ch10/#unittests","text":"Our last iteration of our app was extremely simple. It didn't even use any HTML and didn't properly return a web-page; just the string \"Hello, Flask!\" That's not particularly useful if we're trying to build a little web-app, but it's a start. Now we're moving on to bigger and better things. You'll actually have a proper webpage. Our first step will be to modify our functional test so that it looks for a title property. We'll alo add the story that Percival mentions So let's go to the functional test: from selenium import webdriver browser = webdriver.Firefox() # Edith (our test) has heard about a cool new online to-do app. She goes # to check out its homepage browser.get('http://127.0.0.1:5000') # or http://localhost:5000 # She notices the page title and header mention to-do lists assert 'To-Do' in browser.title # She is invited to enter a to-do item straight away # She types \"Buy peacock feathers\" into a text box (Edith's hobby # is tying fly-fishing lures) # When she hits enter, the page updates, and now the page lists # \"1: Buy peacock feathers\" as an item in a to-do list # There is still a text box inviting her to add another item. She # enters \"Use peacock feathers to make a fly\" (Edith is very methodical) # The page updates again, and now shows both items on her list # Edith wonders whether the site will remember her list. Then she sees # that the site has generated a unique URL for her -- there is some # explanatory text to that effect. # She visits that URL - her to-do list is still there. # Satisfied, she goes back to sleep browser.quit() functional_tests.py","title":"Unittests"},{"location":"ch10/#comments","text":"There are lot of opinions when it comes to how we add comments to our code. In a traditional CS program, we'd expect students to write extensive comments. This is to help the instructor see what you believe you are doing with a particular line of code or function. Likewise, the practice of writing such comments is useful for you to become conscious of what your code is doing. Comments can also be used as a sort of pseudocode to describe what functions your code will need to accomplish (as in the above example). In professional settings, there is a debate as to how many comments are necessary. On the one hand, some argue that your code should be clearly written enough that you don't need any comments. If your code needs comments to explain what's going on, you probably have a problem with your code. They also argue that if you change your code in the future without changing your comments, the comments can become misleading and more of a hinderance for future developers. On the other hand, some argue that comments provide crucial insight to you and other developers about what the code is supposed to do. They give future developers a sense of what you were thinking when you were writing the code. They are also important if you are writing an API or other code that future developers will extend. Additionally, comments are frequently used to generate documentation. For instance Sphinx and other documentation generation tools can automatically create docs based on the comments. Beyond all of this, if you're working for a company, that company will likely have its own approach to comments, and probably a majority of your first period there will be reading the code and comments that you will later be working on. This is all to say, you'll have to decide how much you want to comment your code based on the project. A general rule of thumb is that if the code doesn't obviously tell you what is happening, it's worth commenting. For example the first comment is probably not needed, but the second is (I also probably wouldn't write that generator just to save a few lines of code anyway): # Increment age by 1 age += 1 n = int(input(\"How many players? \")) # prompt users for name and age for each player age_map = {input(\"Name?\"): int(input(\"Age?\")) for i in range(n)}","title":"Comments"},{"location":"ch10/#back-to-our-tests","text":"If we start up our Flask server: (env) $ flask run and in another shell run our functional tests, you'll get an error like this: (env) $ python functional_tests.py Traceback (most recent call last): File \"functional_tests.py\", line 6, in <module> assert 'To-Do' in browser.title AssertionError We are getting the error that we are expecting! However, we want to move over to the unittest framework to make our test a little bit more robust. After all, we'll be building an entire testing suite for our application: every operation we want should be tested. This will be very similar to the test in Percival's book, but before that, take a moment to consider the unittest library.","title":"Back to our Tests"},{"location":"ch10/#unittest","text":"The unittest library is a framework for writing unit tests. A unit test is an automated test that checks the functionality of one unit of a particular application. For instance, one unit of our webpage is the title that shows up on the browser tab. A unit test will test that that is as it should be. Likewise, it might test a single function of our application. When writing a unit test, we need to provide all of the conditions or dependencies except the one variable that is being tested. So our browser title test needs to just test that the browser title contains particular content. It shouldn't check that the browser starts up or anything that appears on the page or that the URL is correct. A functional test is a test that checks a particular functionality of our application. For instance, a functional test might check that we can input a new item into a list and when we do so the item gets added to the database. Unlike a unit test that might have distinct tests for user input and writing to the database, the functional test tries to see that the components work together properly. Another way to think of this: unit tests check a discrete section of code. Functional tests simulate user experience. So, now lets update our functional_tests.py file. You'll notice that this is a functional test because it tests a component of our application as a user would encounter it. We'll write unittests later. from selenium import webdriver import unittest class NewVisitorTest(unittest.TestCase): def setUp(self): self.browser = webdriver.Firefox() def tearDown(self): self.browser.quit() def test_can_start_a_list_and_retrieve_it_later(self): # Call homepage self.browser.get('http://127.0.0.1:5000') # Old way: # assert 'To-Do' in browser.title # Using unittest methods self.assertIn('To-Do', self.browser.title) self.fail('Finish writing the test!') # She is invited to enter a to-do item straight away # She types \"Buy peacock feathers\" into a text box (Edith's hobby # is tying fly-fishing lures) # When she hits enter, the page updates, and now the page lists # \"1: Buy peacock feathers\" as an item in a to-do list # There is still a text box inviting her to add another item. She # enters \"Use peacock feathers to make a fly\" (Edith is very methodical) # The page updates again, and now shows both items on her list # Edith wonders whether the site will remember her list. Then she sees # that the site has generated a unique URL for her -- there is some # explanatory text to that effect. # She visits that URL - her to-do list is still there. # Satisfied, she goes back to sleep if __name__ in '__main__': unittest.main(warnings='ignore') Once again, we want to test it. If you stopped your Flask server, launch it again. Then let's run our functional tests and see the results: (env) $ python functional_tests.py F ====================================================================== FAIL: test_can_start_a_list_and_retrieve_it_later (__main__.NewVisitorTest) ---------------------------------------------------------------------- Traceback (most recent call last): File \"functional_tests.py\", line 20, in test_can_start_a_list_and_retrieve_it_later self.assertIn('To-Do', self.browser.title) AssertionError: 'To-Do' not found in '' ---------------------------------------------------------------------- Ran 1 test in 37.913s FAILED (failures=1) Woo! Our tests are failing as they should be. Notice, we haven't added anything to our app in this chapter, and that's intentional. We now have a test that will pass once our app is returning a page that has the correct title and that will be our next step. For now, it would be a good moment to commit your project and push it to github.","title":"unittest"},{"location":"ch11/","text":"Your Flask App We will be building the Superlists app in Flask. The approach and the code will be a bit different, but our tests will be pretty close to the Django Superlists apps discussed in Percival's book . Since Flask is a microframework, we don't have the same CLI to build a new application or feature within our app. In Django, when you run the command $ python manage.py startapp lists Django creates a brand new app with a bunch of files associated with that application. It includes an admin interface, all of your database models, and your views. This makes building with Django relatively easy and quick, but on the other hand, if you are, say, building an app that doesn't require a database or admin interface or users, then Django gives you a lot of extra stuff that you don't need, still needs to be maintained, and might contain vulnerabilities that will be patched in the future. How do we start our app with Flask?","title":"Your Flask App"},{"location":"ch11/#your-flask-app","text":"We will be building the Superlists app in Flask. The approach and the code will be a bit different, but our tests will be pretty close to the Django Superlists apps discussed in Percival's book . Since Flask is a microframework, we don't have the same CLI to build a new application or feature within our app. In Django, when you run the command $ python manage.py startapp lists Django creates a brand new app with a bunch of files associated with that application. It includes an admin interface, all of your database models, and your views. This makes building with Django relatively easy and quick, but on the other hand, if you are, say, building an app that doesn't require a database or admin interface or users, then Django gives you a lot of extra stuff that you don't need, still needs to be maintained, and might contain vulnerabilities that will be patched in the future. How do we start our app with Flask?","title":"Your Flask App"},{"location":"ch2/","text":"Types of Tests In the first chapter we looked at an example of how to use a few different tools to test our programs. We saw how we might write a set of tests first before we write any code, and then write our code so that it passes the unit tests. We do this for a few reasons. Tests force us to think of testable actions our code might perform. This means we need to figure out what specific action or output our code should have before we write it. That's a good practice. Tests force us to consider what conditions should be passing and what conditions should be failing for our code. Tests will tell us immediately when we have written enough code. Tests can help us constrain how many features our code base has. We can only build what we've written tests for. Tests yield less buggy code and cut down on debugging time. We know our code works when it passes the tests. Now does this all mean that TDD will give us perfect code? No, it's intirely possible to write code that is full of bugs that still passes our tests and functions. There are four main categories of tests: unit tests, functional tests, and end-to-end tests. An important concept to understand before we dive into these approaches is white box and black box testing. White box testing is concerned with the inner workings of your application. This means that it tests how your functions are doing the work that they are supposed to do. White box testing cares about the code itself. Black box testing, on the other hand, is concerned with whether your application works or not. This is an important distinction, and you might think of it in these terms. Developers are concerned with white box testing because it ensures that their code has minimal bugs and achieves the correct results the way it's supposed to. Business managers are concerned with black box testing because it ensures that the code is meeting the product requirements. Unit Testing Unit testing is white box testing and involves testing individual units or individual processes in your code free from their dependencies. A good way to think about this is that unit testing should test individual funtions--even if that function is never called independently by the user. In the last chapter, I walked through the process of writing tests for a particular function, but let's look at another example. Let's say we are working on a project to build word cloud visualizations. These word clouds display the words in a text in a cloud pattern sized by frequency of each word. If we decided not to use the builtin count function in Python, we could go about building our own. This means I need a function that will take a given text, iterate through the words and count the frequency of each word. I also don't want to use the count function (for this example at least). I also want the function to be able to adjust for case sensitivity or not. Here are pre and post conditions that should be present if this function works correctly: The function should take a string as an input. It may or may not take a case as a second input, but that second input must be a boolean. The function should return some code if the input is wrong. The function should return a dictionary with words as keys and their count as values for each word in the text passage. This means I'll have seven tests that will, when passing, show me that under the right circumstances, my function is working, and if the wrong input is given to my function, it returns the right error code. Let's write some tests together again. I'll go wordcloud_tests.py import unittest import wordcloud as t class TestWordCloud(unittest.TestCase): def setUp(self): self.text = \"Peter peter of Pickeled Pepper pepper Pepper\" self.sensitive = { 'Peter': 1, 'peter': 1, 'of': 1, 'Pickeled': 1, 'Pepper': 2, 'pepper': 2 } self.insensitive = { 'peter': 2, 'of': 1, 'pickeled': 1, 'pepper': 4 } def test_returns_error_code_on_bad_text(self): self.assertEqual(t.word_count(1), -1) def test_returns_error_code_on_bad_case(self): self.assertEqual(t.word_count('Pass', 11), -1) def test_case_sensitive(self): self.assertEqual(t.word_count(self.text, True), self.sensitive) def test_case_insensitve(self): self.assertEqual(t.word_count(self.text), self.insensitive) There are two options when writing tests and writing production code. You can either write a test, then write code to pass the test, then write another test and get that one to pass, or you can write a set of tests for one particular function and then write code to get them all to pass. In this case, I wrote all of my tests first, and it gives me a sort of todo list. I know I have to write code to get all of these tests to pass, and I should only write that much code. First I'll write the code that gets the first two tests passing. wordcloud.py def word_count(text, case): return -1 The first two tests will pass, but the second two tests will fail once I've written this code. Notice that I don't have any logic in this function, but simply a return statement that will pass the test. I like this approach because it is very little code to write, and still it satisfies the test cases. Next I want to write the code to get the case sensitive version to work. wordcloud.py def word_count(text, case): if isinstance(text, str) and isinstance(case, bool): counts = {} for word in text.split(): if word in counts.keys(): counts[word] += 1 else: counts[word] = 1 return counts return -1 Once again, you can try this out, but all of the tests except for the last one should be passing now. We're making progress, but now I need to think about how I want to implement the case where we don't want to be case sensitive. An easy way to do this is simply set all the words to lower case and then use the same logic as above. def word_count(text, case): if isinstance(text, str) and isinstance(case, bool): counts = {} if not case: text = text.lower() for word in text.split(): if word in counts.keys(): counts[word] += 1 else: counts[word] = 1 return counts return -1 Now all of my tests are passing, but there's one more feature I want to add. Since word clouds often are used to show the importance of meaningful words, I want to not count words that contain digits or are just string representations of numbers. So if my text included \"dinn3r\" or \"2\", those strings should be ignored. I might be tempted to implement this directly, but I need to write tests first, and I'll just add them to the test code I already have (notice I changed the text to be checked): wordcloud_tests.py import unittest import wordcloud as t class TestWordCloud(unittest.TestCase): def setUp(self): self.text = \"Peter peter of Pickeled \\ Pepper pepper Pepper 123 p3pper\" self.sensitive = { 'Peter': 1, 'peter': 1, 'of': 1, 'Pickeled': 1, 'Pepper': 2, 'pepper': 2 } self.insensitive = { 'peter': 2, 'of': 1, 'pickeled': 1, 'pepper': 4 } def test_returns_error_code_on_bad_text(self): self.assertEqual(t.word_count(1), -1) def test_returns_error_code_on_bad_case(self): self.assertEqual(t.word_count('Pass', 11), -1) def test_case_sensitive(self): self.assertEqual(t.word_count(self.text, True), self.sensitive) def test_case_insensitve(self): self.assertEqual(t.word_count(self.text), self.insensitive) def test_ignores_digits(self): self.assertEqual(t.word_count(self.text), self.insensitive) Next, write code to get that test to pass. wordcloud.py def word_count(text, case): if isinstance(text, str) and isinstance(case, bool): counts = {} if not case: text = text.lower() for word in text.split(): # make sure no characters in the word are digits if not any(map(word.isdigit, word)): if word in counts.keys(): counts[word] += 1 else: counts[word] = 1 return counts return -1 All of my tests are passing now, so basically I know that my code is working as expected. I haven't done anything to ensure that the user uses the code correctly, but at this point that's okay. There's just one more small change I would like to make and add some documentation. I want to make case a kwarg instead of an arg. I want to do this so I can set a default setting. I want the function to not be case sensitive unless it is asked to be sensitive. Kwargs are cool because you can set a default value for an argument, and that makes it so that we don't need to pass True or False to the function in some of the cases. Only when we want to be case sensitive. I made a small refactor as below with documentation added. wordcloud.py def word_count(text, case=False): \"\"\" This function calculates word frequency in a text. This function should not count digit strings. Args: text (str): the text to be searched. Kwargs: case (bool): Should the search be case sensive Returns: dict. counts keyed by word, or return code:: -1 -- Error \"\"\" if isinstance(text, str) and isinstance(case, bool): counts = {} for word in text.split(): if not any(map(word.isdigit, word)): if not case: word = word.lower() if word in counts.keys(): counts[word] += 1 else: counts[word] = 1 return counts return -1 Functional Testing If unit tests test to see if the code is working correctly, functional tests test to see if a particular functionality of a program is working correctly. This means we are not so concerned with the inner workings of our functions, but instead we are concerned with the functions that an application provides a user. We will cover functional tests as we start building our Flask app, but imagine for now our word cloud application. The user enters a text file and the application creates an image object based on the text. For a functional test, I'd create a mockup of an expected image object based on a particular text, and then pass that text to the function and compare the output with the expected like so: functional_tests.py import unittest import wordcloud as t class TestWordCloudFunctional(unittest.TestCase): def setUp(self): self.text = \"My text ...\" self.cloud = '' with open('img.png', 'rb') as f: self.cloud = f.read() def test_can_create_word_cloud(self): self.assertEqual(t.make_cloud(self.text), self.cloud) I'm imagining that we'll have to create a function called make_cloud, which probably will call the word_cound and so on. End to End (E2E) Testing These tests make use of the user interface that you've developed and are like functional tests, but instead of testing one function of your code, they would test a sequence of functions that a user might use. For instance, if I was making a calculator, my E2E test might begin by launching the calculator, perform a series of calculations and then close the calculator. Alternatively, if I was creating a sign-up function for a website, an E2E test would test that through the user interface a new user can be created, saved to whatever storage solution we have for that data, test the user can login, and then log back out again. We won't be developing any E2E tests in this class because we'll be focusing on a very small application that can be tested with functional and unit tests.","title":"Types of Tests"},{"location":"ch2/#types-of-tests","text":"In the first chapter we looked at an example of how to use a few different tools to test our programs. We saw how we might write a set of tests first before we write any code, and then write our code so that it passes the unit tests. We do this for a few reasons. Tests force us to think of testable actions our code might perform. This means we need to figure out what specific action or output our code should have before we write it. That's a good practice. Tests force us to consider what conditions should be passing and what conditions should be failing for our code. Tests will tell us immediately when we have written enough code. Tests can help us constrain how many features our code base has. We can only build what we've written tests for. Tests yield less buggy code and cut down on debugging time. We know our code works when it passes the tests. Now does this all mean that TDD will give us perfect code? No, it's intirely possible to write code that is full of bugs that still passes our tests and functions. There are four main categories of tests: unit tests, functional tests, and end-to-end tests. An important concept to understand before we dive into these approaches is white box and black box testing. White box testing is concerned with the inner workings of your application. This means that it tests how your functions are doing the work that they are supposed to do. White box testing cares about the code itself. Black box testing, on the other hand, is concerned with whether your application works or not. This is an important distinction, and you might think of it in these terms. Developers are concerned with white box testing because it ensures that their code has minimal bugs and achieves the correct results the way it's supposed to. Business managers are concerned with black box testing because it ensures that the code is meeting the product requirements.","title":"Types of Tests"},{"location":"ch2/#unit-testing","text":"Unit testing is white box testing and involves testing individual units or individual processes in your code free from their dependencies. A good way to think about this is that unit testing should test individual funtions--even if that function is never called independently by the user. In the last chapter, I walked through the process of writing tests for a particular function, but let's look at another example. Let's say we are working on a project to build word cloud visualizations. These word clouds display the words in a text in a cloud pattern sized by frequency of each word. If we decided not to use the builtin count function in Python, we could go about building our own. This means I need a function that will take a given text, iterate through the words and count the frequency of each word. I also don't want to use the count function (for this example at least). I also want the function to be able to adjust for case sensitivity or not. Here are pre and post conditions that should be present if this function works correctly: The function should take a string as an input. It may or may not take a case as a second input, but that second input must be a boolean. The function should return some code if the input is wrong. The function should return a dictionary with words as keys and their count as values for each word in the text passage. This means I'll have seven tests that will, when passing, show me that under the right circumstances, my function is working, and if the wrong input is given to my function, it returns the right error code. Let's write some tests together again. I'll go wordcloud_tests.py import unittest import wordcloud as t class TestWordCloud(unittest.TestCase): def setUp(self): self.text = \"Peter peter of Pickeled Pepper pepper Pepper\" self.sensitive = { 'Peter': 1, 'peter': 1, 'of': 1, 'Pickeled': 1, 'Pepper': 2, 'pepper': 2 } self.insensitive = { 'peter': 2, 'of': 1, 'pickeled': 1, 'pepper': 4 } def test_returns_error_code_on_bad_text(self): self.assertEqual(t.word_count(1), -1) def test_returns_error_code_on_bad_case(self): self.assertEqual(t.word_count('Pass', 11), -1) def test_case_sensitive(self): self.assertEqual(t.word_count(self.text, True), self.sensitive) def test_case_insensitve(self): self.assertEqual(t.word_count(self.text), self.insensitive) There are two options when writing tests and writing production code. You can either write a test, then write code to pass the test, then write another test and get that one to pass, or you can write a set of tests for one particular function and then write code to get them all to pass. In this case, I wrote all of my tests first, and it gives me a sort of todo list. I know I have to write code to get all of these tests to pass, and I should only write that much code. First I'll write the code that gets the first two tests passing. wordcloud.py def word_count(text, case): return -1 The first two tests will pass, but the second two tests will fail once I've written this code. Notice that I don't have any logic in this function, but simply a return statement that will pass the test. I like this approach because it is very little code to write, and still it satisfies the test cases. Next I want to write the code to get the case sensitive version to work. wordcloud.py def word_count(text, case): if isinstance(text, str) and isinstance(case, bool): counts = {} for word in text.split(): if word in counts.keys(): counts[word] += 1 else: counts[word] = 1 return counts return -1 Once again, you can try this out, but all of the tests except for the last one should be passing now. We're making progress, but now I need to think about how I want to implement the case where we don't want to be case sensitive. An easy way to do this is simply set all the words to lower case and then use the same logic as above. def word_count(text, case): if isinstance(text, str) and isinstance(case, bool): counts = {} if not case: text = text.lower() for word in text.split(): if word in counts.keys(): counts[word] += 1 else: counts[word] = 1 return counts return -1 Now all of my tests are passing, but there's one more feature I want to add. Since word clouds often are used to show the importance of meaningful words, I want to not count words that contain digits or are just string representations of numbers. So if my text included \"dinn3r\" or \"2\", those strings should be ignored. I might be tempted to implement this directly, but I need to write tests first, and I'll just add them to the test code I already have (notice I changed the text to be checked): wordcloud_tests.py import unittest import wordcloud as t class TestWordCloud(unittest.TestCase): def setUp(self): self.text = \"Peter peter of Pickeled \\ Pepper pepper Pepper 123 p3pper\" self.sensitive = { 'Peter': 1, 'peter': 1, 'of': 1, 'Pickeled': 1, 'Pepper': 2, 'pepper': 2 } self.insensitive = { 'peter': 2, 'of': 1, 'pickeled': 1, 'pepper': 4 } def test_returns_error_code_on_bad_text(self): self.assertEqual(t.word_count(1), -1) def test_returns_error_code_on_bad_case(self): self.assertEqual(t.word_count('Pass', 11), -1) def test_case_sensitive(self): self.assertEqual(t.word_count(self.text, True), self.sensitive) def test_case_insensitve(self): self.assertEqual(t.word_count(self.text), self.insensitive) def test_ignores_digits(self): self.assertEqual(t.word_count(self.text), self.insensitive) Next, write code to get that test to pass. wordcloud.py def word_count(text, case): if isinstance(text, str) and isinstance(case, bool): counts = {} if not case: text = text.lower() for word in text.split(): # make sure no characters in the word are digits if not any(map(word.isdigit, word)): if word in counts.keys(): counts[word] += 1 else: counts[word] = 1 return counts return -1 All of my tests are passing now, so basically I know that my code is working as expected. I haven't done anything to ensure that the user uses the code correctly, but at this point that's okay. There's just one more small change I would like to make and add some documentation. I want to make case a kwarg instead of an arg. I want to do this so I can set a default setting. I want the function to not be case sensitive unless it is asked to be sensitive. Kwargs are cool because you can set a default value for an argument, and that makes it so that we don't need to pass True or False to the function in some of the cases. Only when we want to be case sensitive. I made a small refactor as below with documentation added. wordcloud.py def word_count(text, case=False): \"\"\" This function calculates word frequency in a text. This function should not count digit strings. Args: text (str): the text to be searched. Kwargs: case (bool): Should the search be case sensive Returns: dict. counts keyed by word, or return code:: -1 -- Error \"\"\" if isinstance(text, str) and isinstance(case, bool): counts = {} for word in text.split(): if not any(map(word.isdigit, word)): if not case: word = word.lower() if word in counts.keys(): counts[word] += 1 else: counts[word] = 1 return counts return -1","title":"Unit Testing"},{"location":"ch2/#functional-testing","text":"If unit tests test to see if the code is working correctly, functional tests test to see if a particular functionality of a program is working correctly. This means we are not so concerned with the inner workings of our functions, but instead we are concerned with the functions that an application provides a user. We will cover functional tests as we start building our Flask app, but imagine for now our word cloud application. The user enters a text file and the application creates an image object based on the text. For a functional test, I'd create a mockup of an expected image object based on a particular text, and then pass that text to the function and compare the output with the expected like so: functional_tests.py import unittest import wordcloud as t class TestWordCloudFunctional(unittest.TestCase): def setUp(self): self.text = \"My text ...\" self.cloud = '' with open('img.png', 'rb') as f: self.cloud = f.read() def test_can_create_word_cloud(self): self.assertEqual(t.make_cloud(self.text), self.cloud) I'm imagining that we'll have to create a function called make_cloud, which probably will call the word_cound and so on.","title":"Functional Testing"},{"location":"ch2/#end-to-end-e2e-testing","text":"These tests make use of the user interface that you've developed and are like functional tests, but instead of testing one function of your code, they would test a sequence of functions that a user might use. For instance, if I was making a calculator, my E2E test might begin by launching the calculator, perform a series of calculations and then close the calculator. Alternatively, if I was creating a sign-up function for a website, an E2E test would test that through the user interface a new user can be created, saved to whatever storage solution we have for that data, test the user can login, and then log back out again. We won't be developing any E2E tests in this class because we'll be focusing on a very small application that can be tested with functional and unit tests.","title":"End to End (E2E) Testing"},{"location":"ch3/","text":"Introduction to Objects One of the major paradigms in programming is object oriented programming (OOP). This approach to programming attempts to bundle data and functionality into generalized objects. It is worth noting that this approach is more popular in server-side programming and in applications that run on a local machine rather than client side websites. This is because websites cannot rely on every client to have the same data stored, and because the web is sometimes fundamentally described as stateless . We're discussing a little bit of OOP here because when you use flask later on, you will be instantiating a Flask object, and understanding what that means will help you better understand how flask works. An object is a set of data and methods taht are collected together. A good way to think of it, but perhaps not a good way to think of it, is to use a car as an example. A car has a bunch of properties (wheels, seats, an engine, air conditioning, etc.). It also has a bunch of methods, perhaps related to those properties, like driving, honking, braking, etc. The key is that the object defines these properties and methods as existing as a sort of blueprint or template. Then when we use the object in our code, we create an instance with specific values. Here's what our object might look like in Python: Car.py class Car: def __init__(self, color, max_speed, horn): # These are variables that store the color # maximum speed, and sound the horn makes. self.color = color self.current_speed = 0 self.max_speed = max_speed self.horn = horn def get_horn(self): return self.horn def get_color(self): return self.color def get_speed(self): return self.current_speed def accelerate(self) # Increases speed by 1 until max speed is reached while self.current_speed <= self.max_speed: self.current_speed += 1 The first line in the snippet above defines the class using the class keyword and then the class name. The name Car is arbitrary in the same way variable names are arbitrary. They cannot be reserved words in Python, but they can be any other words. It is conventional to capitalize the first letter of every word in class names. After the class name, we might have a set of parentheses in which we place the name of another object that this one inherits from. Don't worry too much about this, but be aware that it might exist and you'll see it in Flask. You'll notice next that everything below the first line is indented, which means it is part of the block that defines this particular class. The first part of the class definition you'll recognize as a function by the keyword def . __init__ is a special function, and it is called the constructor . The constructor is a special method or function that is automatically called when an object defined by this class is constructed . I'll explain this in a moment, but for now, remember that it's a special function that's automatically called. In Python, the constructor will always be called __init__ . You'll notice above that the Car object has four properties (or four variables that will hold data): color, current_speed, max_speed, and horn. Likewise, the Car object has four methods (or actions that can be performed): three get methods that return the value stored in each of the properties, and an accelerate method that increments the current_speed property until it reaches max_speed. You've probably encountered methods before. If you recall, there are a bunch of methods we can do to a string: my_string.upper() is one example. What's happening is this this: my_string is an instance of the String object, which has a method called upper() that converts all of the characters to upper case. Likewise, the Car class has a method called accelerate. When we call my_car.accelarate() , you guessed it, the property my_car.current_speed is incremented until it reaches my_car.max_speed . One other thing you might've noticed is this weird parameter self , which is included in each of the functions. Hold tight and I'll explain that below after we get to creating specific instances of the class. As I said above, the properties of the class are variables, which means in the class definition, they contain no value. Instead, they are empty boxes that could have values put in them. In the computer, what's happening is these names point to the address in memory (RAM) where that data could be stored. When we use this class to create a specific car (instead of the general Car prototype), we create a spot in memory that contains instructions to do the car methods, and addresses to store the specific properties of this car. Let me give you an example to make this clear. I'll show you what this looks like in the Python interpreter first. >>> from Car import Car >>> my_car = Car('blue', 1000, 'beep beep') >>> my_second_car = Car('red', 10, 'honk honk') >>> print(my_car.get_horn()) beep beep >>> print(my_second_car.get_horn()) honk honk >>> There are a few things to notice. First, I have imported the Car class from a file called Car.py. When I do this, the file is read into memory and Car becomes a known class in the same way as when you define a function. However, that class is a blueprint and contains no data initially. It's not specific cars, it's the generic model of a car. In the next line my_car = Car('blue', 1000, 'beep beep') a specific car is made. This is also called instantiation . An instance of the Car class is constructed. Here's the process. We begin with the right side of the assignment ( = ) operator and we see Car('blue', 1000, 'beep beep') . This tells the interpreter first to find a class definition called Car . Since we imported that before, the interpreter will know about that. Immediately a copy of the blueprint is established and the __init__ function is called (the constructor is called). You'll notice that the constructor takes 3 parameters (plus self), and you'll notice we passed three values (blue, 1000, and beep beep) when we called the class. The constructor takes these three values just as any function would take values for its parameters. The constructor executes. A variable called self.color is assigned the value 'blue' , self.current_speed is assigned the value 0, and so on. I'll explain self after this list of steps. After the constructor runs, the copy of the blueprint created in step two now has values stored in its variables. It also has methods. The constructed object that was built on steps 1-4 is stored to memory with the variable named my_car attached. Note: the Car class definition is not changed. It still is a blueprint. my_car is an instance of Car, or a set of values and methods defined by the Car class and set up by the constructor in step 3. The next line repeats these steps for a second instance of Car and stores that second instance to a variable my_second_car . Again, the Car class definition doesn't change, and we have two instances based off of the same class with different values stored their properties. The remaining lines of the example simply show the output of the get_horn() method for each instance. The function works the same way for both instances returning the value stored in the self.horn property, but you'll note that the values are unique to the instance. Self Before we go further, I need to talk a bit about self . This often is a tricky concept. First, we need a little review on scope. If you recall, scope defines where a variable is accessible from. For instance, in the following example: >>> num = 0 >>> def myfun(): ... num = 5 ... return num >>> print(num) 0 >>> print(myfun()) 5 >>> num = myfun() >>> print(num) 5 the first num is a global variable and is accessible in the global scope. The second num inside of myfun() is a local variable and is pointing to a different address in memory than the first num . The following lines prove that those two variables are different. Also, you'll recall that variables are only accessible in the scope in which they are defined. The same is true with classes. Class properties are variables that are accessible anywhere in the class. Each method might also have local variables that are accessible only within that method. When the class is instantiated, the class properties are populated with values. So where does self come in? self references this current instance of the class. So, in the car example above, the value stored in my_car 's self.color would be 'blue'. There are a few things: each method within a class must at least take self as a parameter. This is how the method gains access to the instance's properties and methods. Second, and this is really important, local variables disappear when they go out of scope. Class variables identified by self remain until the instance of the class is deleted. This means in the above example that when any instance of the car is instantiated, the value for self.current_speed is 0. When we call accelerate() for that instance the value for that instance of self.current_speed is incremented until it reaches the self.max_speed , and it stays at that value until it is changed again or the instance is deleted. It does not revert back to zero after accelerate() stops running. Visibility In some programming languages, the notion of scope is taken a bit more seriously, and we can use objects to protect or hide the values stored in various parameters. I'll give you an example that's a bit of a digression, but let's look at the car example in C++: car.cpp class Car { public: Car(string color, int max_speed, string horn) { this.color = color; this.current_speed = 0; this.max_speed = max_speed; this.horn = horn; } string get_horn() { return this.horn; } string get_color() { return this.color; } int get_speed(self) { return self.current_speed; } void accelerate() { while (this.current_speed <= this.max_speed) { this.current_speed++; } } private: string horn; string color; int current_speed; int max_speed; }; int main() { Car my_car = new Car(\"blue\", 40, 'beep beep'); cout << \"The color is: \" << my_car.get_color() << endl; // This next line will not work because color is private. cout << \"The color is: \" << my_car.color << endl; } In the class above, all of my object properties are called \"private\" properties, which means they cannot be accessed directly from outside of the class. Instead, I use getter methods to return the values. This is useful because you can control how the properties are changed or retrieved. Likewise, methods could be set as private or protected. I'm not going to go into that here, but if you're interested in all of the features of object oriented programming, it is worth reading up on. While languages like Java and C++ allow you to make properties and methods private, Python doesn't do that. All properties are accessible anywhere. In practice, if you want a method to be treated as private, you must start its name with an underscore. So to denote accelerate() as private, the definition line in Python would look like this: python def _accelerate(self): . This doesn't mean it cannot be accessed from outside the class, but it does tell developers that it shouldn't be accessed directly. Instead, maybe you have another method from within the class that can access it. We won't be dealing with any of this in this book, but it is useful to know that one of the major reason we use objects, besides to collect data and methods into single units. Conclusion Object oriented programming, or designing your system around a number of classes, is a popular paradigm. I would encourage you to research it further. In the next chapter, I'm going to walk through an example of building a class using Test Driven Development that builds on the prime_factors function from the first chapter. However, for our purposes, we'll be using classes, but we won't be going to far down the OOP path. You will have a better sense now of what's happening when we say app = Flask(__name__) .","title":"Intro to Objects"},{"location":"ch3/#introduction-to-objects","text":"One of the major paradigms in programming is object oriented programming (OOP). This approach to programming attempts to bundle data and functionality into generalized objects. It is worth noting that this approach is more popular in server-side programming and in applications that run on a local machine rather than client side websites. This is because websites cannot rely on every client to have the same data stored, and because the web is sometimes fundamentally described as stateless . We're discussing a little bit of OOP here because when you use flask later on, you will be instantiating a Flask object, and understanding what that means will help you better understand how flask works. An object is a set of data and methods taht are collected together. A good way to think of it, but perhaps not a good way to think of it, is to use a car as an example. A car has a bunch of properties (wheels, seats, an engine, air conditioning, etc.). It also has a bunch of methods, perhaps related to those properties, like driving, honking, braking, etc. The key is that the object defines these properties and methods as existing as a sort of blueprint or template. Then when we use the object in our code, we create an instance with specific values. Here's what our object might look like in Python: Car.py class Car: def __init__(self, color, max_speed, horn): # These are variables that store the color # maximum speed, and sound the horn makes. self.color = color self.current_speed = 0 self.max_speed = max_speed self.horn = horn def get_horn(self): return self.horn def get_color(self): return self.color def get_speed(self): return self.current_speed def accelerate(self) # Increases speed by 1 until max speed is reached while self.current_speed <= self.max_speed: self.current_speed += 1 The first line in the snippet above defines the class using the class keyword and then the class name. The name Car is arbitrary in the same way variable names are arbitrary. They cannot be reserved words in Python, but they can be any other words. It is conventional to capitalize the first letter of every word in class names. After the class name, we might have a set of parentheses in which we place the name of another object that this one inherits from. Don't worry too much about this, but be aware that it might exist and you'll see it in Flask. You'll notice next that everything below the first line is indented, which means it is part of the block that defines this particular class. The first part of the class definition you'll recognize as a function by the keyword def . __init__ is a special function, and it is called the constructor . The constructor is a special method or function that is automatically called when an object defined by this class is constructed . I'll explain this in a moment, but for now, remember that it's a special function that's automatically called. In Python, the constructor will always be called __init__ . You'll notice above that the Car object has four properties (or four variables that will hold data): color, current_speed, max_speed, and horn. Likewise, the Car object has four methods (or actions that can be performed): three get methods that return the value stored in each of the properties, and an accelerate method that increments the current_speed property until it reaches max_speed. You've probably encountered methods before. If you recall, there are a bunch of methods we can do to a string: my_string.upper() is one example. What's happening is this this: my_string is an instance of the String object, which has a method called upper() that converts all of the characters to upper case. Likewise, the Car class has a method called accelerate. When we call my_car.accelarate() , you guessed it, the property my_car.current_speed is incremented until it reaches my_car.max_speed . One other thing you might've noticed is this weird parameter self , which is included in each of the functions. Hold tight and I'll explain that below after we get to creating specific instances of the class. As I said above, the properties of the class are variables, which means in the class definition, they contain no value. Instead, they are empty boxes that could have values put in them. In the computer, what's happening is these names point to the address in memory (RAM) where that data could be stored. When we use this class to create a specific car (instead of the general Car prototype), we create a spot in memory that contains instructions to do the car methods, and addresses to store the specific properties of this car. Let me give you an example to make this clear. I'll show you what this looks like in the Python interpreter first. >>> from Car import Car >>> my_car = Car('blue', 1000, 'beep beep') >>> my_second_car = Car('red', 10, 'honk honk') >>> print(my_car.get_horn()) beep beep >>> print(my_second_car.get_horn()) honk honk >>> There are a few things to notice. First, I have imported the Car class from a file called Car.py. When I do this, the file is read into memory and Car becomes a known class in the same way as when you define a function. However, that class is a blueprint and contains no data initially. It's not specific cars, it's the generic model of a car. In the next line my_car = Car('blue', 1000, 'beep beep') a specific car is made. This is also called instantiation . An instance of the Car class is constructed. Here's the process. We begin with the right side of the assignment ( = ) operator and we see Car('blue', 1000, 'beep beep') . This tells the interpreter first to find a class definition called Car . Since we imported that before, the interpreter will know about that. Immediately a copy of the blueprint is established and the __init__ function is called (the constructor is called). You'll notice that the constructor takes 3 parameters (plus self), and you'll notice we passed three values (blue, 1000, and beep beep) when we called the class. The constructor takes these three values just as any function would take values for its parameters. The constructor executes. A variable called self.color is assigned the value 'blue' , self.current_speed is assigned the value 0, and so on. I'll explain self after this list of steps. After the constructor runs, the copy of the blueprint created in step two now has values stored in its variables. It also has methods. The constructed object that was built on steps 1-4 is stored to memory with the variable named my_car attached. Note: the Car class definition is not changed. It still is a blueprint. my_car is an instance of Car, or a set of values and methods defined by the Car class and set up by the constructor in step 3. The next line repeats these steps for a second instance of Car and stores that second instance to a variable my_second_car . Again, the Car class definition doesn't change, and we have two instances based off of the same class with different values stored their properties. The remaining lines of the example simply show the output of the get_horn() method for each instance. The function works the same way for both instances returning the value stored in the self.horn property, but you'll note that the values are unique to the instance.","title":"Introduction to Objects"},{"location":"ch3/#self","text":"Before we go further, I need to talk a bit about self . This often is a tricky concept. First, we need a little review on scope. If you recall, scope defines where a variable is accessible from. For instance, in the following example: >>> num = 0 >>> def myfun(): ... num = 5 ... return num >>> print(num) 0 >>> print(myfun()) 5 >>> num = myfun() >>> print(num) 5 the first num is a global variable and is accessible in the global scope. The second num inside of myfun() is a local variable and is pointing to a different address in memory than the first num . The following lines prove that those two variables are different. Also, you'll recall that variables are only accessible in the scope in which they are defined. The same is true with classes. Class properties are variables that are accessible anywhere in the class. Each method might also have local variables that are accessible only within that method. When the class is instantiated, the class properties are populated with values. So where does self come in? self references this current instance of the class. So, in the car example above, the value stored in my_car 's self.color would be 'blue'. There are a few things: each method within a class must at least take self as a parameter. This is how the method gains access to the instance's properties and methods. Second, and this is really important, local variables disappear when they go out of scope. Class variables identified by self remain until the instance of the class is deleted. This means in the above example that when any instance of the car is instantiated, the value for self.current_speed is 0. When we call accelerate() for that instance the value for that instance of self.current_speed is incremented until it reaches the self.max_speed , and it stays at that value until it is changed again or the instance is deleted. It does not revert back to zero after accelerate() stops running.","title":"Self"},{"location":"ch3/#visibility","text":"In some programming languages, the notion of scope is taken a bit more seriously, and we can use objects to protect or hide the values stored in various parameters. I'll give you an example that's a bit of a digression, but let's look at the car example in C++: car.cpp class Car { public: Car(string color, int max_speed, string horn) { this.color = color; this.current_speed = 0; this.max_speed = max_speed; this.horn = horn; } string get_horn() { return this.horn; } string get_color() { return this.color; } int get_speed(self) { return self.current_speed; } void accelerate() { while (this.current_speed <= this.max_speed) { this.current_speed++; } } private: string horn; string color; int current_speed; int max_speed; }; int main() { Car my_car = new Car(\"blue\", 40, 'beep beep'); cout << \"The color is: \" << my_car.get_color() << endl; // This next line will not work because color is private. cout << \"The color is: \" << my_car.color << endl; } In the class above, all of my object properties are called \"private\" properties, which means they cannot be accessed directly from outside of the class. Instead, I use getter methods to return the values. This is useful because you can control how the properties are changed or retrieved. Likewise, methods could be set as private or protected. I'm not going to go into that here, but if you're interested in all of the features of object oriented programming, it is worth reading up on. While languages like Java and C++ allow you to make properties and methods private, Python doesn't do that. All properties are accessible anywhere. In practice, if you want a method to be treated as private, you must start its name with an underscore. So to denote accelerate() as private, the definition line in Python would look like this: python def _accelerate(self): . This doesn't mean it cannot be accessed from outside the class, but it does tell developers that it shouldn't be accessed directly. Instead, maybe you have another method from within the class that can access it. We won't be dealing with any of this in this book, but it is useful to know that one of the major reason we use objects, besides to collect data and methods into single units.","title":"Visibility"},{"location":"ch3/#conclusion","text":"Object oriented programming, or designing your system around a number of classes, is a popular paradigm. I would encourage you to research it further. In the next chapter, I'm going to walk through an example of building a class using Test Driven Development that builds on the prime_factors function from the first chapter. However, for our purposes, we'll be using classes, but we won't be going to far down the OOP path. You will have a better sense now of what's happening when we say app = Flask(__name__) .","title":"Conclusion"},{"location":"ch4/","text":"TDD with Objects In this chapter, I'm going to walk through creating a class using TDD. We'll be building off of material in Chapter 1 and 2, so make sure you've read that carefully. At the end of Chapter 1, we had a set of tests that looked like this: prime_factors_tests.py import unittest import prime_factors as target class TestPrimeFactors(unittest.TestCase): def test_bad_input(self): self.assertIsNone(target.prime_factors(\"apple\")) def test_returns_list(self): l = target.prime_factors(315) self.assertIsInstance(l, list) def test_returns_correct_list(self): l = target.prime_factors(315) self.assertEqual([3, 5, 7], l) and we had created a function that we developed to pass those tests. prime_factors.py import math def prime_factors(n): if isinstance(n, int): out = [] if n % 2 == 0: out.append(2) while n % 2 == 0: n = n / 2 for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: out.append(i) while n % i == 0: n = n / i if n > 2: out.append(n) return out return None I'm going to build a class that uses prime_factors as a method. I'm also going to create a second method that finds the factorial value of a given number (factorial is 1 * 2 * 3 ... * n-1 * n). Next, calculating prime_factors and factorials for very large values is processor intensive, so let's make our calculator have a couple dictionaries that contain the key/value pairs of calculated numbers. So we start with our tests. I want to change my file name first to better reflect what we're doing. Then the first thing we need to do is change how we import our calculator. We also need to set up a test for our constructor (the __init__ method). Let's start with those two steps. While we're at it, we're going to modify our existing tests to call object methods instead of freestanding functions. import unittest # Import the class definition from Calculator import Calculator class TestCalculator(unittest.TestCase): def setUp(self): self.calc = Calculator() def test_calculator_constructor(self): expected = ({}, {}) actual = (self.calc.prime_factor, \\ self.calc.factorial) def test_bad_input(self): self.assertIsNone(self.calc.prime_factors(\"apple\")) def test_returns_list(self): l = self.calc.prime_factors(315) self.assertIsInstance(l, list) def test_returns_correct_list(self): l = self.calc.prime_factors(315) self.assertEqual([3, 5, 7], l) When we run our tests, since we haven't touched our code, we should run into error messages. I'm expecting an import error and a bunch of name errors. Let's see if we get that: (env) $ python -m unittest calculator_tests.py E ====================================================================== ERROR: calculator_tests (unittest.loader._FailedTest) ---------------------------------------------------------------------- ImportError: Failed to import test module: calculator_tests Traceback (most recent call last): File \"/usr/lib/python3.6/unittest/loader.py\", line 153, in loadTestsFromName module = __import__(module_name) File \"exercises/calculator_tests.py\", line 3, in <module> from Calculator import Calculator ModuleNotFoundError: No module named 'Calculator' ---------------------------------------------------------------------- Ran 1 test in 0.000s FAILED (errors=1) That's exactly the error I was expecting, so to fix this we can go about renaming our file for our code. I changed the name prime_factors.py to Calculator.py. Now my expectation is that there will be a name error because there's no such thing as a Calculator class. Run the tests again and here's the result: $ python -m unittest calculator_tests.py E ====================================================================== ERROR: calculator_tests (unittest.loader._FailedTest) ---------------------------------------------------------------------- ImportError: Failed to import test module: calculator_tests Traceback (most recent call last): File \"/usr/lib/python3.6/unittest/loader.py\", line 153, in loadTestsFromName module = __import__(module_name) File \"exercises/calculator_tests.py\", line 3, in <module> from Calculator import Calculator ImportError: cannot import name 'Calculator' ---------------------------------------------------------------------- Ran 1 test in 0.000s FAILED (errors=1) Once again, expected error achieved. Let's fix that by modifying my code a bit so that the prime_factors function becomes a method of Calculator. Calculator.py import math class Calculator: def __init__(self): self.prime_factor = {} self.factorial = {} def prime_factors(self, n): if isinstance(n, int): out = [] if n % 2 == 0: out.append(2) while n % 2 == 0: n = n / 2 for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: out.append(i) while n % i == 0: n = n / i if n > 2: out.append(n) return out return None I'm expecting a number of errors and failed tests now, but I believe that two of the tests will pass. test_bad_input and test_returns_list should still pass, but I'll get errors for the class properties and the list comparison should fail. (env) $ python -m unittest calculator_tests.py .EF. ====================================================================== ERROR: test_calculator_constructor (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 13, in test_calculator_constructor self.calc.factorial) AttributeError: type object 'Calculator' has no attribute 'factorial' ====================================================================== FAIL: test_returns_correct_list (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 24, in test_returns_correct_list self.assertEqual([3, 5, 7], l) AssertionError: Lists differ: [3, 5, 7] != [] First list contains 3 additional elements. First extra element 0: 3 - [3, 5, 7] + [] ---------------------------------------------------------------------- Ran 4 tests in 0.001s FAILED (failures=1, errors=1) Again, this is good. Let's now add a constructor and adjust our function and see if we can get these tests to pass. import math class Calculator: def __init__(self): self.prime_factor = {} self.factorial = {} def prime_factors(self, n): if isinstance(n, int): out = [] if n % 2 == 0: out.append(2) while n % 2 == 0: n = n / 2 for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: out.append(i) while n % i == 0: n = n / i if n > 2: out.append(n) return out return None You'll notice that I added a constructor to my class and added self as a parameter for prime_factors() . The constructor initializes the two class properties to empty dictionaries. At this point, all of my tests should pass. (env) $ python -m unittest calculator_tests.py .... ---------------------------------------------------------------------- Ran 4 tests in 0.000s OK Great! Now we might be tempted to add the extra functionality directly to our class and move forward, but we must obey the testing goat. We have to start by writing our tests. First, we need to do similar tests for our new method called factorials. It should test that the method returns None if it is passed a value that is not an integer. It should also test that the correct value is returned for a given integer. Second, we need a tests that make sure each of the dictionaries are being constructed in the right way as the classes methods are called. Let's see if we can get those tests written. import unittest # Import the class definition from Calculator import Calculator class TestCalculator(unittest.TestCase): def setUp(self): self.calc = Calculator() def test_calculator_constructor(self): expected = ({}, {}) actual = (self.calc.prime_factor, \\ self.calc.factorial) def test_bad_input(self): self.assertIsNone(self.calc.prime_factors(\"apple\")) def test_returns_list(self): l = self.calc.prime_factors(315) self.assertIsInstance(l, list) def test_returns_correct_list(self): l = self.calc.prime_factors(315) self.assertEqual([3, 5, 7], l) def test_factorials_bad_input(self): self.assertIsNone(self.calc.factorials(\"apple\")) def test_factorials_good_input(self): l = self.calc.factorials(5) self.assertEqual(120, l) def test_memory_prime_factors(self): calc = Calculator() calc.prime_factors(315) calc.prime_factors(9) expected = {315: [3, 5, 7], 9: [3]} self.assertDictEqual(calc.prime_factor, expected) def test_memory_factorial(self): calc = Calculator() calc.factorials(4) calc.factorials(5) expected = {4: 24, 5: 120} self.assertDictEqual(calc.factorial, expected) We added four new tests. A couple things to notice: first, the memory tests create new instances of the Calculator class. I did this because I wanted to isolate that instance and see if the memory for that one instance was working without any of the other tests altering the state of the instance. calc != self.calc in these cases. Second, I'm using assertDictEqual which is a new feature of unittest as of python 3.1, and it allows us to compare equality of dictionaries. Of course, all these should have errors (not fail) because factorials doesn't exist yet. (env) $ python -m unittest calculator_tests.py ..EEEF.. ====================================================================== ERROR: test_factorials_bad_input (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 27, in test_factorials_bad_input self.assertIsNone(self.calc.factorials(\"apple\")) AttributeError: 'Calculator' object has no attribute 'factorials' ====================================================================== ERROR: test_factorials_good_input (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 30, in test_factorials_good_input l = self.calc.factorials(5) AttributeError: 'Calculator' object has no attribute 'factorials' ====================================================================== ERROR: test_memory_factorial (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 42, in test_memory_factorial calc.factorials(4) AttributeError: 'Calculator' object has no attribute 'factorials' ====================================================================== FAIL: test_memory_prime_factors (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 38, in test_memory_prime_factors self.assertDictEqual(calc.prime_factor, expected) AssertionError: {} != {315: [3, 5, 7], 9: [3]} - {} + {9: [3], 315: [3, 5, 7]} ---------------------------------------------------------------------- Ran 8 tests in 0.001s FAILED (failures=1, errors=3) Good, so let's add a function called factorials and see that we get at least three failures. Which means we need to modify our code: Calculator.py import math class Calculator: def __init__(self): self.prime_factor = {} self.factorial = {} def prime_factors(self, n): if isinstance(n, int): out = [] if n % 2 == 0: out.append(2) while n % 2 == 0: n = n / 2 for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: out.append(i) while n % i == 0: n = n / i if n > 2: out.append(n) return out return None def factorials(self, n): pass Run our tests: (env) $ python -m unittest calculator_tests.py ...FFF.. ====================================================================== FAIL: test_factorials_good_input (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 31, in test_factorials_good_input self.assertEqual(120, l) AssertionError: 120 != None ====================================================================== FAIL: test_memory_factorial (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 45, in test_memory_factorial self.assertDictEqual(calc.factorial, expected) AssertionError: {} != {4: 24, 5: 120} - {} + {4: 24, 5: 120} ====================================================================== FAIL: test_memory_prime_factors (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 38, in test_memory_prime_factors self.assertDictEqual(calc.prime_factor, expected) AssertionError: {} != {315: [3, 5, 7], 9: [3]} - {} + {9: [3], 315: [3, 5, 7]} ---------------------------------------------------------------------- Ran 8 tests in 0.001s FAILED (failures=3) Outstanding! So to get the tests to pass, I need to do a few things. I need to first build the factorials method. Then I need to modify the two methods in the class to add values to the class properties that are keeping track. We might also add a way to make these methods return the stored value rather than run the calculation so as to save processor power. Think of it like a cache. I'll do all of this at once for now, but you would probably want to take each of these as a single step if you were doing very strict TDD. Here's what I came up with: import math class Calculator: def __init__(self): self.prime_factor = {} self.factorial = {} def prime_factors(self, n): if isinstance(n, int): out = [] if n in self.prime_factor.keys(): return self.prime_factor[n] original = n if n % 2 == 0: out.append(2) while n % 2 == 0: n = n / 2 for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: out.append(i) while n % i == 0: n = n / i if n > 2: out.append(n) self.prime_factor[original] = out return out return None def factorials(self, n): if not isinstance(n, int): return None out = 1 original = n while n > 1: if n in self.factorial.keys(): out *= self.factorial[n] # clever n = 1 else: out *= n n -= 1 self.factorial[original] = out return out You'll notice that I adjusted both methods to check to see if we'd already calculated the factorials or the prime_factors of n, and if so, we return the cached value. Otherwise, we run the calculation. Also, I set up the functionality to store the value in the cache. There's a clever bit on the line with the comment #clever. This will short circuit our while loop if we've already calculated a value for n that is less than the original parameter. This helps because if we are calculating 5 factorial, we have to do 5 * 4 * 3 * 2 * 1, but if we've already calculated 3! and have it stored, then once what happens is we calculate 5 * 4 and when we hit n == 3, then the method looks up our stored result for 3!, which is 6, so the calculation becomes 5 * 4 * 6 and the result is returned without recalcuating 3 * 2 * 1. This matters if our number is 1000 and we've already calculated 960!. It would save us 960 iterations in our loop. Here's the results of our unit tests: (env) $ python -m unittest calculator_tests.py ........ ---------------------------------------------------------------------- Ran 8 tests in 0.000s OK I'd say that's not too bad for a days work. Of course, I could have gone through all of the steps and written one test at a time, but hopefully you're getting the hang of it. In a larger application I might be a bit more careful. Conclusion So by now you should have a sense of what a class is and how we might build a class using a TDD approach. If you want extra practice, you might do this kind of refactoring with the function from Chapter 2. If you're excited about objects, Python 4 Everybody has a great series of lessons on Objects in Python.","title":"TDD with Objects"},{"location":"ch4/#tdd-with-objects","text":"In this chapter, I'm going to walk through creating a class using TDD. We'll be building off of material in Chapter 1 and 2, so make sure you've read that carefully. At the end of Chapter 1, we had a set of tests that looked like this: prime_factors_tests.py import unittest import prime_factors as target class TestPrimeFactors(unittest.TestCase): def test_bad_input(self): self.assertIsNone(target.prime_factors(\"apple\")) def test_returns_list(self): l = target.prime_factors(315) self.assertIsInstance(l, list) def test_returns_correct_list(self): l = target.prime_factors(315) self.assertEqual([3, 5, 7], l) and we had created a function that we developed to pass those tests. prime_factors.py import math def prime_factors(n): if isinstance(n, int): out = [] if n % 2 == 0: out.append(2) while n % 2 == 0: n = n / 2 for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: out.append(i) while n % i == 0: n = n / i if n > 2: out.append(n) return out return None I'm going to build a class that uses prime_factors as a method. I'm also going to create a second method that finds the factorial value of a given number (factorial is 1 * 2 * 3 ... * n-1 * n). Next, calculating prime_factors and factorials for very large values is processor intensive, so let's make our calculator have a couple dictionaries that contain the key/value pairs of calculated numbers. So we start with our tests. I want to change my file name first to better reflect what we're doing. Then the first thing we need to do is change how we import our calculator. We also need to set up a test for our constructor (the __init__ method). Let's start with those two steps. While we're at it, we're going to modify our existing tests to call object methods instead of freestanding functions. import unittest # Import the class definition from Calculator import Calculator class TestCalculator(unittest.TestCase): def setUp(self): self.calc = Calculator() def test_calculator_constructor(self): expected = ({}, {}) actual = (self.calc.prime_factor, \\ self.calc.factorial) def test_bad_input(self): self.assertIsNone(self.calc.prime_factors(\"apple\")) def test_returns_list(self): l = self.calc.prime_factors(315) self.assertIsInstance(l, list) def test_returns_correct_list(self): l = self.calc.prime_factors(315) self.assertEqual([3, 5, 7], l) When we run our tests, since we haven't touched our code, we should run into error messages. I'm expecting an import error and a bunch of name errors. Let's see if we get that: (env) $ python -m unittest calculator_tests.py E ====================================================================== ERROR: calculator_tests (unittest.loader._FailedTest) ---------------------------------------------------------------------- ImportError: Failed to import test module: calculator_tests Traceback (most recent call last): File \"/usr/lib/python3.6/unittest/loader.py\", line 153, in loadTestsFromName module = __import__(module_name) File \"exercises/calculator_tests.py\", line 3, in <module> from Calculator import Calculator ModuleNotFoundError: No module named 'Calculator' ---------------------------------------------------------------------- Ran 1 test in 0.000s FAILED (errors=1) That's exactly the error I was expecting, so to fix this we can go about renaming our file for our code. I changed the name prime_factors.py to Calculator.py. Now my expectation is that there will be a name error because there's no such thing as a Calculator class. Run the tests again and here's the result: $ python -m unittest calculator_tests.py E ====================================================================== ERROR: calculator_tests (unittest.loader._FailedTest) ---------------------------------------------------------------------- ImportError: Failed to import test module: calculator_tests Traceback (most recent call last): File \"/usr/lib/python3.6/unittest/loader.py\", line 153, in loadTestsFromName module = __import__(module_name) File \"exercises/calculator_tests.py\", line 3, in <module> from Calculator import Calculator ImportError: cannot import name 'Calculator' ---------------------------------------------------------------------- Ran 1 test in 0.000s FAILED (errors=1) Once again, expected error achieved. Let's fix that by modifying my code a bit so that the prime_factors function becomes a method of Calculator. Calculator.py import math class Calculator: def __init__(self): self.prime_factor = {} self.factorial = {} def prime_factors(self, n): if isinstance(n, int): out = [] if n % 2 == 0: out.append(2) while n % 2 == 0: n = n / 2 for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: out.append(i) while n % i == 0: n = n / i if n > 2: out.append(n) return out return None I'm expecting a number of errors and failed tests now, but I believe that two of the tests will pass. test_bad_input and test_returns_list should still pass, but I'll get errors for the class properties and the list comparison should fail. (env) $ python -m unittest calculator_tests.py .EF. ====================================================================== ERROR: test_calculator_constructor (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 13, in test_calculator_constructor self.calc.factorial) AttributeError: type object 'Calculator' has no attribute 'factorial' ====================================================================== FAIL: test_returns_correct_list (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 24, in test_returns_correct_list self.assertEqual([3, 5, 7], l) AssertionError: Lists differ: [3, 5, 7] != [] First list contains 3 additional elements. First extra element 0: 3 - [3, 5, 7] + [] ---------------------------------------------------------------------- Ran 4 tests in 0.001s FAILED (failures=1, errors=1) Again, this is good. Let's now add a constructor and adjust our function and see if we can get these tests to pass. import math class Calculator: def __init__(self): self.prime_factor = {} self.factorial = {} def prime_factors(self, n): if isinstance(n, int): out = [] if n % 2 == 0: out.append(2) while n % 2 == 0: n = n / 2 for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: out.append(i) while n % i == 0: n = n / i if n > 2: out.append(n) return out return None You'll notice that I added a constructor to my class and added self as a parameter for prime_factors() . The constructor initializes the two class properties to empty dictionaries. At this point, all of my tests should pass. (env) $ python -m unittest calculator_tests.py .... ---------------------------------------------------------------------- Ran 4 tests in 0.000s OK Great! Now we might be tempted to add the extra functionality directly to our class and move forward, but we must obey the testing goat. We have to start by writing our tests. First, we need to do similar tests for our new method called factorials. It should test that the method returns None if it is passed a value that is not an integer. It should also test that the correct value is returned for a given integer. Second, we need a tests that make sure each of the dictionaries are being constructed in the right way as the classes methods are called. Let's see if we can get those tests written. import unittest # Import the class definition from Calculator import Calculator class TestCalculator(unittest.TestCase): def setUp(self): self.calc = Calculator() def test_calculator_constructor(self): expected = ({}, {}) actual = (self.calc.prime_factor, \\ self.calc.factorial) def test_bad_input(self): self.assertIsNone(self.calc.prime_factors(\"apple\")) def test_returns_list(self): l = self.calc.prime_factors(315) self.assertIsInstance(l, list) def test_returns_correct_list(self): l = self.calc.prime_factors(315) self.assertEqual([3, 5, 7], l) def test_factorials_bad_input(self): self.assertIsNone(self.calc.factorials(\"apple\")) def test_factorials_good_input(self): l = self.calc.factorials(5) self.assertEqual(120, l) def test_memory_prime_factors(self): calc = Calculator() calc.prime_factors(315) calc.prime_factors(9) expected = {315: [3, 5, 7], 9: [3]} self.assertDictEqual(calc.prime_factor, expected) def test_memory_factorial(self): calc = Calculator() calc.factorials(4) calc.factorials(5) expected = {4: 24, 5: 120} self.assertDictEqual(calc.factorial, expected) We added four new tests. A couple things to notice: first, the memory tests create new instances of the Calculator class. I did this because I wanted to isolate that instance and see if the memory for that one instance was working without any of the other tests altering the state of the instance. calc != self.calc in these cases. Second, I'm using assertDictEqual which is a new feature of unittest as of python 3.1, and it allows us to compare equality of dictionaries. Of course, all these should have errors (not fail) because factorials doesn't exist yet. (env) $ python -m unittest calculator_tests.py ..EEEF.. ====================================================================== ERROR: test_factorials_bad_input (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 27, in test_factorials_bad_input self.assertIsNone(self.calc.factorials(\"apple\")) AttributeError: 'Calculator' object has no attribute 'factorials' ====================================================================== ERROR: test_factorials_good_input (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 30, in test_factorials_good_input l = self.calc.factorials(5) AttributeError: 'Calculator' object has no attribute 'factorials' ====================================================================== ERROR: test_memory_factorial (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 42, in test_memory_factorial calc.factorials(4) AttributeError: 'Calculator' object has no attribute 'factorials' ====================================================================== FAIL: test_memory_prime_factors (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 38, in test_memory_prime_factors self.assertDictEqual(calc.prime_factor, expected) AssertionError: {} != {315: [3, 5, 7], 9: [3]} - {} + {9: [3], 315: [3, 5, 7]} ---------------------------------------------------------------------- Ran 8 tests in 0.001s FAILED (failures=1, errors=3) Good, so let's add a function called factorials and see that we get at least three failures. Which means we need to modify our code: Calculator.py import math class Calculator: def __init__(self): self.prime_factor = {} self.factorial = {} def prime_factors(self, n): if isinstance(n, int): out = [] if n % 2 == 0: out.append(2) while n % 2 == 0: n = n / 2 for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: out.append(i) while n % i == 0: n = n / i if n > 2: out.append(n) return out return None def factorials(self, n): pass Run our tests: (env) $ python -m unittest calculator_tests.py ...FFF.. ====================================================================== FAIL: test_factorials_good_input (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 31, in test_factorials_good_input self.assertEqual(120, l) AssertionError: 120 != None ====================================================================== FAIL: test_memory_factorial (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 45, in test_memory_factorial self.assertDictEqual(calc.factorial, expected) AssertionError: {} != {4: 24, 5: 120} - {} + {4: 24, 5: 120} ====================================================================== FAIL: test_memory_prime_factors (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 38, in test_memory_prime_factors self.assertDictEqual(calc.prime_factor, expected) AssertionError: {} != {315: [3, 5, 7], 9: [3]} - {} + {9: [3], 315: [3, 5, 7]} ---------------------------------------------------------------------- Ran 8 tests in 0.001s FAILED (failures=3) Outstanding! So to get the tests to pass, I need to do a few things. I need to first build the factorials method. Then I need to modify the two methods in the class to add values to the class properties that are keeping track. We might also add a way to make these methods return the stored value rather than run the calculation so as to save processor power. Think of it like a cache. I'll do all of this at once for now, but you would probably want to take each of these as a single step if you were doing very strict TDD. Here's what I came up with: import math class Calculator: def __init__(self): self.prime_factor = {} self.factorial = {} def prime_factors(self, n): if isinstance(n, int): out = [] if n in self.prime_factor.keys(): return self.prime_factor[n] original = n if n % 2 == 0: out.append(2) while n % 2 == 0: n = n / 2 for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: out.append(i) while n % i == 0: n = n / i if n > 2: out.append(n) self.prime_factor[original] = out return out return None def factorials(self, n): if not isinstance(n, int): return None out = 1 original = n while n > 1: if n in self.factorial.keys(): out *= self.factorial[n] # clever n = 1 else: out *= n n -= 1 self.factorial[original] = out return out You'll notice that I adjusted both methods to check to see if we'd already calculated the factorials or the prime_factors of n, and if so, we return the cached value. Otherwise, we run the calculation. Also, I set up the functionality to store the value in the cache. There's a clever bit on the line with the comment #clever. This will short circuit our while loop if we've already calculated a value for n that is less than the original parameter. This helps because if we are calculating 5 factorial, we have to do 5 * 4 * 3 * 2 * 1, but if we've already calculated 3! and have it stored, then once what happens is we calculate 5 * 4 and when we hit n == 3, then the method looks up our stored result for 3!, which is 6, so the calculation becomes 5 * 4 * 6 and the result is returned without recalcuating 3 * 2 * 1. This matters if our number is 1000 and we've already calculated 960!. It would save us 960 iterations in our loop. Here's the results of our unit tests: (env) $ python -m unittest calculator_tests.py ........ ---------------------------------------------------------------------- Ran 8 tests in 0.000s OK I'd say that's not too bad for a days work. Of course, I could have gone through all of the steps and written one test at a time, but hopefully you're getting the hang of it. In a larger application I might be a bit more careful.","title":"TDD with Objects"},{"location":"ch4/#conclusion","text":"So by now you should have a sense of what a class is and how we might build a class using a TDD approach. If you want extra practice, you might do this kind of refactoring with the function from Chapter 2. If you're excited about objects, Python 4 Everybody has a great series of lessons on Objects in Python.","title":"Conclusion"},{"location":"ch5/","text":"The Internet This chapter is going to give you a general introduction to the internet, internet traffic, and how applications send and receive data. There won't be much code in this chapter, but I believe you should spend some time getting to know, at very least, the basics of how internet traffic works. When traffic flows over the internet, it is broken into packets. Those packets get routed by routers along the way and the recipient's computer reassembles those packages into a complete message. There are two different protocols for this, one that assembles and loads the message as it is received (UDP) and one that waits for the entire message to be received before loading anything (TCP). Streaming video services generally use UDP because the designers know that we're more frustrated by buffering than reduction in video quality. However, this all occurs below the application level and our FLASK application doesn't deal with unassembled packets. UDP and TCP manage the packets before they're sent to the application. Our applications are concerned with the entire message. When we request a page on a website, the message is that entire page. Likewise, when we send data to a website, the message is that entire data object (even if it is a massive photo that must be broken into lots of packets). When we look at an entire message that is sent over the internet, we are talking about the HTTP protocol. This protocol defines how entire messages are sent from one application (a web server, like Flask) to another (a browser, like Firefox). Within this protocols, there are two actions: Requests and Responses. Requests are made by clients, like web browsers, and either request some content from the server or request that some data be accepted by the server. On the other end, servers make responses. They do this when they receive a request from a client and their response depends upon the request. Requests An HTTP request is send by a client. This could be your web browser or any other application set up to make requests over the internet using the HTTP protocol. For fun, try out the following in your terminal: $ curl --request GET https://dlondonmedina.github.io/tester/ Curl is a program that sends HTTP requests similar to a web browers. What the above says is send a GET request to the address https://dlondonmedina.github.io/tester/ That request leaves curl and goes through my network card, gets sent across a bunch of routers to a DNS server which matches the name dlondonmedina.github.io with this IP address 185.199.109.153. The specific message is something like \"Get me whatever resource is named 'tester.'\" Now curl waits to see if there's a server that can respond to the particular message at the address 185.199.109.153. We'll see that response in just a moment. Before we get there, you'll notice the word --request GET in the command above. GET is a key word, and refers to a particular method in HTTP. Just as a method is a particular operation of an object and performs particular processes, HTTP methods are the particular operations that a request asks the server to do. GET above means get me whatever data is appropriate for the name 'tester.' The following are the most commonly used HTTP methods, but we'll mainly be concerned with GET and POST. Method Effect GET This method retrieves data from the resource at the specified URL or IP Address. GET should not be used to send data. POST This method submits data to the resource at the specified URL or IP Address. It causes a change in state on the server. For instance, when you create an account on a website, the data you enter in their form is sent via a POST request and stored on, or at least processed by, the server. PUT Like POST, this method submits data to the resource at the specified URL or IP address, but the data is an alteration to a preexisting resource on the server. The new data updates the old data. Think of this as resetting a username that is stored in a database on the server. DELETE This method submits data to identify a particular resource on a server at the specified URL or IP Address, and it deletes that data. There are others, but with Flask, you generally only use GET and POST. A crucial thing to know about using the HTTP methods is that some change the state of an object on the server and others do not. GET, for example, only retrieves data from a server, but doesn't change the state of that data. When you open a blog post on a web page, your browser uses GET to request the contents of the blog post. It doesn't change the coontents on the server or have any other side-effects (like placing an order or creating a user). On the other hand, when you submit a comment to that blog post, the broswer uses the POST method, which adds content to a database on the server, thus changing the state of that database resource. If this is all exciting, I encourage you to read more about all the HTTP methods, and perhaps pursue web development further. Responses Let's go back to our sample request above. We sent a GET request to the resource located at the URL dlondonmedina.github.io/ requesting the resource 'tester/'. Along with that request, we sent our IP address so that the server knows where to return the response. There are a few things that happen: Once our request goes to the DNS, which pairs the URL: dlondonmedina.github.io with the IP address: 185.199.109.153. Our request is sent to the IP address (185.199.109.153) If there is not a server listening for requests at 185.199.109.153, then an error message will be returned. If there is a server listening for requests at 185.199.109.153, then the server will receive the request and look for 'tester/' as a named resource. If the server doesn't know 'tester/' as a named resource (static file or method), then it will respond with an error. If the server does know 'tester/', then it will gather whatever resource is identified by that name (sometimes an HTML file). Once the resource is gathered, the server sends that data back to the IP address sent by the client along with the address. Here is the full request/response that I showed you above: $ curl -v --request GET https://dlondonmedina.github.io/tester/ <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>Tester</title> </head> <body> <h1>Welcome</h1> <p>You've successfully tested the site.</p> </body> </html> The first line is the request sent by the curl client. The rest of the lines are the HTML content that the server sent back in response. Of course, it's not showing you the entire HTTP wrapper that goes along with the request. The Responses will be sent along with a code that signifies what happend. Status code 200 means that the request was successful. Most other codes identify one sort of error or another. You don't need to know much about the error codes for Flask, but they might be useful to learn for debugging or if you're excited about web technologies. The status codes are part of the HTTP protocol just as the methods listed above are. So, here again is the entire request/response cycle with the HTTP wrapper displayed (I've cut out the TLS handshake that allows encryption to happen with https). The lines beginning with > are the request from my curl client. The lines beginning with < are the response from the server, and everything after <!DOCTYPE html> until </html> is the body of the response: $ curl -v https://dlondonmedina.github.io/tester/ > GET /tester/ HTTP/2 > Host: dlondonmedina.github.io > User-Agent: curl/7.58.0 > Accept: */* > < HTTP/2 200 < server: GitHub.com < content-type: text/html; charset=utf-8 < last-modified: Sat, 18 Apr 2020 01:54:09 GMT < etag: \"5e9a5dc1-101\" < access-control-allow-origin: * < expires: Sat, 18 Apr 2020 02:06:20 GMT < cache-control: max-age=600 < x-proxy-cache: MISS < x-github-request-id: < accept-ranges: bytes < date: Sun, 19 Apr 2020 00:52:52 GMT < via: 1.1 varnish < age: 14 < x-served-by: cache-yvr1522-YVR < x-cache: HIT < x-cache-hits: 1 < x-timer: S1587257573.591449,VS0,VE0 < vary: Accept-Encoding < x-fastly-request-id: < content-length: 257 < <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>Tester</title> </head> <body> <h1>Welcome</h1> <p>You've successfully tested the site.</p> </body> </html> An Analogy It is quite important to understand the basic flow of traffic on the internet to understand how our Flask app will be working. Hopefully the technical information above is useful. In this section, I'm going to describe the flow with a metaphor--specifically a postal metaphor. Imagine I'm a freelance consultant in the old days where invoices were sent over the mail. I've done $400 worth of work for Tyler in Spokane at 203 W 28th Avenue, Spokane, WA, 99203. I fill out my invoice with all the pertinent data (hours worked, rate, subtotal, taxes, total, etc.). That is like the web form that you fill out online. Then I fold up my invoice and put it in an envelope with Tyler's address and my return address. The envelope is the HTTP layer that's necessary for routing by the postal network. I drop my letter in the mail and the carrier picks it up. They read the letter and look to see if the address is a valid address. If not, they try to return it to me. If you've ever miss addressed a piece of mail, you've seen that they return it to your return address with a stamp on it saying what the error was (wrong address?). In this case, the process at the postal hub trying to find if my address is valid is like the DNS server trying to find out if the URL is valid and related to a particular physical location (IP address is the address of a particular server or maybe router). If the address was valid, then the postal carriers take my invoice to the address that I put on it. It arrives at that address, and someone has to be answering the mail (imagine it is certified mail and needs to be signed for). If nobody picks it up, the postal carrier will return it to sender with an error message. Otherwise, if Tyler is there to sign for it, he takes the letter, opens the envelop (if we're using HTTPS, this is akin to decrypting) and reads the content. Tyler is the server on the other end waiting to respond. If Tyler is unfamiliar with me or rejects the contents of my request, he'll add a note saying something like \"I don't know what you're talking about\" or something else, and then he'll send my request back to me. This would be like a server sending back an error code because it doesn't know what to do with the request. On the other hand, he'll write me a check, which changes the state of his bank account, and put it into a return envelope with the invoice ticket. Then Tyler puts my address on the return envelope and the same transport process occurs as when I sent my invoice to him. If all that works, I get my money and I'm satisfied. If I get an error code, then I might try again or try a different address. In any case, this process of sending and responding with a bunch of address and content checking along the way is very much like a simplified view of internet traffic.","title":"The Internet"},{"location":"ch5/#the-internet","text":"This chapter is going to give you a general introduction to the internet, internet traffic, and how applications send and receive data. There won't be much code in this chapter, but I believe you should spend some time getting to know, at very least, the basics of how internet traffic works. When traffic flows over the internet, it is broken into packets. Those packets get routed by routers along the way and the recipient's computer reassembles those packages into a complete message. There are two different protocols for this, one that assembles and loads the message as it is received (UDP) and one that waits for the entire message to be received before loading anything (TCP). Streaming video services generally use UDP because the designers know that we're more frustrated by buffering than reduction in video quality. However, this all occurs below the application level and our FLASK application doesn't deal with unassembled packets. UDP and TCP manage the packets before they're sent to the application. Our applications are concerned with the entire message. When we request a page on a website, the message is that entire page. Likewise, when we send data to a website, the message is that entire data object (even if it is a massive photo that must be broken into lots of packets). When we look at an entire message that is sent over the internet, we are talking about the HTTP protocol. This protocol defines how entire messages are sent from one application (a web server, like Flask) to another (a browser, like Firefox). Within this protocols, there are two actions: Requests and Responses. Requests are made by clients, like web browsers, and either request some content from the server or request that some data be accepted by the server. On the other end, servers make responses. They do this when they receive a request from a client and their response depends upon the request.","title":"The Internet"},{"location":"ch5/#requests","text":"An HTTP request is send by a client. This could be your web browser or any other application set up to make requests over the internet using the HTTP protocol. For fun, try out the following in your terminal: $ curl --request GET https://dlondonmedina.github.io/tester/ Curl is a program that sends HTTP requests similar to a web browers. What the above says is send a GET request to the address https://dlondonmedina.github.io/tester/ That request leaves curl and goes through my network card, gets sent across a bunch of routers to a DNS server which matches the name dlondonmedina.github.io with this IP address 185.199.109.153. The specific message is something like \"Get me whatever resource is named 'tester.'\" Now curl waits to see if there's a server that can respond to the particular message at the address 185.199.109.153. We'll see that response in just a moment. Before we get there, you'll notice the word --request GET in the command above. GET is a key word, and refers to a particular method in HTTP. Just as a method is a particular operation of an object and performs particular processes, HTTP methods are the particular operations that a request asks the server to do. GET above means get me whatever data is appropriate for the name 'tester.' The following are the most commonly used HTTP methods, but we'll mainly be concerned with GET and POST. Method Effect GET This method retrieves data from the resource at the specified URL or IP Address. GET should not be used to send data. POST This method submits data to the resource at the specified URL or IP Address. It causes a change in state on the server. For instance, when you create an account on a website, the data you enter in their form is sent via a POST request and stored on, or at least processed by, the server. PUT Like POST, this method submits data to the resource at the specified URL or IP address, but the data is an alteration to a preexisting resource on the server. The new data updates the old data. Think of this as resetting a username that is stored in a database on the server. DELETE This method submits data to identify a particular resource on a server at the specified URL or IP Address, and it deletes that data. There are others, but with Flask, you generally only use GET and POST. A crucial thing to know about using the HTTP methods is that some change the state of an object on the server and others do not. GET, for example, only retrieves data from a server, but doesn't change the state of that data. When you open a blog post on a web page, your browser uses GET to request the contents of the blog post. It doesn't change the coontents on the server or have any other side-effects (like placing an order or creating a user). On the other hand, when you submit a comment to that blog post, the broswer uses the POST method, which adds content to a database on the server, thus changing the state of that database resource. If this is all exciting, I encourage you to read more about all the HTTP methods, and perhaps pursue web development further.","title":"Requests"},{"location":"ch5/#responses","text":"Let's go back to our sample request above. We sent a GET request to the resource located at the URL dlondonmedina.github.io/ requesting the resource 'tester/'. Along with that request, we sent our IP address so that the server knows where to return the response. There are a few things that happen: Once our request goes to the DNS, which pairs the URL: dlondonmedina.github.io with the IP address: 185.199.109.153. Our request is sent to the IP address (185.199.109.153) If there is not a server listening for requests at 185.199.109.153, then an error message will be returned. If there is a server listening for requests at 185.199.109.153, then the server will receive the request and look for 'tester/' as a named resource. If the server doesn't know 'tester/' as a named resource (static file or method), then it will respond with an error. If the server does know 'tester/', then it will gather whatever resource is identified by that name (sometimes an HTML file). Once the resource is gathered, the server sends that data back to the IP address sent by the client along with the address. Here is the full request/response that I showed you above: $ curl -v --request GET https://dlondonmedina.github.io/tester/ <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>Tester</title> </head> <body> <h1>Welcome</h1> <p>You've successfully tested the site.</p> </body> </html> The first line is the request sent by the curl client. The rest of the lines are the HTML content that the server sent back in response. Of course, it's not showing you the entire HTTP wrapper that goes along with the request. The Responses will be sent along with a code that signifies what happend. Status code 200 means that the request was successful. Most other codes identify one sort of error or another. You don't need to know much about the error codes for Flask, but they might be useful to learn for debugging or if you're excited about web technologies. The status codes are part of the HTTP protocol just as the methods listed above are. So, here again is the entire request/response cycle with the HTTP wrapper displayed (I've cut out the TLS handshake that allows encryption to happen with https). The lines beginning with > are the request from my curl client. The lines beginning with < are the response from the server, and everything after <!DOCTYPE html> until </html> is the body of the response: $ curl -v https://dlondonmedina.github.io/tester/ > GET /tester/ HTTP/2 > Host: dlondonmedina.github.io > User-Agent: curl/7.58.0 > Accept: */* > < HTTP/2 200 < server: GitHub.com < content-type: text/html; charset=utf-8 < last-modified: Sat, 18 Apr 2020 01:54:09 GMT < etag: \"5e9a5dc1-101\" < access-control-allow-origin: * < expires: Sat, 18 Apr 2020 02:06:20 GMT < cache-control: max-age=600 < x-proxy-cache: MISS < x-github-request-id: < accept-ranges: bytes < date: Sun, 19 Apr 2020 00:52:52 GMT < via: 1.1 varnish < age: 14 < x-served-by: cache-yvr1522-YVR < x-cache: HIT < x-cache-hits: 1 < x-timer: S1587257573.591449,VS0,VE0 < vary: Accept-Encoding < x-fastly-request-id: < content-length: 257 < <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>Tester</title> </head> <body> <h1>Welcome</h1> <p>You've successfully tested the site.</p> </body> </html>","title":"Responses"},{"location":"ch5/#an-analogy","text":"It is quite important to understand the basic flow of traffic on the internet to understand how our Flask app will be working. Hopefully the technical information above is useful. In this section, I'm going to describe the flow with a metaphor--specifically a postal metaphor. Imagine I'm a freelance consultant in the old days where invoices were sent over the mail. I've done $400 worth of work for Tyler in Spokane at 203 W 28th Avenue, Spokane, WA, 99203. I fill out my invoice with all the pertinent data (hours worked, rate, subtotal, taxes, total, etc.). That is like the web form that you fill out online. Then I fold up my invoice and put it in an envelope with Tyler's address and my return address. The envelope is the HTTP layer that's necessary for routing by the postal network. I drop my letter in the mail and the carrier picks it up. They read the letter and look to see if the address is a valid address. If not, they try to return it to me. If you've ever miss addressed a piece of mail, you've seen that they return it to your return address with a stamp on it saying what the error was (wrong address?). In this case, the process at the postal hub trying to find if my address is valid is like the DNS server trying to find out if the URL is valid and related to a particular physical location (IP address is the address of a particular server or maybe router). If the address was valid, then the postal carriers take my invoice to the address that I put on it. It arrives at that address, and someone has to be answering the mail (imagine it is certified mail and needs to be signed for). If nobody picks it up, the postal carrier will return it to sender with an error message. Otherwise, if Tyler is there to sign for it, he takes the letter, opens the envelop (if we're using HTTPS, this is akin to decrypting) and reads the content. Tyler is the server on the other end waiting to respond. If Tyler is unfamiliar with me or rejects the contents of my request, he'll add a note saying something like \"I don't know what you're talking about\" or something else, and then he'll send my request back to me. This would be like a server sending back an error code because it doesn't know what to do with the request. On the other hand, he'll write me a check, which changes the state of his bank account, and put it into a return envelope with the invoice ticket. Then Tyler puts my address on the return envelope and the same transport process occurs as when I sent my invoice to him. If all that works, I get my money and I'm satisfied. If I get an error code, then I might try again or try a different address. In any case, this process of sending and responding with a bunch of address and content checking along the way is very much like a simplified view of internet traffic.","title":"An Analogy"},{"location":"ch6/","text":"Test Driven Design and the Web Before we move into Flask, I want to walk through an exercise of how we might develop a quick web client using the requests library and the test driven design approach. First, I have set up a resource at http://computingconcepts.herokuapp.com that returns status codes based on the request it receives. I built this as a toy to help students experiment with the requests library, and so it does the following: If it receives a GET request it will respond. If that GET request is accompanied by a user-agent called 'DICE' then it will return the string 44260953 in the body of the response The application is set up to handle POST requests at the resource named 'post', so the complete URL should be https://computingconcepts.herokuapp.com/post and if it received a POST request it will check the data. If the data is {'username': 'bobby', 'email': 'bobby@bobby.com'} then it will return the string 44261853 in the body of the response. If the data is wrong, it will return \"You didn't submit the right data\" The specifications of my assignment is the following: Build three functions: basic_request(), request_user_agent(), and request_post() basic_request takes one parameter: a URL. Uses requests to make a GET request to the URL. It returns -1 if the status code response from the URL is anything but 200, otherwise it returns 200. request_user_agent() takes 2 parameters, a URL and a user agent. It uses requests to make a GET request to the URL with the user agent defined. If the URL is bad or the user agent is not set, it will return -1. Otherwise, it will return the content of the response. I know the server above, so I can test this. request_post() takes 2 parameters, a URL and a data object (probably dictionary). If the URL is bad or if no data is included, it should return -1. Otherwise, it should return the content of the response. I know the server above so I can test this. Just arbitrarily, I want my functions to define a good url as anything that ends with '.com' (Again, this is a toy, so I'm trying to keep it really simple.) I know that I'm doing TDD so I need to start with some tests. I will begin with a setUp() and some tests to test the basic_request() method. requester_tests.py import unittest import requester as target class TestRequester(unittest.TestCase): def setUp(self): self.url = 'http://computingconcepts.herokuapp.com' self.bad_url = 'http://computingconcepts.gopher' self.data = { 'username': 'bobby', 'email': 'bobby@bobby.com' } def test_basic_request_bad_url(self): response = target.basic_request(self.bad_url) self.assertEqual(-1, response) def test_basic_request_good_url(self): response = target.basic_request(self.url) self.assertEqual(200, response) I'll need to install the requests library, so I'll do that right now and create the file requester.py. I'll then run my tests. (env) $ touch requester.py (env) $ pip install requests (env) $ python -m unittest requester_tests.py EE ====================================================================== ERROR: test_basic_request_bad_url (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/requester_tests.py\", line 16, in test_basic_request_bad_url response = target.basic_request(self.bad_url) AttributeError: module 'requester' has no attribute 'basic_request' ====================================================================== ERROR: test_basic_request_good_url (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/requester_tests.py\", line 20, in test_basic_request_good_url response = target.basic_request(self.url) AttributeError: module 'requester' has no attribute 'basic_request' ---------------------------------------------------------------------- Ran 2 tests in 0.001s FAILED (errors=2) Of course we don't have anything in our file, so let's get it set up so that the tests fail the right way. requester.py import requests def basic_request(url): pass I know this will make my tests fail the right way because there is the correct function to call and it returns nothing. Sure enough, when I run my tests: $ python -m unittest requester_tests.py FF ====================================================================== FAIL: test_basic_request_bad_url (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 17, in test_basic_request_bad_url self.assertEqual(-1, response) AssertionError: -1 != None ====================================================================== FAIL: test_basic_request_good_url (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 21, in test_basic_request_good_url self.assertEqual(200, response) AssertionError: 200 != None ---------------------------------------------------------------------- Ran 2 tests in 0.000s FAILED (failures=2) That's exactly the errors we want, so now we want to get it to pass. I know I want the function to check that the URL is valid first (by our silly arbitrary definition of valid as ending with .com). Second, I want it to use requests to call the valid URL. Third, I want to check the status code and return it if it is 200. If 200 is not the status code or there is a problem with the URL, we should return -1. I've done all that in the code below: requester.py import requests def basic_request(url): if url[-4:] != '.com': return -1 resp = requests.get(url) if resp.status_code == 200: return resp.status_code return -1 We run our tests and you'll notice that they hang for a minute on the second test. That's because Python waits on line requests line until it gets a response. The server we're calling is really wimpy, so this might take some time. On my machine, the tests take 10.451 seconds to run. $ python -m unittest requester_tests.py .200 . ---------------------------------------------------------------------- Ran 2 tests in 10.451s OK Now we need to move on to our next function. We need to test that request_user_agent first checks the validity of the url. We also need to check that it returns -1 if the user agent is not set, and finally that it returns the content if the user agent is set. I've built the app on heroku specifically to do this. I know that if the user agent is 'DICE' the response will be 44260953. The idea is that you should be able to predict the output based on the input, and that's what you are testing. requester_tests.py import unittest import requester as target class TestRequester(unittest.TestCase): def setUp(self): self.url = 'https://computingconcepts.herokuapp.com' self.bad_url = 'https://computingconcepts.gopher' self.data = { 'username': 'bobby', 'email': 'bobby@bobby.com' } def test_basic_request_bad_url(self): response = target.basic_request(self.bad_url) self.assertEqual(-1, response) def test_basic_request_good_url(self): response = target.basic_request(self.url) self.assertEqual(200, response) def test_user_agent_bad_url(self): resp = target.request_user_agent(self.bad_url, 'DICE') self.assertEqual(-1, resp) def test_user_agent_no_user_agent(self): resp = target.request_user_agent(self.url, None) self.assertEqual(-1, resp) def test_user_agent_success(self): resp = target.request_user_agent(self.url, 'DICE') self.assertEqual('44260953', resp) I'm also going to quickly add a function to requester.py called request_user_agent() and have it pass so I don't have to go through the errors. We'll see that the tests fail. $ python -m unittest requester_tests.py ..FFF ====================================================================== FAIL: test_user_agent_bad_url (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 25, in test_user_agent_bad_url self.assertEqual(-1, resp) AssertionError: -1 != None ====================================================================== FAIL: test_user_agent_no_user_agent (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 29, in test_user_agent_no_user_agent self.assertEqual(-1, resp) AssertionError: -1 != None ====================================================================== FAIL: test_user_agent_success (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 33, in test_user_agent_success self.assertEqual(44260953, resp) AssertionError: 44260953 != None ---------------------------------------------------------------------- Ran 5 tests in 5.449s FAILED (failures=3) So now we need to write the code to make these tests pass. We can copy our url check from basic_request() and maybe add some or logic to it to catch when our user_agent is None. Then we just need to handle the request. Please do take a moment to look at the documentation for requests to figure out how you might pass a user_agent to the request object. requester.py import requests def basic_request(url): if url[-4:] != '.com': return -1 resp = requests.get(url) if resp.status_code == 200: return resp.status_code return -1 def request_user_agent(url, agent): if url[-4:] != '.com' or agent == None: return -1 headers = { 'User-Agent': agent } resp = requests.get(url, headers = headers) if resp.status_code == 200: return resp.text return -1 What's interesting here is that I ran into an unexpected error. Initially I returned resp.content but that yielded these results: (env) $ python -m unittest requester_tests.py ....F ====================================================================== FAIL: test_user_agent_success (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 33, in test_user_agent_success self.assertEqual(44260953, resp) AssertionError: 44260953 != b'44260953' ---------------------------------------------------------------------- Ran 5 tests in 9.271s FAILED (failures=1) I forgot that the data in the content is returned as bytes, so I had to use the text property instead. Now all my tests pass: (env) $ python -m unittest requester_tests.py ..... ---------------------------------------------------------------------- Ran 5 tests in 10.985s OK Now the last bit that we have to do is build our requests_post() function. Once again, I know that I need to test both of the parameters with the wrong data and both parameters with good data. However, instead of using the GET method, I know my function needs to call requests.post() instead. Again since I built the server to run tests against, I can predict the appropriate input and output for my function if it is working correctly. requester_tests.py import unittest import requester as target class TestRequester(unittest.TestCase): def setUp(self): self.url = 'https://computingconcepts.herokuapp.com' self.bad_url = 'https://computingconcepts.gopher' self.data = { 'username': 'bobby', 'email': 'bobby@bobby.com' } self.bad_data = { } def test_basic_request_bad_url(self): response = target.basic_request(self.bad_url) self.assertEqual(-1, response) def test_basic_request_good_url(self): response = target.basic_request(self.url) self.assertEqual(200, response) def test_user_agent_bad_url(self): resp = target.request_user_agent(self.bad_url, 'DICE') self.assertEqual(-1, resp) def test_user_agent_no_user_agent(self): resp = target.request_user_agent(self.url, None) self.assertEqual(-1, resp) def test_user_agent_success(self): resp = target.request_user_agent(self.url, 'DICE') self.assertEqual('44260953', resp) def test_post_bad_url(self): resp = target.request_post(self.bad_url, self.data) self.assertEqual(-1, resp) def test_post_no_data(self): resp = target.request_post(self.url, None) self.assertEqual(-1, resp) def test_post_bad_data(self): data = {'username': 'bad', 'email':'bad'} resp = target.request_post(self.url, data) self.assertEqual(\"You didn't submit the right data\", resp) def test_post_good_data(self): resp = target.request_post(self.url, self.data) self.assertEqual('44261853', resp) Then we add the request_post() function to requester.py and run our tests: $ python -m unittest requester_tests.py ..FFFF... ====================================================================== FAIL: test_post_bad_data (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 49, in test_post_bad_data self.assertEqual(\"You didn't submit the right data\", resp) AssertionError: \"You didn't submit the right data\" != None ====================================================================== FAIL: test_post_bad_url (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 40, in test_post_bad_url self.assertEqual(-1, resp) AssertionError: -1 != None ====================================================================== FAIL: test_post_good_data (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 53, in test_post_good_data self.assertEqual('44261853', resp) AssertionError: '44261853' != None ====================================================================== FAIL: test_post_no_data (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 44, in test_post_no_data self.assertEqual(-1, resp) AssertionError: -1 != None ---------------------------------------------------------------------- Ran 9 tests in 0.733s FAILED (failures=4) Excellent! Again it's failing like we want it to fail. Again, I've set up my tests to fail in a particular way so that when they pass, I know the code is doing exactly what I want it to be doing. I'm going to build out the code next. Again, I leave you to read up on how to send data with requests. It uses the post() method. requester.py import requests def basic_request(url): if url[-4:] != '.com': return -1 resp = requests.get(url) if resp.status_code == 200: return resp.status_code return -1 def request_user_agent(url, agent): if url[-4:] != '.com' or agent == None: return -1 headers = { 'User-Agent': agent } resp = requests.get(url, headers = headers) if resp.status_code == 200: return resp.text return -1 def request_post(url, data): if url[-4:] != '.com' or data == None: return -1 url = url + '/post' resp = requests.post(url, data = data) if resp.status_code == 200: return resp.text return -1 You'll notice that I'm concatenating '/post' to the url so that the right resource is being called by the request. Then we run our tests and we're good to go. (env) $ python -m unittest requester_tests.py ......... ---------------------------------------------------------------------- Ran 9 tests in 2.363s OK In the next chapter we'll finally be able to get into building our Flask app with TDD. We'll be building a miniature blog over the remaining chapters.","title":"TDD Online"},{"location":"ch6/#test-driven-design-and-the-web","text":"Before we move into Flask, I want to walk through an exercise of how we might develop a quick web client using the requests library and the test driven design approach. First, I have set up a resource at http://computingconcepts.herokuapp.com that returns status codes based on the request it receives. I built this as a toy to help students experiment with the requests library, and so it does the following: If it receives a GET request it will respond. If that GET request is accompanied by a user-agent called 'DICE' then it will return the string 44260953 in the body of the response The application is set up to handle POST requests at the resource named 'post', so the complete URL should be https://computingconcepts.herokuapp.com/post and if it received a POST request it will check the data. If the data is {'username': 'bobby', 'email': 'bobby@bobby.com'} then it will return the string 44261853 in the body of the response. If the data is wrong, it will return \"You didn't submit the right data\" The specifications of my assignment is the following: Build three functions: basic_request(), request_user_agent(), and request_post() basic_request takes one parameter: a URL. Uses requests to make a GET request to the URL. It returns -1 if the status code response from the URL is anything but 200, otherwise it returns 200. request_user_agent() takes 2 parameters, a URL and a user agent. It uses requests to make a GET request to the URL with the user agent defined. If the URL is bad or the user agent is not set, it will return -1. Otherwise, it will return the content of the response. I know the server above, so I can test this. request_post() takes 2 parameters, a URL and a data object (probably dictionary). If the URL is bad or if no data is included, it should return -1. Otherwise, it should return the content of the response. I know the server above so I can test this. Just arbitrarily, I want my functions to define a good url as anything that ends with '.com' (Again, this is a toy, so I'm trying to keep it really simple.) I know that I'm doing TDD so I need to start with some tests. I will begin with a setUp() and some tests to test the basic_request() method. requester_tests.py import unittest import requester as target class TestRequester(unittest.TestCase): def setUp(self): self.url = 'http://computingconcepts.herokuapp.com' self.bad_url = 'http://computingconcepts.gopher' self.data = { 'username': 'bobby', 'email': 'bobby@bobby.com' } def test_basic_request_bad_url(self): response = target.basic_request(self.bad_url) self.assertEqual(-1, response) def test_basic_request_good_url(self): response = target.basic_request(self.url) self.assertEqual(200, response) I'll need to install the requests library, so I'll do that right now and create the file requester.py. I'll then run my tests. (env) $ touch requester.py (env) $ pip install requests (env) $ python -m unittest requester_tests.py EE ====================================================================== ERROR: test_basic_request_bad_url (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/requester_tests.py\", line 16, in test_basic_request_bad_url response = target.basic_request(self.bad_url) AttributeError: module 'requester' has no attribute 'basic_request' ====================================================================== ERROR: test_basic_request_good_url (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/requester_tests.py\", line 20, in test_basic_request_good_url response = target.basic_request(self.url) AttributeError: module 'requester' has no attribute 'basic_request' ---------------------------------------------------------------------- Ran 2 tests in 0.001s FAILED (errors=2) Of course we don't have anything in our file, so let's get it set up so that the tests fail the right way. requester.py import requests def basic_request(url): pass I know this will make my tests fail the right way because there is the correct function to call and it returns nothing. Sure enough, when I run my tests: $ python -m unittest requester_tests.py FF ====================================================================== FAIL: test_basic_request_bad_url (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 17, in test_basic_request_bad_url self.assertEqual(-1, response) AssertionError: -1 != None ====================================================================== FAIL: test_basic_request_good_url (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 21, in test_basic_request_good_url self.assertEqual(200, response) AssertionError: 200 != None ---------------------------------------------------------------------- Ran 2 tests in 0.000s FAILED (failures=2) That's exactly the errors we want, so now we want to get it to pass. I know I want the function to check that the URL is valid first (by our silly arbitrary definition of valid as ending with .com). Second, I want it to use requests to call the valid URL. Third, I want to check the status code and return it if it is 200. If 200 is not the status code or there is a problem with the URL, we should return -1. I've done all that in the code below: requester.py import requests def basic_request(url): if url[-4:] != '.com': return -1 resp = requests.get(url) if resp.status_code == 200: return resp.status_code return -1 We run our tests and you'll notice that they hang for a minute on the second test. That's because Python waits on line requests line until it gets a response. The server we're calling is really wimpy, so this might take some time. On my machine, the tests take 10.451 seconds to run. $ python -m unittest requester_tests.py .200 . ---------------------------------------------------------------------- Ran 2 tests in 10.451s OK Now we need to move on to our next function. We need to test that request_user_agent first checks the validity of the url. We also need to check that it returns -1 if the user agent is not set, and finally that it returns the content if the user agent is set. I've built the app on heroku specifically to do this. I know that if the user agent is 'DICE' the response will be 44260953. The idea is that you should be able to predict the output based on the input, and that's what you are testing. requester_tests.py import unittest import requester as target class TestRequester(unittest.TestCase): def setUp(self): self.url = 'https://computingconcepts.herokuapp.com' self.bad_url = 'https://computingconcepts.gopher' self.data = { 'username': 'bobby', 'email': 'bobby@bobby.com' } def test_basic_request_bad_url(self): response = target.basic_request(self.bad_url) self.assertEqual(-1, response) def test_basic_request_good_url(self): response = target.basic_request(self.url) self.assertEqual(200, response) def test_user_agent_bad_url(self): resp = target.request_user_agent(self.bad_url, 'DICE') self.assertEqual(-1, resp) def test_user_agent_no_user_agent(self): resp = target.request_user_agent(self.url, None) self.assertEqual(-1, resp) def test_user_agent_success(self): resp = target.request_user_agent(self.url, 'DICE') self.assertEqual('44260953', resp) I'm also going to quickly add a function to requester.py called request_user_agent() and have it pass so I don't have to go through the errors. We'll see that the tests fail. $ python -m unittest requester_tests.py ..FFF ====================================================================== FAIL: test_user_agent_bad_url (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 25, in test_user_agent_bad_url self.assertEqual(-1, resp) AssertionError: -1 != None ====================================================================== FAIL: test_user_agent_no_user_agent (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 29, in test_user_agent_no_user_agent self.assertEqual(-1, resp) AssertionError: -1 != None ====================================================================== FAIL: test_user_agent_success (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 33, in test_user_agent_success self.assertEqual(44260953, resp) AssertionError: 44260953 != None ---------------------------------------------------------------------- Ran 5 tests in 5.449s FAILED (failures=3) So now we need to write the code to make these tests pass. We can copy our url check from basic_request() and maybe add some or logic to it to catch when our user_agent is None. Then we just need to handle the request. Please do take a moment to look at the documentation for requests to figure out how you might pass a user_agent to the request object. requester.py import requests def basic_request(url): if url[-4:] != '.com': return -1 resp = requests.get(url) if resp.status_code == 200: return resp.status_code return -1 def request_user_agent(url, agent): if url[-4:] != '.com' or agent == None: return -1 headers = { 'User-Agent': agent } resp = requests.get(url, headers = headers) if resp.status_code == 200: return resp.text return -1 What's interesting here is that I ran into an unexpected error. Initially I returned resp.content but that yielded these results: (env) $ python -m unittest requester_tests.py ....F ====================================================================== FAIL: test_user_agent_success (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 33, in test_user_agent_success self.assertEqual(44260953, resp) AssertionError: 44260953 != b'44260953' ---------------------------------------------------------------------- Ran 5 tests in 9.271s FAILED (failures=1) I forgot that the data in the content is returned as bytes, so I had to use the text property instead. Now all my tests pass: (env) $ python -m unittest requester_tests.py ..... ---------------------------------------------------------------------- Ran 5 tests in 10.985s OK Now the last bit that we have to do is build our requests_post() function. Once again, I know that I need to test both of the parameters with the wrong data and both parameters with good data. However, instead of using the GET method, I know my function needs to call requests.post() instead. Again since I built the server to run tests against, I can predict the appropriate input and output for my function if it is working correctly. requester_tests.py import unittest import requester as target class TestRequester(unittest.TestCase): def setUp(self): self.url = 'https://computingconcepts.herokuapp.com' self.bad_url = 'https://computingconcepts.gopher' self.data = { 'username': 'bobby', 'email': 'bobby@bobby.com' } self.bad_data = { } def test_basic_request_bad_url(self): response = target.basic_request(self.bad_url) self.assertEqual(-1, response) def test_basic_request_good_url(self): response = target.basic_request(self.url) self.assertEqual(200, response) def test_user_agent_bad_url(self): resp = target.request_user_agent(self.bad_url, 'DICE') self.assertEqual(-1, resp) def test_user_agent_no_user_agent(self): resp = target.request_user_agent(self.url, None) self.assertEqual(-1, resp) def test_user_agent_success(self): resp = target.request_user_agent(self.url, 'DICE') self.assertEqual('44260953', resp) def test_post_bad_url(self): resp = target.request_post(self.bad_url, self.data) self.assertEqual(-1, resp) def test_post_no_data(self): resp = target.request_post(self.url, None) self.assertEqual(-1, resp) def test_post_bad_data(self): data = {'username': 'bad', 'email':'bad'} resp = target.request_post(self.url, data) self.assertEqual(\"You didn't submit the right data\", resp) def test_post_good_data(self): resp = target.request_post(self.url, self.data) self.assertEqual('44261853', resp) Then we add the request_post() function to requester.py and run our tests: $ python -m unittest requester_tests.py ..FFFF... ====================================================================== FAIL: test_post_bad_data (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 49, in test_post_bad_data self.assertEqual(\"You didn't submit the right data\", resp) AssertionError: \"You didn't submit the right data\" != None ====================================================================== FAIL: test_post_bad_url (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 40, in test_post_bad_url self.assertEqual(-1, resp) AssertionError: -1 != None ====================================================================== FAIL: test_post_good_data (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 53, in test_post_good_data self.assertEqual('44261853', resp) AssertionError: '44261853' != None ====================================================================== FAIL: test_post_no_data (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 44, in test_post_no_data self.assertEqual(-1, resp) AssertionError: -1 != None ---------------------------------------------------------------------- Ran 9 tests in 0.733s FAILED (failures=4) Excellent! Again it's failing like we want it to fail. Again, I've set up my tests to fail in a particular way so that when they pass, I know the code is doing exactly what I want it to be doing. I'm going to build out the code next. Again, I leave you to read up on how to send data with requests. It uses the post() method. requester.py import requests def basic_request(url): if url[-4:] != '.com': return -1 resp = requests.get(url) if resp.status_code == 200: return resp.status_code return -1 def request_user_agent(url, agent): if url[-4:] != '.com' or agent == None: return -1 headers = { 'User-Agent': agent } resp = requests.get(url, headers = headers) if resp.status_code == 200: return resp.text return -1 def request_post(url, data): if url[-4:] != '.com' or data == None: return -1 url = url + '/post' resp = requests.post(url, data = data) if resp.status_code == 200: return resp.text return -1 You'll notice that I'm concatenating '/post' to the url so that the right resource is being called by the request. Then we run our tests and we're good to go. (env) $ python -m unittest requester_tests.py ......... ---------------------------------------------------------------------- Ran 9 tests in 2.363s OK In the next chapter we'll finally be able to get into building our Flask app with TDD. We'll be building a miniature blog over the remaining chapters.","title":"Test Driven Design and the Web"},{"location":"ch7/","text":"Introduction to Flask Flask is a Python microframework that is amazingly easy to use and still relatively powerful. But before we get ahead of ourselves, what the heck is a framework? Think about it this way: If I wanted to build a brick wall from scratch, I would need to first be able to make bricks from clay. I'd also need to know how to mix mortar to the appropriate consistency. I'd also probably need to know a bit about the general physics behind wall building. Etc. Of course, I don't do that. I'd probably get plans off the internet, buy bricks from Mutual Materials or Home Depot or Salmon Bay, I'd also buy mortar mix (cuz mixing real mortar, while cool, is a pain), and all the tools I need to assemble the wall. A framework is kind of like that. A web framework is a set of classes and functions that have been built for you that you assemble and tweak as you see fit. For instance, you could write a server to listen for HTTP requests. You could also write your own database interface, and so on. But you probably don't need to because one out there already exists that's been tested and optimized for your use case. That's what frameworks do. A framework is a set of tools that manages the common operations of applications freeing up your time to develop within those frameworks the specific features of your application. There are numerous web frameworks to choose from in many languages, most popular include PHP, Python, Javascript, and Ruby. Some popular ones include Wordpress, Drupal, Laravel and CodeIgniter in PHP, and Django and Flask in Python. Wordpress and Drupal are both CMS' rather than web frameworks, but they are often used to develop applications. They provide great tools for people who don't necessarily want to get their hands dirty writing code. That being said, they are much more limited in terms of what you can do unless you want to write your own modules. The rest are more true to the web framework idea. You will have to code something, but much of your coding will involve using build in functions and classes. Laravel and Django are both full frameworks, whereas CodeIgniter and Flask are micro-frameworks. You will notice that I don't mention any Javascript frameworks. That's in part because we won't touch much Javascript, and in part because that material is covered in the WATS program. We're not going to learn Laravel or CodeIgniter because they are in PHP, we learn Python, and PHP is a strange and ugly language that powers much of the web, but doesn't do much else. Once you've learned developing apps in Python, you could easily take a few weeks and learn how to do it in PHP. Here is a chart comparing their popularity based Google Search trends. trends.embed.renderExploreWidget(\"TIMESERIES\", {\"comparisonItem\":[{\"keyword\":\"/m/0dgs72v\",\"geo\":\"US\",\"time\":\"today 5-y\"},{\"keyword\":\"/m/06y_qx\",\"geo\":\"US\",\"time\":\"today 5-y\"},{\"keyword\":\"/m/0jwy148\",\"geo\":\"US\",\"time\":\"today 5-y\"}],\"category\":0,\"property\":\"\"}, {\"exploreQuery\":\"date=today%205-y&amp;geo=US&amp;q=%2Fm%2F0dgs72v,%2Fm%2F06y_qx,%2Fm%2F0jwy148\",\"guestPath\":\"https://trends.google.com:443/trends/embed/\"}); In searching for the top skills that a Python developer ought to have after being familiar with Python, Django and Flask come up as the first and second regularly. We're learning Flask in this class because it's a lot smaller and because it does less of its work automagically. To write a really complicated app in Flask would be more time consuming than it would be in Django because Django is so comprehensive, but we're not building complicated apps, and once you've learned Flask, you can go pick up Django pretty easily. The concepts are the same, but Django has more features built in. Design Patterns Web frameworks are built on a design pattern that separates concerns: for instance, separating the user interface from the processing. Separating concerns is a crucial concept of programming. An example might be the functions we've built so far. You'll notice that we didn't use a single input() function or print() function. This is because we were building general functions whose aim was to perform a single operation. Keeping the processing logic separate from the user interface is useful. My calculator can work with any user interface and is not dependent upon a single user interface to work. I could link it to a command line user interface just as easily as I could link it to a web application. As long as my functions are getting the right parameters, they will return the appropriate values. Additionally, I can have separate design teams working on the data processing and the user interface. This is a good practice in general and makes whatever we build significantly more flexible. Code that keeps elements tightly linked so that the processing is dependent upon the user interface and vice versa is called tightly coupled. For instance, if I used input() to get an integer from my user in the prime_factors() function instead of the parameters, I would have written a user interface that was tightly coupled to the function that processes the input from the user. On the other hand when our components are not necessarily dependent on the design of the other components, we would call them loosely coupled. Generally, loosely coupled components are better. Model View Controller Web frameworks generally separate concerns following a pattern similar to Model-View-Controller, or MVC. The Model-View-Controller pattern separates our concerns into three components. The Model is the component responsible for managing data and usually interfaces with some database where the data will be stored. Likewise, the Model might do some data processing. The View or Views is the component responsible for the user interface. The Views in Web Frameworks usually use some templating language that is rendered into HTML/CSS and Javascript to be sent over the network to the client. Likewise, Views usually include the forms that allow the user to send data to the application. The Controller is the component that links the Models and the Views. Let's say you've created a blog. When the user requests a particular post, they make a GET request through a link in one of the pages rendered in their web browser. The routing mechanism in the framework listens for the particular request and calls the appropriate Controller. The Controller calls the function in the Model that retrieves the requested post. It then takes that data returned by the Model function and puts that into the appropriate view (probably a template for displaying a single blog post on a page). It assembles the data and the template and sends that as an HTML/CSS and Javascript web page for the user to see. There are MVC frameworks written in Python, PHP, C++, Java, and C#. The strength is they are well developed and have all the components you need to build a large website and set of applications. Sometimes the design pattern is slightly different. Django, for instance, follows a Model, View, Template pattern. In this case, the View acts more like a controller. It calls functions from the Model and populates the Template. Regardless of the slight variations, this design pattern that separates concerns is common across frameworks. One cool trick about separating concerns is that you can replace with little difficulty the View component, and one strategy is replacing the View component built into the framework with a Javascript frontend framework like React or Vue or Angular. Generally this is done by having the MVC framework generate JSON objects that get sent to the frontend framework. What this has to do with Flask Flask is not a traditional Framework. It is a microframework, so it does things slightly differently. Traditional frameworks assume that you'll need things like a database and user authentication and so on. As a result, those components are built in and make the framework pretty large. Flask's philosophy is to include only the bare minimum. As a result, it does not come with a database system or user authentication and so on. That doesn't mean you can't add it later, but it does mean that if you don't need a database, it's not there to take up space and get in the way. When the server running Flask gets a request, it sends that request to Flask. Flask's routes listen for known requests. If one of the routes is requested properly, the route function collects all of the resources including the database objects (if using) and the templates, and returns those to the client. This will make more sense when we start building, so let's get started. In the next chapter, we'll seet up the bare minimum web application possible in Flask. It will contain 7 lines of code and we'll developing using TDD.","title":"Intro to Flask"},{"location":"ch7/#introduction-to-flask","text":"Flask is a Python microframework that is amazingly easy to use and still relatively powerful. But before we get ahead of ourselves, what the heck is a framework? Think about it this way: If I wanted to build a brick wall from scratch, I would need to first be able to make bricks from clay. I'd also need to know how to mix mortar to the appropriate consistency. I'd also probably need to know a bit about the general physics behind wall building. Etc. Of course, I don't do that. I'd probably get plans off the internet, buy bricks from Mutual Materials or Home Depot or Salmon Bay, I'd also buy mortar mix (cuz mixing real mortar, while cool, is a pain), and all the tools I need to assemble the wall. A framework is kind of like that. A web framework is a set of classes and functions that have been built for you that you assemble and tweak as you see fit. For instance, you could write a server to listen for HTTP requests. You could also write your own database interface, and so on. But you probably don't need to because one out there already exists that's been tested and optimized for your use case. That's what frameworks do. A framework is a set of tools that manages the common operations of applications freeing up your time to develop within those frameworks the specific features of your application. There are numerous web frameworks to choose from in many languages, most popular include PHP, Python, Javascript, and Ruby. Some popular ones include Wordpress, Drupal, Laravel and CodeIgniter in PHP, and Django and Flask in Python. Wordpress and Drupal are both CMS' rather than web frameworks, but they are often used to develop applications. They provide great tools for people who don't necessarily want to get their hands dirty writing code. That being said, they are much more limited in terms of what you can do unless you want to write your own modules. The rest are more true to the web framework idea. You will have to code something, but much of your coding will involve using build in functions and classes. Laravel and Django are both full frameworks, whereas CodeIgniter and Flask are micro-frameworks. You will notice that I don't mention any Javascript frameworks. That's in part because we won't touch much Javascript, and in part because that material is covered in the WATS program. We're not going to learn Laravel or CodeIgniter because they are in PHP, we learn Python, and PHP is a strange and ugly language that powers much of the web, but doesn't do much else. Once you've learned developing apps in Python, you could easily take a few weeks and learn how to do it in PHP. Here is a chart comparing their popularity based Google Search trends. trends.embed.renderExploreWidget(\"TIMESERIES\", {\"comparisonItem\":[{\"keyword\":\"/m/0dgs72v\",\"geo\":\"US\",\"time\":\"today 5-y\"},{\"keyword\":\"/m/06y_qx\",\"geo\":\"US\",\"time\":\"today 5-y\"},{\"keyword\":\"/m/0jwy148\",\"geo\":\"US\",\"time\":\"today 5-y\"}],\"category\":0,\"property\":\"\"}, {\"exploreQuery\":\"date=today%205-y&amp;geo=US&amp;q=%2Fm%2F0dgs72v,%2Fm%2F06y_qx,%2Fm%2F0jwy148\",\"guestPath\":\"https://trends.google.com:443/trends/embed/\"}); In searching for the top skills that a Python developer ought to have after being familiar with Python, Django and Flask come up as the first and second regularly. We're learning Flask in this class because it's a lot smaller and because it does less of its work automagically. To write a really complicated app in Flask would be more time consuming than it would be in Django because Django is so comprehensive, but we're not building complicated apps, and once you've learned Flask, you can go pick up Django pretty easily. The concepts are the same, but Django has more features built in.","title":"Introduction to Flask"},{"location":"ch7/#design-patterns","text":"Web frameworks are built on a design pattern that separates concerns: for instance, separating the user interface from the processing. Separating concerns is a crucial concept of programming. An example might be the functions we've built so far. You'll notice that we didn't use a single input() function or print() function. This is because we were building general functions whose aim was to perform a single operation. Keeping the processing logic separate from the user interface is useful. My calculator can work with any user interface and is not dependent upon a single user interface to work. I could link it to a command line user interface just as easily as I could link it to a web application. As long as my functions are getting the right parameters, they will return the appropriate values. Additionally, I can have separate design teams working on the data processing and the user interface. This is a good practice in general and makes whatever we build significantly more flexible. Code that keeps elements tightly linked so that the processing is dependent upon the user interface and vice versa is called tightly coupled. For instance, if I used input() to get an integer from my user in the prime_factors() function instead of the parameters, I would have written a user interface that was tightly coupled to the function that processes the input from the user. On the other hand when our components are not necessarily dependent on the design of the other components, we would call them loosely coupled. Generally, loosely coupled components are better.","title":"Design Patterns"},{"location":"ch7/#model-view-controller","text":"Web frameworks generally separate concerns following a pattern similar to Model-View-Controller, or MVC. The Model-View-Controller pattern separates our concerns into three components. The Model is the component responsible for managing data and usually interfaces with some database where the data will be stored. Likewise, the Model might do some data processing. The View or Views is the component responsible for the user interface. The Views in Web Frameworks usually use some templating language that is rendered into HTML/CSS and Javascript to be sent over the network to the client. Likewise, Views usually include the forms that allow the user to send data to the application. The Controller is the component that links the Models and the Views. Let's say you've created a blog. When the user requests a particular post, they make a GET request through a link in one of the pages rendered in their web browser. The routing mechanism in the framework listens for the particular request and calls the appropriate Controller. The Controller calls the function in the Model that retrieves the requested post. It then takes that data returned by the Model function and puts that into the appropriate view (probably a template for displaying a single blog post on a page). It assembles the data and the template and sends that as an HTML/CSS and Javascript web page for the user to see. There are MVC frameworks written in Python, PHP, C++, Java, and C#. The strength is they are well developed and have all the components you need to build a large website and set of applications. Sometimes the design pattern is slightly different. Django, for instance, follows a Model, View, Template pattern. In this case, the View acts more like a controller. It calls functions from the Model and populates the Template. Regardless of the slight variations, this design pattern that separates concerns is common across frameworks. One cool trick about separating concerns is that you can replace with little difficulty the View component, and one strategy is replacing the View component built into the framework with a Javascript frontend framework like React or Vue or Angular. Generally this is done by having the MVC framework generate JSON objects that get sent to the frontend framework.","title":"Model View Controller"},{"location":"ch7/#what-this-has-to-do-with-flask","text":"Flask is not a traditional Framework. It is a microframework, so it does things slightly differently. Traditional frameworks assume that you'll need things like a database and user authentication and so on. As a result, those components are built in and make the framework pretty large. Flask's philosophy is to include only the bare minimum. As a result, it does not come with a database system or user authentication and so on. That doesn't mean you can't add it later, but it does mean that if you don't need a database, it's not there to take up space and get in the way. When the server running Flask gets a request, it sends that request to Flask. Flask's routes listen for known requests. If one of the routes is requested properly, the route function collects all of the resources including the database objects (if using) and the templates, and returns those to the client. This will make more sense when we start building, so let's get started. In the next chapter, we'll seet up the bare minimum web application possible in Flask. It will contain 7 lines of code and we'll developing using TDD.","title":"What this has to do with Flask"},{"location":"ch8/","text":"Getting Started with Flask Ok, so I said in the last chapter that we would begin by writing a Flask web application in 7 lines of code, but that's getting a bit ahead of ourselves. There is some setup that we need to do first. Then we have to write a unittest or two. Then once we get our unittest to fail, we'll build our app and get that unittest to pass. Over the next series of chapters we'll be building a simple blogging platform. To do that, we'll be reusing our code, refactoring, and adding to it as we go. Expect to have to make changes to the code that you've already written. Setup the Environment Our first step is to create a directory where all of our code for this project will go. This will be the project root and nothing for this project should exist outside of this directory. To do this enter your terminal, navigate to a convenient location, and create a directory. For me, I have a directory called Projects where I put all of my projects. So I navigate to that directory, create a new one called blog , which is totally arbitrary, and then change directories into that new directory: ~$ cd Projects ~/Projects/$ mkdir blog && cd blog ~/Projects/blog$ Next, I want to set up a virtual environment and version control. If you've never used git before for version control, I recommend this tutorial: git tutorial . Likewise, if you want to be able to share your code using Github, you can add a remote repository that you can push your changes to. I'll be doing both. I like to do this before I set up the virtual environment because I'm going to tell git to ignore all of the virtual environment files. I'll show you all of the steps first, and then I'll explain each of them. ~/Projects/blog$ git init Initialized empty Git repository in /home/user1/Projects/blog/.git/ ~/Projects/blog$ git remote add origin git@github.com:dlondonmedina/blog.git ~/Projects/blog$ touch .gitignore ~/Projects/blog$ python3 -m venv env ~/Projects/blog$ source env/bin/activate (env) ~/Projects/blog$ pip install flask Collecting flask Downloading https://files.pythonhosted.org/packages/f2/28/2a03252dfb9ebf377f40fba6a7841b47083260bf8bd8e737b0c6952df83f/Flask-1.1.2-py2.py3-none-any.whl (94kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 102kB 1.3MB/s Collecting click>=5.1 (from flask) Downloading https://files.pythonhosted.org/packages/dd/c0/4d8f43a9b16e289f36478422031b8a63b54b6ac3b1ba605d602f10dd54d6/click-7.1.1-py2.py3-none-any.whl (82kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 92kB 2.9MB/s Collecting Werkzeug>=0.15 (from flask) Downloading https://files.pythonhosted.org/packages/cc/94/5f7079a0e00bd6863ef8f1da638721e9da21e5bacee597595b318f71d62e/Werkzeug-1.0.1-py2.py3-none-any.whl (298kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 307kB 3.3MB/s Collecting itsdangerous>=0.24 (from flask) Using cached https://files.pythonhosted.org/packages/76/ae/44b03b253d6fade317f32c24d100b3b35c2239807046a4c953c7b89fa49e/itsdangerous-1.1.0-py2.py3-none-any.whl Collecting Jinja2>=2.10.1 (from flask) Downloading https://files.pythonhosted.org/packages/30/9e/f663a2aa66a09d838042ae1a2c5659828bb9b41ea3a6efa20a20fd92b121/Jinja2-2.11.2-py2.py3-none-any.whl (125kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 133kB 1.6MB/s Collecting MarkupSafe>=0.23 (from Jinja2>=2.10.1->flask) Using cached https://files.pythonhosted.org/packages/b2/5f/23e0023be6bb885d00ffbefad2942bc51a620328ee910f64abe5a8d18dd1/MarkupSafe-1.1.1-cp36-cp36m-manylinux1_x86_64.whl Installing collected packages: click, Werkzeug, itsdangerous, MarkupSafe, Jinja2, flask Successfully installed Jinja2-2.11.2 MarkupSafe-1.1.1 Werkzeug-1.0.1 click-7.1.1 flask-1.1.2 itsdangerous-1.1.0 (env) ~/Projects/blog$ pip freeze > requirements.txt (env) ~/Projects/blog$ ls env requirements.txt git init This initializes the directory as a git repository. This means that I can use git to track the changes made to this directory. What happens is git creates \"snapshots\" of the directory and each time we commit a new \"snapshot\" of the changes from the previous version is saved. If we want to rollback changes, then all that has to happen is for git to restore to the previous snapshot. git remote add origin ... This links my local repository created in the previous line to a remote repository on Github that I already created. It is an empty repository online, so I just need to add the remote link. You'll notice I'm using ssh instead of https. When I want to copy my local repository to my remote repository, I'll use the git push command. touch .gitignore I create a .gitignore file. This tells git that some files should be ignored from the version tracking. I'll add content that next and then I'll commit my changes and push to github. python3 -m venv env This uses the venv module, which is part of Python, to create a virtual environment in a directory called env If you only have Python 3 installed and not Python 2, then your command might be different. On Unix (OSX, Linux) based operating systems you'll probably have Python 2 installed by default. source env/bin/activate This activates the virtual environment. The command is different if you are on Windows ( env\\Scripts\\activate without source ). pip install flask This installs Flask in this virtual environment. If you read the output of this command you'll see that flask, click, Werkzeug, itsdangerous, Jinja2, and MarkupSafe are all also installed. These are the dependencies that flask requires. Since we activated the virutal environment in the last step, Flask is only installed to this environment and not globally. pip freeze > requirements.txt This tells pip to write the list of dependencies that we've installed in this virtual environment to a file called requirements.txt. This will make it easy to reinstall our application elsewhere and make sure our requirements are all correct. Finally, I'm listing out the content of my blog directory. Now we need to get our .gitignore in working order. If you create your repository on Github first and then clone it from there. You can have Github initialize the repository with a README, a License, and a .gitignore files. This is convenient, but I chose not to do that here. So, I need to create the gitignore file. I like to copy the one that Github uses, so I just visit: Github Python.gitignore and copy it into my .gitignore file. .gitignore # Byte-compiled / optimized / DLL files __pycache__/ *.py[cod] *$py.class # C extensions *.so # Distribution / packaging .Python build/ develop-eggs/ dist/ downloads/ eggs/ .eggs/ lib/ lib64/ parts/ sdist/ var/ wheels/ share/python-wheels/ *.egg-info/ .installed.cfg *.egg MANIFEST # PyInstaller # Usually these files are written by a python script from a template # before PyInstaller builds the exe, so as to inject date/other infos into it. *.manifest *.spec # Installer logs pip-log.txt pip-delete-this-directory.txt # Unit test / coverage reports htmlcov/ .tox/ .nox/ .coverage .coverage.* .cache nosetests.xml coverage.xml *.cover *.py,cover .hypothesis/ .pytest_cache/ cover/ # Translations *.mo *.pot # Django stuff: *.log local_settings.py db.sqlite3 db.sqlite3-journal # Flask stuff: instance/ .webassets-cache # Scrapy stuff: .scrapy # Sphinx documentation docs/_build/ # PyBuilder .pybuilder/ target/ # Jupyter Notebook .ipynb_checkpoints # IPython profile_default/ ipython_config.py # pyenv # For a library or package, you might want to ignore these files since the code is # intended to run in multiple environments; otherwise, check them in: # .python-version # pipenv # According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control. # However, in case of collaboration, if having platform-specific dependencies or dependencies # having no cross-platform support, pipenv may install dependencies that don't work, or not # install all needed dependencies. #Pipfile.lock # PEP 582; used by e.g. github.com/David-OConnor/pyflow __pypackages__/ # Celery stuff celerybeat-schedule celerybeat.pid # SageMath parsed files *.sage.py # Environments .env .venv env/ venv/ ENV/ env.bak/ venv.bak/ # Spyder project settings .spyderproject .spyproject # Rope project settings .ropeproject # mkdocs documentation /site # mypy .mypy_cache/ .dmypy.json dmypy.json # Pyre type checker .pyre/ # pytype static type analyzer .pytype/ # Cython debug symbols cython_debug/ I might go through and remove all of the lines that I know I won't use, but for now, this works. For instance, I know that my virtual environment directory is called env/ , so I could remove all of the other ones in the .gitignore. Now I'm almost done. I've created my environment, I just need to commit it to git and push it to Github. This is pretty simple: (env) ~/Projects/blog$ git status On branch master No commits yet Untracked files: (use \"git add <file>...\" to include in what will be committed) .gitignore requirements.txt nothing added to commit but untracked files present (use \"git add\" to track) (env) ~/Projects/blog$ git add . (env) ~/Projects/blog$ git commit -m \"initial commit\" [master (root-commit) c83fa38] initial commit 2 files changed, 146 insertions(+) create mode 100644 .gitignore create mode 100644 requirements.txt (env) ~/Projects/blog$ git push origin master Counting objects: 4, done. Delta compression using up to 4 threads. Compressing objects: 100% (4/4), done. Writing objects: 100% (4/4), 1.40 KiB | 1.40 MiB/s, done. Total 4 (delta 0), reused 0 (delta 0) To github.com:dlondonmedina/blog.git * [new branch] master -> master (env) ~/Projects/blog$ git status This tells me what the status is of my git repositiory. You'll see that .gitignore and requirements.txt are not being tracked yet. I like to check this before I commit because sometimes I am not paying perfect attention to all the changes I've made. git add . This adds all of the untracked files and changes to git tracking. This can be undone at this point. You can also specify which files to track by replacing the dot with the file name. git commit -m \"initial commit\" This line commits the changes I just made to the git repository. In other words, it makes a \"snapshot\" of the repository in this current condition. The \"initial commit\" part is an arbitrary message. It should say briefly what the commit changed. I'm a fan of many smaller commits, so these messages should be short. You'll see as we go. git push origin master This finally pushes the changes we made to our local repository up to our remote repository. It says literally, git, please push the changes made on the master branch to the origin (you'll notice we added the remote as origin in the previous series of commands). Okay. Our environment is set up. Now we're ready to turn to our tests. Building our tests and app Flask is a web application microframework, so what we'll be testing is the features we've built with Flask. Unlike the functions we've tested so far, we'll be testing an application designed to receive its input from clients on the internet. This means we need to think about how our tests are going to access our application. We have two ways to do this: we could run our web application and then have our tests make requests to the test server that runs the web application, or we can use the built in test client and make our requests through the test client. I'm going to walk through both approaches. For the former, we'll be using the requests library, but in the future, we'll be using selenium to simulate requests made by a web browser. More about that in the next chapter. Our first step is to set up our test directory and our app directory. These will keep our application and our tests contained. Both of these directories should be children of blog/ and siblings of env . We're also going to create a few files to get set up. I've included the output from ls to show you what is in each directory. (env) ~/Projects/blog$ mkdir app tests (env) ~/Projects/blog$ touch app.py app/__init__.py (env) ~/Projects/blog$ touch tests/blog_tests.py tests/blog_web_tests.py (env) ~/Projects/blog$ ls app app.py env __pycache__ requirements.txt tests (env) ~/Projects/blog$ ls app __init__.py (env) ~/Projects/blog$ ls tests blog_tests.py blog_web_tests.py Now we're going to get our first test setup. The basic Flask application listens at various different routes. If you recall from the chapters on the Internet, when we navigate the web, we visit URLs. A URL includes the domain and subdomain, followed by any parameters that are sent to the server. So, https://example.com/index.html is a resource at example.com and the specific name of the resource is index.html, which is an html file that the server should be able to return. Web servers are usually setup to serve index.html or index.js or index.php, etc. by default, so a request to https://example.com by default should return index.html. With web frameworks, our servers, however, are not serving up static html files. Instead, they are building the html dynamically. So, https://example.com/posts would make a call to the server listening at the address identified by example.com, and it would call the posts method or route. I'd assume based on the name that the posts method would return a web page containing a list of the current posts. We'll discuss this in depth in the next few chapters, but for now, know that our Flask app has specific routes or methods that are registered and will respond if they are called. This will become more apparent as we start. For now, though, lets set up our first tests. Using Requests I'm going to start by writing the tests that would simulate a user making a request across a network. Then I'll create the test that uses the built-in test_client() feature of Flask. To simulate the requests, I'll use the requests library. To do that I install the library. (env) ~/Projects/blog$ pip install requests and then fix my dependencies with this command (env) ~/Projects/blog$ pip freeze > requirements.txt Now I need to consider what I'm going to test. The easiest way would be to see if the application returns a particular text value. I also need to know what URL the test server uses to host Flask. It happens to be http://127.0.0.1:5000. With that in mind, let's set up our test. blog_web_tests.py import unittest import requests class TestBlog(unittest.TestCase): def setUp(self): self.url = 'http://127.0.0.1:5000/' def test_hello_flask(self): resp = requests.get(self.url) self.assertEquals('Hello Flask!', resp.text) First, I import the two modules--unittest and requests--and then as we've been doing we set up our test class. setUp(self) This method is called automatically by the test runner and it sets a class property called url to the string of the IP address that the Flask test server will be listening at. test_hello_flask(self) This test first uses requests to call the Flask server. It then tests that the server responded with the string 'Hello Flask!'. This is an arbitrary string that I will use when I build the app. Run our tests and let's see where we're at. There will be many errors, so I'm removing the traceback for efficiency sake. ~/Projects/blog$ python -m unittest tests/blog_web_tests.py E ====================================================================== ERROR: test_hello_flask (tests.blog_web_tests.TestBlog) ---------------------------------------------------------------------- Traceback (most recent call last): ... [Removed for brevity] ... ConnectionRefusedError: [Errno 111] Connection refused ---------------------------------------------------------------------- Ran 1 test in 0.033s FAILED (errors=1) The ConnectionRefusedError suggests that when requests tried to make a request to the url, the server at the URL refused it. This makes sense because I don't have an app yet. So let me get some things set up so that at least there's an app. app.py from app import app This is a simple script that initializes our instance of Flask. It will try to import from our app directory, which will automatically run __init__.py.py in that directory, which will contain our Flask application code. So let's go there next. __init__.py from flask import Flask app = Flask(__name__) @app.route('/') def hello_flask(): return '' from flask import Flask We're importing the Flask class which contains our basic web microframework object. app = Flask(__name__) This line instantiates Flask as a variable named \"app.\" If you remember from app.py, the app here is the one that is imported in app.py. @app.route('/') is a decorator that passes the following function to the route() method. Next chapter we will discuss this in depth. For now, think of this as the way hello_flask() is called when a user requests the route. I'm not quite ready to run my tests yet. If I were to do so, I would get the same errors because my Flask app isn't running yet. To do this, I need to launch the Flask app and then run my tests. (env) ~/Projects/blog$ export FLASK_APP=app.py (env) ~/Projects/blog$ python -m flask run * Serving Flask app \"app.py\" * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Debug mode: off * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) export FLASK_APP=app.py This line creates an environmental variable called FLASK_APP. When we call flask run on the next line, the program looks for this variable and then runs the assigned script (app.py). In the following output, we can see some information about the server running our Flask app. Don't worry about the WARNING for now, but the key is to not set up flask on a live web server using this method. Now we open a second terminal, launch our virtual environment, and run our tests again. (env) ~/Projects/blog$ python -m unittest tests/blog_web_tests.py F ====================================================================== FAIL: test_hello_flask (tests.blog_web_tests.TestBlog) ---------------------------------------------------------------------- Traceback (most recent call last): File \"blog/tests/blog_web_tests.py\", line 11, in test_hello_flask self.assertIn('Hello Flask!', resp.text) AssertionError: 'Hello Flask!' not found in '' ---------------------------------------------------------------------- Ran 1 test in 0.005s FAILED (failures=1) This is the kind of failure we're looking for. We'll notice that our flask app is returning an empty string. All we need to do now is change that return and run our tests again. __init__.py from flask import Flask app = Flask(__name__) @app.route('/') def hello_flask(): return 'Hello Flask!' and it fails again. We need to relaunch our flask app. To do this, open the terminal that is running our flask app, and use CTRL+C to stop the process. Then type python -m flask run again and our tests pass: (env) ~/Projects/blog$ python -m unittest tests/blog_web_tests.py. ---------------------------------------------------------------------- Ran 1 test in 0.006s OK Using Test Client Now, I'm going to build tests using the test_client(). I won't rewrite the Flask app, so I'll just show you the new tests. My first step is to shut down the test server I launched in the last section. Just as the test server ran our Flask app, the test_client gives us access to make calls to our app directly without launching a test server. blog_tests.py import unittest from app import app class TestBlog(unittest.TestCase): def setUp(self): self.client = app.test_client() def test_hello_flask(self): resp = self.client.get('/') self.assertEqual(b'Hello Flask!', resp.data) def setUp(self) In this setUp method, we create a test client. This test client can make calls directly to the app without launching the test server as we did in the last section. test_hello_flask() This method is only slightly different. Instead of making the request to the app via requests to the test server, this makes a GET request to the test_client. The major difference that is worth noticing is that the data property of the response is a byte-string so we need to compare 'Hello Flask!' as a byte-string to the data. Now we can run our tests and see them pass again. Conclusion One last step that we need to do is commit all this work we did. (env) ~/Projects/blog$ git status On branch master Changes not staged for commit: (use \"git add <file>...\" to update what will be committed) (use \"git checkout -- <file>...\" to discard changes in working directory) modified: requirements.txt Untracked files: (use \"git add <file>...\" to include in what will be committed) app.py app/ tests/ no changes added to commit (use \"git add\" and/or \"git commit -a\") (env) ~/Projects/blog$ git add . (env) ~/Projects/blog$ git commit -m \"built hello flask\" [master 5a061ab] built hello flask 5 files changed, 36 insertions(+) create mode 100644 app.py create mode 100644 app/__init__.py create mode 100644 tests/blog_tests.py create mode 100644 tests/blog_web_tests.py (env) user1@Desktop1:~/Projects/blog$ git push origin master Counting objects: 9, done. Delta compression using up to 4 threads. Compressing objects: 100% (7/7), done. Writing objects: 100% (9/9), 1.08 KiB | 553.00 KiB/s, done. Total 9 (delta 0), reused 0 (delta 0) To github.com:dlondonmedina/blog.git c83fa38..5a061ab master -> master At this point we have a very simple application. It returns the string 'Hello Flask!' at one route. However, this is a full web application and we'll be building on this as we work towards a fully functional blog. I'll be showing you how to use both the test_client and requests or selenium to test your application.","title":"Smallest App"},{"location":"ch8/#getting-started-with-flask","text":"Ok, so I said in the last chapter that we would begin by writing a Flask web application in 7 lines of code, but that's getting a bit ahead of ourselves. There is some setup that we need to do first. Then we have to write a unittest or two. Then once we get our unittest to fail, we'll build our app and get that unittest to pass. Over the next series of chapters we'll be building a simple blogging platform. To do that, we'll be reusing our code, refactoring, and adding to it as we go. Expect to have to make changes to the code that you've already written.","title":"Getting Started with Flask"},{"location":"ch8/#setup-the-environment","text":"Our first step is to create a directory where all of our code for this project will go. This will be the project root and nothing for this project should exist outside of this directory. To do this enter your terminal, navigate to a convenient location, and create a directory. For me, I have a directory called Projects where I put all of my projects. So I navigate to that directory, create a new one called blog , which is totally arbitrary, and then change directories into that new directory: ~$ cd Projects ~/Projects/$ mkdir blog && cd blog ~/Projects/blog$ Next, I want to set up a virtual environment and version control. If you've never used git before for version control, I recommend this tutorial: git tutorial . Likewise, if you want to be able to share your code using Github, you can add a remote repository that you can push your changes to. I'll be doing both. I like to do this before I set up the virtual environment because I'm going to tell git to ignore all of the virtual environment files. I'll show you all of the steps first, and then I'll explain each of them. ~/Projects/blog$ git init Initialized empty Git repository in /home/user1/Projects/blog/.git/ ~/Projects/blog$ git remote add origin git@github.com:dlondonmedina/blog.git ~/Projects/blog$ touch .gitignore ~/Projects/blog$ python3 -m venv env ~/Projects/blog$ source env/bin/activate (env) ~/Projects/blog$ pip install flask Collecting flask Downloading https://files.pythonhosted.org/packages/f2/28/2a03252dfb9ebf377f40fba6a7841b47083260bf8bd8e737b0c6952df83f/Flask-1.1.2-py2.py3-none-any.whl (94kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 102kB 1.3MB/s Collecting click>=5.1 (from flask) Downloading https://files.pythonhosted.org/packages/dd/c0/4d8f43a9b16e289f36478422031b8a63b54b6ac3b1ba605d602f10dd54d6/click-7.1.1-py2.py3-none-any.whl (82kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 92kB 2.9MB/s Collecting Werkzeug>=0.15 (from flask) Downloading https://files.pythonhosted.org/packages/cc/94/5f7079a0e00bd6863ef8f1da638721e9da21e5bacee597595b318f71d62e/Werkzeug-1.0.1-py2.py3-none-any.whl (298kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 307kB 3.3MB/s Collecting itsdangerous>=0.24 (from flask) Using cached https://files.pythonhosted.org/packages/76/ae/44b03b253d6fade317f32c24d100b3b35c2239807046a4c953c7b89fa49e/itsdangerous-1.1.0-py2.py3-none-any.whl Collecting Jinja2>=2.10.1 (from flask) Downloading https://files.pythonhosted.org/packages/30/9e/f663a2aa66a09d838042ae1a2c5659828bb9b41ea3a6efa20a20fd92b121/Jinja2-2.11.2-py2.py3-none-any.whl (125kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 133kB 1.6MB/s Collecting MarkupSafe>=0.23 (from Jinja2>=2.10.1->flask) Using cached https://files.pythonhosted.org/packages/b2/5f/23e0023be6bb885d00ffbefad2942bc51a620328ee910f64abe5a8d18dd1/MarkupSafe-1.1.1-cp36-cp36m-manylinux1_x86_64.whl Installing collected packages: click, Werkzeug, itsdangerous, MarkupSafe, Jinja2, flask Successfully installed Jinja2-2.11.2 MarkupSafe-1.1.1 Werkzeug-1.0.1 click-7.1.1 flask-1.1.2 itsdangerous-1.1.0 (env) ~/Projects/blog$ pip freeze > requirements.txt (env) ~/Projects/blog$ ls env requirements.txt git init This initializes the directory as a git repository. This means that I can use git to track the changes made to this directory. What happens is git creates \"snapshots\" of the directory and each time we commit a new \"snapshot\" of the changes from the previous version is saved. If we want to rollback changes, then all that has to happen is for git to restore to the previous snapshot. git remote add origin ... This links my local repository created in the previous line to a remote repository on Github that I already created. It is an empty repository online, so I just need to add the remote link. You'll notice I'm using ssh instead of https. When I want to copy my local repository to my remote repository, I'll use the git push command. touch .gitignore I create a .gitignore file. This tells git that some files should be ignored from the version tracking. I'll add content that next and then I'll commit my changes and push to github. python3 -m venv env This uses the venv module, which is part of Python, to create a virtual environment in a directory called env If you only have Python 3 installed and not Python 2, then your command might be different. On Unix (OSX, Linux) based operating systems you'll probably have Python 2 installed by default. source env/bin/activate This activates the virtual environment. The command is different if you are on Windows ( env\\Scripts\\activate without source ). pip install flask This installs Flask in this virtual environment. If you read the output of this command you'll see that flask, click, Werkzeug, itsdangerous, Jinja2, and MarkupSafe are all also installed. These are the dependencies that flask requires. Since we activated the virutal environment in the last step, Flask is only installed to this environment and not globally. pip freeze > requirements.txt This tells pip to write the list of dependencies that we've installed in this virtual environment to a file called requirements.txt. This will make it easy to reinstall our application elsewhere and make sure our requirements are all correct. Finally, I'm listing out the content of my blog directory. Now we need to get our .gitignore in working order. If you create your repository on Github first and then clone it from there. You can have Github initialize the repository with a README, a License, and a .gitignore files. This is convenient, but I chose not to do that here. So, I need to create the gitignore file. I like to copy the one that Github uses, so I just visit: Github Python.gitignore and copy it into my .gitignore file. .gitignore # Byte-compiled / optimized / DLL files __pycache__/ *.py[cod] *$py.class # C extensions *.so # Distribution / packaging .Python build/ develop-eggs/ dist/ downloads/ eggs/ .eggs/ lib/ lib64/ parts/ sdist/ var/ wheels/ share/python-wheels/ *.egg-info/ .installed.cfg *.egg MANIFEST # PyInstaller # Usually these files are written by a python script from a template # before PyInstaller builds the exe, so as to inject date/other infos into it. *.manifest *.spec # Installer logs pip-log.txt pip-delete-this-directory.txt # Unit test / coverage reports htmlcov/ .tox/ .nox/ .coverage .coverage.* .cache nosetests.xml coverage.xml *.cover *.py,cover .hypothesis/ .pytest_cache/ cover/ # Translations *.mo *.pot # Django stuff: *.log local_settings.py db.sqlite3 db.sqlite3-journal # Flask stuff: instance/ .webassets-cache # Scrapy stuff: .scrapy # Sphinx documentation docs/_build/ # PyBuilder .pybuilder/ target/ # Jupyter Notebook .ipynb_checkpoints # IPython profile_default/ ipython_config.py # pyenv # For a library or package, you might want to ignore these files since the code is # intended to run in multiple environments; otherwise, check them in: # .python-version # pipenv # According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control. # However, in case of collaboration, if having platform-specific dependencies or dependencies # having no cross-platform support, pipenv may install dependencies that don't work, or not # install all needed dependencies. #Pipfile.lock # PEP 582; used by e.g. github.com/David-OConnor/pyflow __pypackages__/ # Celery stuff celerybeat-schedule celerybeat.pid # SageMath parsed files *.sage.py # Environments .env .venv env/ venv/ ENV/ env.bak/ venv.bak/ # Spyder project settings .spyderproject .spyproject # Rope project settings .ropeproject # mkdocs documentation /site # mypy .mypy_cache/ .dmypy.json dmypy.json # Pyre type checker .pyre/ # pytype static type analyzer .pytype/ # Cython debug symbols cython_debug/ I might go through and remove all of the lines that I know I won't use, but for now, this works. For instance, I know that my virtual environment directory is called env/ , so I could remove all of the other ones in the .gitignore. Now I'm almost done. I've created my environment, I just need to commit it to git and push it to Github. This is pretty simple: (env) ~/Projects/blog$ git status On branch master No commits yet Untracked files: (use \"git add <file>...\" to include in what will be committed) .gitignore requirements.txt nothing added to commit but untracked files present (use \"git add\" to track) (env) ~/Projects/blog$ git add . (env) ~/Projects/blog$ git commit -m \"initial commit\" [master (root-commit) c83fa38] initial commit 2 files changed, 146 insertions(+) create mode 100644 .gitignore create mode 100644 requirements.txt (env) ~/Projects/blog$ git push origin master Counting objects: 4, done. Delta compression using up to 4 threads. Compressing objects: 100% (4/4), done. Writing objects: 100% (4/4), 1.40 KiB | 1.40 MiB/s, done. Total 4 (delta 0), reused 0 (delta 0) To github.com:dlondonmedina/blog.git * [new branch] master -> master (env) ~/Projects/blog$ git status This tells me what the status is of my git repositiory. You'll see that .gitignore and requirements.txt are not being tracked yet. I like to check this before I commit because sometimes I am not paying perfect attention to all the changes I've made. git add . This adds all of the untracked files and changes to git tracking. This can be undone at this point. You can also specify which files to track by replacing the dot with the file name. git commit -m \"initial commit\" This line commits the changes I just made to the git repository. In other words, it makes a \"snapshot\" of the repository in this current condition. The \"initial commit\" part is an arbitrary message. It should say briefly what the commit changed. I'm a fan of many smaller commits, so these messages should be short. You'll see as we go. git push origin master This finally pushes the changes we made to our local repository up to our remote repository. It says literally, git, please push the changes made on the master branch to the origin (you'll notice we added the remote as origin in the previous series of commands). Okay. Our environment is set up. Now we're ready to turn to our tests.","title":"Setup the Environment"},{"location":"ch8/#building-our-tests-and-app","text":"Flask is a web application microframework, so what we'll be testing is the features we've built with Flask. Unlike the functions we've tested so far, we'll be testing an application designed to receive its input from clients on the internet. This means we need to think about how our tests are going to access our application. We have two ways to do this: we could run our web application and then have our tests make requests to the test server that runs the web application, or we can use the built in test client and make our requests through the test client. I'm going to walk through both approaches. For the former, we'll be using the requests library, but in the future, we'll be using selenium to simulate requests made by a web browser. More about that in the next chapter. Our first step is to set up our test directory and our app directory. These will keep our application and our tests contained. Both of these directories should be children of blog/ and siblings of env . We're also going to create a few files to get set up. I've included the output from ls to show you what is in each directory. (env) ~/Projects/blog$ mkdir app tests (env) ~/Projects/blog$ touch app.py app/__init__.py (env) ~/Projects/blog$ touch tests/blog_tests.py tests/blog_web_tests.py (env) ~/Projects/blog$ ls app app.py env __pycache__ requirements.txt tests (env) ~/Projects/blog$ ls app __init__.py (env) ~/Projects/blog$ ls tests blog_tests.py blog_web_tests.py Now we're going to get our first test setup. The basic Flask application listens at various different routes. If you recall from the chapters on the Internet, when we navigate the web, we visit URLs. A URL includes the domain and subdomain, followed by any parameters that are sent to the server. So, https://example.com/index.html is a resource at example.com and the specific name of the resource is index.html, which is an html file that the server should be able to return. Web servers are usually setup to serve index.html or index.js or index.php, etc. by default, so a request to https://example.com by default should return index.html. With web frameworks, our servers, however, are not serving up static html files. Instead, they are building the html dynamically. So, https://example.com/posts would make a call to the server listening at the address identified by example.com, and it would call the posts method or route. I'd assume based on the name that the posts method would return a web page containing a list of the current posts. We'll discuss this in depth in the next few chapters, but for now, know that our Flask app has specific routes or methods that are registered and will respond if they are called. This will become more apparent as we start. For now, though, lets set up our first tests.","title":"Building our tests and app"},{"location":"ch8/#using-requests","text":"I'm going to start by writing the tests that would simulate a user making a request across a network. Then I'll create the test that uses the built-in test_client() feature of Flask. To simulate the requests, I'll use the requests library. To do that I install the library. (env) ~/Projects/blog$ pip install requests and then fix my dependencies with this command (env) ~/Projects/blog$ pip freeze > requirements.txt Now I need to consider what I'm going to test. The easiest way would be to see if the application returns a particular text value. I also need to know what URL the test server uses to host Flask. It happens to be http://127.0.0.1:5000. With that in mind, let's set up our test. blog_web_tests.py import unittest import requests class TestBlog(unittest.TestCase): def setUp(self): self.url = 'http://127.0.0.1:5000/' def test_hello_flask(self): resp = requests.get(self.url) self.assertEquals('Hello Flask!', resp.text) First, I import the two modules--unittest and requests--and then as we've been doing we set up our test class. setUp(self) This method is called automatically by the test runner and it sets a class property called url to the string of the IP address that the Flask test server will be listening at. test_hello_flask(self) This test first uses requests to call the Flask server. It then tests that the server responded with the string 'Hello Flask!'. This is an arbitrary string that I will use when I build the app. Run our tests and let's see where we're at. There will be many errors, so I'm removing the traceback for efficiency sake. ~/Projects/blog$ python -m unittest tests/blog_web_tests.py E ====================================================================== ERROR: test_hello_flask (tests.blog_web_tests.TestBlog) ---------------------------------------------------------------------- Traceback (most recent call last): ... [Removed for brevity] ... ConnectionRefusedError: [Errno 111] Connection refused ---------------------------------------------------------------------- Ran 1 test in 0.033s FAILED (errors=1) The ConnectionRefusedError suggests that when requests tried to make a request to the url, the server at the URL refused it. This makes sense because I don't have an app yet. So let me get some things set up so that at least there's an app. app.py from app import app This is a simple script that initializes our instance of Flask. It will try to import from our app directory, which will automatically run __init__.py.py in that directory, which will contain our Flask application code. So let's go there next. __init__.py from flask import Flask app = Flask(__name__) @app.route('/') def hello_flask(): return '' from flask import Flask We're importing the Flask class which contains our basic web microframework object. app = Flask(__name__) This line instantiates Flask as a variable named \"app.\" If you remember from app.py, the app here is the one that is imported in app.py. @app.route('/') is a decorator that passes the following function to the route() method. Next chapter we will discuss this in depth. For now, think of this as the way hello_flask() is called when a user requests the route. I'm not quite ready to run my tests yet. If I were to do so, I would get the same errors because my Flask app isn't running yet. To do this, I need to launch the Flask app and then run my tests. (env) ~/Projects/blog$ export FLASK_APP=app.py (env) ~/Projects/blog$ python -m flask run * Serving Flask app \"app.py\" * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Debug mode: off * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) export FLASK_APP=app.py This line creates an environmental variable called FLASK_APP. When we call flask run on the next line, the program looks for this variable and then runs the assigned script (app.py). In the following output, we can see some information about the server running our Flask app. Don't worry about the WARNING for now, but the key is to not set up flask on a live web server using this method. Now we open a second terminal, launch our virtual environment, and run our tests again. (env) ~/Projects/blog$ python -m unittest tests/blog_web_tests.py F ====================================================================== FAIL: test_hello_flask (tests.blog_web_tests.TestBlog) ---------------------------------------------------------------------- Traceback (most recent call last): File \"blog/tests/blog_web_tests.py\", line 11, in test_hello_flask self.assertIn('Hello Flask!', resp.text) AssertionError: 'Hello Flask!' not found in '' ---------------------------------------------------------------------- Ran 1 test in 0.005s FAILED (failures=1) This is the kind of failure we're looking for. We'll notice that our flask app is returning an empty string. All we need to do now is change that return and run our tests again. __init__.py from flask import Flask app = Flask(__name__) @app.route('/') def hello_flask(): return 'Hello Flask!' and it fails again. We need to relaunch our flask app. To do this, open the terminal that is running our flask app, and use CTRL+C to stop the process. Then type python -m flask run again and our tests pass: (env) ~/Projects/blog$ python -m unittest tests/blog_web_tests.py. ---------------------------------------------------------------------- Ran 1 test in 0.006s OK","title":"Using Requests"},{"location":"ch8/#using-test-client","text":"Now, I'm going to build tests using the test_client(). I won't rewrite the Flask app, so I'll just show you the new tests. My first step is to shut down the test server I launched in the last section. Just as the test server ran our Flask app, the test_client gives us access to make calls to our app directly without launching a test server. blog_tests.py import unittest from app import app class TestBlog(unittest.TestCase): def setUp(self): self.client = app.test_client() def test_hello_flask(self): resp = self.client.get('/') self.assertEqual(b'Hello Flask!', resp.data) def setUp(self) In this setUp method, we create a test client. This test client can make calls directly to the app without launching the test server as we did in the last section. test_hello_flask() This method is only slightly different. Instead of making the request to the app via requests to the test server, this makes a GET request to the test_client. The major difference that is worth noticing is that the data property of the response is a byte-string so we need to compare 'Hello Flask!' as a byte-string to the data. Now we can run our tests and see them pass again.","title":"Using Test Client"},{"location":"ch8/#conclusion","text":"One last step that we need to do is commit all this work we did. (env) ~/Projects/blog$ git status On branch master Changes not staged for commit: (use \"git add <file>...\" to update what will be committed) (use \"git checkout -- <file>...\" to discard changes in working directory) modified: requirements.txt Untracked files: (use \"git add <file>...\" to include in what will be committed) app.py app/ tests/ no changes added to commit (use \"git add\" and/or \"git commit -a\") (env) ~/Projects/blog$ git add . (env) ~/Projects/blog$ git commit -m \"built hello flask\" [master 5a061ab] built hello flask 5 files changed, 36 insertions(+) create mode 100644 app.py create mode 100644 app/__init__.py create mode 100644 tests/blog_tests.py create mode 100644 tests/blog_web_tests.py (env) user1@Desktop1:~/Projects/blog$ git push origin master Counting objects: 9, done. Delta compression using up to 4 threads. Compressing objects: 100% (7/7), done. Writing objects: 100% (9/9), 1.08 KiB | 553.00 KiB/s, done. Total 9 (delta 0), reused 0 (delta 0) To github.com:dlondonmedina/blog.git c83fa38..5a061ab master -> master At this point we have a very simple application. It returns the string 'Hello Flask!' at one route. However, this is a full web application and we'll be building on this as we work towards a fully functional blog. I'll be showing you how to use both the test_client and requests or selenium to test your application.","title":"Conclusion"},{"location":"ch9/","text":"Getting Flask Set Up and Your First Functional Test The first functional test checks three things: Is the selenium library installed and can we import webdriver Is there a server serving listening and responding at localhost on port 5000 This is different from the Django. Is that server responding with the page_source attribute set to \"Flask\" Here is the code: from selenium import webdriver browser = webdriver.Firefox() browser.get('http://localhost:5000') assert 'Flask' in browser.page_source functional_tests.py As I follow along with this, I get this error: $ python functional_tests.py Traceback (most recent call last): File \"functional_tests.py\", line 1, in <module> from selenium import webdriver ModuleNotFoundError: No module named 'selenium' Notice that the test failed, but not in the way we expected. Should I have written a separate test that selenium was installed? I could have, but since Python throws an import error anyway, it's not that big of a problem to not have a separate test for it. If you're getting this error as well, then the following should fix things up: (env) $ pip install selenium After Selenium is installed, then you should get the expected error message. We should expect a connection error because we haven't set up Flask yet, so there's no server listening. Getting Flask Up and Running I know I haven't installed Flask in this virtual environment, yet, so I know I'll need to do that first. Django has a CLI to help you build your core site, but since Flask is a lightweight Framework with few moving parts, we don't get that. At the same time, we have far fewer files to deal with and far fewer moving parts, so it's a toss up. Flask is a great tool for smaller projects. Step One: Install Flask Installing Flask is pretty easy. Using pip package manager we just need to install Flask. Make sure that your virtual environment is activated (env) $ pip install Flask At this point, it would also be valuable to create a requirements.txt file. This file allows you to easily set up your app on a different machine without having to move all of the dependencies. You will be using the \"freeze\" command that is build into pip. This command echos the list of dependencies that have been installed in this virtual environment using pip install. Try it out in the terminal and you'll see something like this: (env) $ pip freeze Click==7.0 Flask==1.1.1 itsdangerous==1.1.0 Jinja2==2.11.1 MarkupSafe==1.1.1 selenium==3.141.0 urllib3==1.25.8 Werkzeug==1.0.0 When I installed Flask, I also installed its dependencies (Click, itsdangerous, Jinja2, urllib3, werkzeug). You don't need to do this every time, this was just to show you how pip freeze works. Now you'll need to somehow write the output of pip freeze into a text file called requirements.txt You could copy and past from the terminal, but that's too much work. Instead, you can use the > or >> symbol to write the output of a command directly to a file like so: (env) $ pip freeze > requirements.txt If I use the > symbol, it will either create or overwrite the file to the right of the symbol. NOTICE: if you overwrite data will be lost This is the correct choice in this case because each time we update our requirements.txt file, we want to overwrite it. If we were appending to a file for some other reason, then we would use >> which either creates or appends to the file to the right of the symbol. Step Two: Set Up Your Directory Understanding where your files live is crucial in programming. If the files are not in the right place or if your directory is misshapen, you'll have lots of problems. Django's CLI tool does much of this for you. In Flask, we're on our own. Right now your folder structure within your flask directory should look like this: |--functional_tests.py |--geckodriver.log |--requirements.txt |--env (Virtual Environment Directory) | |--[...] We need to create a directory and three files. We need to create a directory called \"app\" and a file called superlists.py that are both siblings of functional_tests.py. This means they are direct children of our flask directory. We also need to create two files called __init__.py and routes.py that is a child of the \"app\" directory. Here are the commands in the terminal. (env) $ mkdir app && touch superlists.py app/__init__.py app/routes.py You can also enter them as three separate commands if you wish. If this was successful, your flask directory should look like this: |--functional_tests.py |--geckodriver.log |--requirements.txt |--superlists.py |--app | |--__init__.py | |--routes.py |--env (Virtual Environment Directory) | |--[...] If your directory doesn't look exactly like this then go back and check for mistakes before you move on. Now that those files are all created, you can start coding so that the tests will pass. You will be editing superlists.py, __init__.py and routes.py. The first is the script that launches the Flask application. from app import app superlists.py The second is the core of the app (for now). from flask import Flask app = Flask(__name__) from app import routes __init__.py The third is a file that manages the routes. from app import app @app.route('/') @app.route('/index') def index(): return \"Hello, Flask!\" We'll be discussing all of these later on in great detail. Once you've created all of these files, you'll need to start your Flask app so that you can run your tests again. This will require you to have 2 terminals open. In the first terminal, start the Flask app: (env) $ flask run and in the second terminal (make sure you've navigated to your project directory and activated your virtual environment): (env) $ python functional_tests.py At this point, the functional tests will open a new browser and call the Flask app. As soon as that loads, you can close the browser. In your terminal, you should get no error messages. If that's the case, you've successfully completed this. If not, you'll need to go through and revise your code until it works. Make sure to read any error messages for a clue as to what to fix. Now, you'll want to initialize your flask project directory as a git repository. Create a gitignore file that contains at least the following: # Byte-compiled / optimized / DLL files __pycache__/ # Unit test / coverage reports .pytest_cache/ # Flask stuff: db.sqlite3 db.sqlite3-journal instance/ .webassets-cache # Environments env/ # Visual Studio Code .vscode/ .gitignore Then create a new github repository and push your local repository to github. You're done with getting started!","title":"Getting Flask Set Up and Your First Functional Test"},{"location":"ch9/#getting-flask-set-up-and-your-first-functional-test","text":"The first functional test checks three things: Is the selenium library installed and can we import webdriver Is there a server serving listening and responding at localhost on port 5000 This is different from the Django. Is that server responding with the page_source attribute set to \"Flask\" Here is the code: from selenium import webdriver browser = webdriver.Firefox() browser.get('http://localhost:5000') assert 'Flask' in browser.page_source functional_tests.py As I follow along with this, I get this error: $ python functional_tests.py Traceback (most recent call last): File \"functional_tests.py\", line 1, in <module> from selenium import webdriver ModuleNotFoundError: No module named 'selenium' Notice that the test failed, but not in the way we expected. Should I have written a separate test that selenium was installed? I could have, but since Python throws an import error anyway, it's not that big of a problem to not have a separate test for it. If you're getting this error as well, then the following should fix things up: (env) $ pip install selenium After Selenium is installed, then you should get the expected error message. We should expect a connection error because we haven't set up Flask yet, so there's no server listening.","title":"Getting Flask Set Up and Your First Functional Test"},{"location":"ch9/#getting-flask-up-and-running","text":"I know I haven't installed Flask in this virtual environment, yet, so I know I'll need to do that first. Django has a CLI to help you build your core site, but since Flask is a lightweight Framework with few moving parts, we don't get that. At the same time, we have far fewer files to deal with and far fewer moving parts, so it's a toss up. Flask is a great tool for smaller projects.","title":"Getting Flask Up and Running"},{"location":"ch9/#step-one-install-flask","text":"Installing Flask is pretty easy. Using pip package manager we just need to install Flask. Make sure that your virtual environment is activated (env) $ pip install Flask At this point, it would also be valuable to create a requirements.txt file. This file allows you to easily set up your app on a different machine without having to move all of the dependencies. You will be using the \"freeze\" command that is build into pip. This command echos the list of dependencies that have been installed in this virtual environment using pip install. Try it out in the terminal and you'll see something like this: (env) $ pip freeze Click==7.0 Flask==1.1.1 itsdangerous==1.1.0 Jinja2==2.11.1 MarkupSafe==1.1.1 selenium==3.141.0 urllib3==1.25.8 Werkzeug==1.0.0 When I installed Flask, I also installed its dependencies (Click, itsdangerous, Jinja2, urllib3, werkzeug). You don't need to do this every time, this was just to show you how pip freeze works. Now you'll need to somehow write the output of pip freeze into a text file called requirements.txt You could copy and past from the terminal, but that's too much work. Instead, you can use the > or >> symbol to write the output of a command directly to a file like so: (env) $ pip freeze > requirements.txt If I use the > symbol, it will either create or overwrite the file to the right of the symbol. NOTICE: if you overwrite data will be lost This is the correct choice in this case because each time we update our requirements.txt file, we want to overwrite it. If we were appending to a file for some other reason, then we would use >> which either creates or appends to the file to the right of the symbol.","title":"Step One: Install Flask"},{"location":"ch9/#step-two-set-up-your-directory","text":"Understanding where your files live is crucial in programming. If the files are not in the right place or if your directory is misshapen, you'll have lots of problems. Django's CLI tool does much of this for you. In Flask, we're on our own. Right now your folder structure within your flask directory should look like this: |--functional_tests.py |--geckodriver.log |--requirements.txt |--env (Virtual Environment Directory) | |--[...] We need to create a directory and three files. We need to create a directory called \"app\" and a file called superlists.py that are both siblings of functional_tests.py. This means they are direct children of our flask directory. We also need to create two files called __init__.py and routes.py that is a child of the \"app\" directory. Here are the commands in the terminal. (env) $ mkdir app && touch superlists.py app/__init__.py app/routes.py You can also enter them as three separate commands if you wish. If this was successful, your flask directory should look like this: |--functional_tests.py |--geckodriver.log |--requirements.txt |--superlists.py |--app | |--__init__.py | |--routes.py |--env (Virtual Environment Directory) | |--[...] If your directory doesn't look exactly like this then go back and check for mistakes before you move on. Now that those files are all created, you can start coding so that the tests will pass. You will be editing superlists.py, __init__.py and routes.py. The first is the script that launches the Flask application. from app import app superlists.py The second is the core of the app (for now). from flask import Flask app = Flask(__name__) from app import routes __init__.py The third is a file that manages the routes. from app import app @app.route('/') @app.route('/index') def index(): return \"Hello, Flask!\" We'll be discussing all of these later on in great detail. Once you've created all of these files, you'll need to start your Flask app so that you can run your tests again. This will require you to have 2 terminals open. In the first terminal, start the Flask app: (env) $ flask run and in the second terminal (make sure you've navigated to your project directory and activated your virtual environment): (env) $ python functional_tests.py At this point, the functional tests will open a new browser and call the Flask app. As soon as that loads, you can close the browser. In your terminal, you should get no error messages. If that's the case, you've successfully completed this. If not, you'll need to go through and revise your code until it works. Make sure to read any error messages for a clue as to what to fix. Now, you'll want to initialize your flask project directory as a git repository. Create a gitignore file that contains at least the following: # Byte-compiled / optimized / DLL files __pycache__/ # Unit test / coverage reports .pytest_cache/ # Flask stuff: db.sqlite3 db.sqlite3-journal instance/ .webassets-cache # Environments env/ # Visual Studio Code .vscode/ .gitignore Then create a new github repository and push your local repository to github. You're done with getting started!","title":"Step Two: Set Up Your Directory"}]}