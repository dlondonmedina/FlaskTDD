{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TDD in Flask This book is a supplement to Test-Driven Development with Python: Obey the Testing Goat: Using Django, Selenium, and Javascript . In this version, much of the content is not copied over. Instead this provides modified exercises and examples using Flask instead of Django. If you have a bit more experience with Python or want to use a more robust framework, I encourage you to take a look at Percival's book. If you want to learn about test-driven development but find Flask suits your purposes better, this is a supplement for you. This book is being built for a course offered at Seattle University, and therefore will contain some additional content for that course. In the future, perhaps video lectures and exercises will become available. For the exercises, starter-code is available. Please feel free to clone it here . About the Author I direct the Web, Application, and Technology Studies program at Seattle University\u2019s School of New and Continuing Studies. My research and pedagogy are deeply invested learning and its application to future contexts. My MA and PhD research focuses on how students acquire and deploy rhetorical strategies and skills within the social, material, and technological landscapes in which they work. I teach in the areas of social theory, social science research, writing, web development, and Python. At heart, I am a maker and have devoted a great deal of energy to creating projects and programs to address problems I see in the world around me. This lead me to develop a transition workshop for service members, which I taught for four years at Joint Base Lewis-McChord. I also lead a team developing Cluster\u2014a suite of tools that work like a personal writing trainer. In the summer, I teach a Python camp for underrepresented kids. Acknowledgements This book is written by Dylan Medina and is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License . It is a Flask supplement for Test-Driven Development with Python by Harry J.W. Percival. Please visit his site and consider purchasing his excellent book. This book ports the exercises from Django to Flask.","title":"Home"},{"location":"#tdd-in-flask","text":"This book is a supplement to Test-Driven Development with Python: Obey the Testing Goat: Using Django, Selenium, and Javascript . In this version, much of the content is not copied over. Instead this provides modified exercises and examples using Flask instead of Django. If you have a bit more experience with Python or want to use a more robust framework, I encourage you to take a look at Percival's book. If you want to learn about test-driven development but find Flask suits your purposes better, this is a supplement for you. This book is being built for a course offered at Seattle University, and therefore will contain some additional content for that course. In the future, perhaps video lectures and exercises will become available. For the exercises, starter-code is available. Please feel free to clone it here .","title":"TDD in Flask"},{"location":"#about-the-author","text":"I direct the Web, Application, and Technology Studies program at Seattle University\u2019s School of New and Continuing Studies. My research and pedagogy are deeply invested learning and its application to future contexts. My MA and PhD research focuses on how students acquire and deploy rhetorical strategies and skills within the social, material, and technological landscapes in which they work. I teach in the areas of social theory, social science research, writing, web development, and Python. At heart, I am a maker and have devoted a great deal of energy to creating projects and programs to address problems I see in the world around me. This lead me to develop a transition workshop for service members, which I taught for four years at Joint Base Lewis-McChord. I also lead a team developing Cluster\u2014a suite of tools that work like a personal writing trainer. In the summer, I teach a Python camp for underrepresented kids.","title":"About the Author"},{"location":"#acknowledgements","text":"This book is written by Dylan Medina and is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License . It is a Flask supplement for Test-Driven Development with Python by Harry J.W. Percival. Please visit his site and consider purchasing his excellent book. This book ports the exercises from Django to Flask.","title":"Acknowledgements"},{"location":"ch1/","text":"Getting Flask Set Up and Your First Functional Test The first functional test checks three things: Is the selenium library installed and can we import webdriver Is there a server serving listening and responding at localhost on port 5000 This is different from the Django. Is that server responding with the page_source attribute set to \"Flask\" Here is the code: from selenium import webdriver browser = webdriver.Firefox() browser.get('http://localhost:5000') assert 'Flask' in browser.page_source functional_tests.py As I follow along with this, I get this error: $ python functional_tests.py Traceback (most recent call last): File \"functional_tests.py\", line 1, in <module> from selenium import webdriver ModuleNotFoundError: No module named 'selenium' Notice that the test failed, but not in the way we expected. Should I have written a separate test that selenium was installed? I could have, but since Python throws an import error anyway, it's not that big of a problem to not have a separate test for it. If you're getting this error as well, then the following should fix things up: (env) $ pip install selenium After Selenium is installed, then you should get the expected error message. We should expect a connection error because we haven't set up Flask yet, so there's no server listening. Getting Flask Up and Running I know I haven't installed Flask in this virtual environment, yet, so I know I'll need to do that first. Django has a CLI to help you build your core site, but since Flask is a lightweight Framework with few moving parts, we don't get that. At the same time, we have far fewer files to deal with and far fewer moving parts, so it's a toss up. Flask is a great tool for smaller projects. Step One: Install Flask Installing Flask is pretty easy. Using pip package manager we just need to install Flask. Make sure that your virtual environment is activated (env) $ pip install Flask At this point, it would also be valuable to create a requirements.txt file. This file allows you to easily set up your app on a different machine without having to move all of the dependencies. You will be using the \"freeze\" command that is build into pip. This command echos the list of dependencies that have been installed in this virtual environment using pip install. Try it out in the terminal and you'll see something like this: (env) $ pip freeze Click==7.0 Flask==1.1.1 itsdangerous==1.1.0 Jinja2==2.11.1 MarkupSafe==1.1.1 selenium==3.141.0 urllib3==1.25.8 Werkzeug==1.0.0 When I installed Flask, I also installed its dependencies (Click, itsdangerous, Jinja2, urllib3, werkzeug). You don't need to do this every time, this was just to show you how pip freeze works. Now you'll need to somehow write the output of pip freeze into a text file called requirements.txt You could copy and past from the terminal, but that's too much work. Instead, you can use the > or >> symbol to write the output of a command directly to a file like so: (env) $ pip freeze > requirements.txt If I use the > symbol, it will either create or overwrite the file to the right of the symbol. NOTICE: if you overwrite data will be lost This is the correct choice in this case because each time we update our requirements.txt file, we want to overwrite it. If we were appending to a file for some other reason, then we would use >> which either creates or appends to the file to the right of the symbol. Step Two: Set Up Your Directory Understanding where your files live is crucial in programming. If the files are not in the right place or if your directory is misshapen, you'll have lots of problems. Django's CLI tool does much of this for you. In Flask, we're on our own. Right now your folder structure within your flask directory should look like this: |--functional_tests.py |--geckodriver.log |--requirements.txt |--env (Virtual Environment Directory) | |--[...] We need to create a directory and three files. We need to create a directory called \"app\" and a file called superlists.py that are both siblings of functional_tests.py. This means they are direct children of our flask directory. We also need to create two files called __init__.py and routes.py that is a child of the \"app\" directory. Here are the commands in the terminal. (env) $ mkdir app && touch superlists.py app/__init__.py app/routes.py You can also enter them as three separate commands if you wish. If this was successful, your flask directory should look like this: |--functional_tests.py |--geckodriver.log |--requirements.txt |--superlists.py |--app | |--__init__.py | |--routes.py |--env (Virtual Environment Directory) | |--[...] If your directory doesn't look exactly like this then go back and check for mistakes before you move on. Now that those files are all created, you can start coding so that the tests will pass. You will be editing superlists.py, __init__.py and routes.py. The first is the script that launches the Flask application. from app import app superlists.py The second is the core of the app (for now). from flask import Flask app = Flask(__name__) from app import routes __init__.py The third is a file that manages the routes. from app import app @app.route('/') @app.route('/index') def index(): return \"Hello, Flask!\" We'll be discussing all of these later on in great detail. Once you've created all of these files, you'll need to start your Flask app so that you can run your tests again. This will require you to have 2 terminals open. In the first terminal, start the Flask app: (env) $ flask run and in the second terminal (make sure you've navigated to your project directory and activated your virtual environment): (env) $ python functional_tests.py At this point, the functional tests will open a new browser and call the Flask app. As soon as that loads, you can close the browser. In your terminal, you should get no error messages. If that's the case, you've successfully completed this. If not, you'll need to go through and revise your code until it works. Make sure to read any error messages for a clue as to what to fix. Now, you'll want to initialize your flask project directory as a git repository. Create a gitignore file that contains at least the following: # Byte-compiled / optimized / DLL files __pycache__/ # Unit test / coverage reports .pytest_cache/ # Flask stuff: db.sqlite3 db.sqlite3-journal instance/ .webassets-cache # Environments env/ # Visual Studio Code .vscode/ .gitignore Then create a new github repository and push your local repository to github. You're done with getting started!","title":"One"},{"location":"ch1/#getting-flask-set-up-and-your-first-functional-test","text":"The first functional test checks three things: Is the selenium library installed and can we import webdriver Is there a server serving listening and responding at localhost on port 5000 This is different from the Django. Is that server responding with the page_source attribute set to \"Flask\" Here is the code: from selenium import webdriver browser = webdriver.Firefox() browser.get('http://localhost:5000') assert 'Flask' in browser.page_source functional_tests.py As I follow along with this, I get this error: $ python functional_tests.py Traceback (most recent call last): File \"functional_tests.py\", line 1, in <module> from selenium import webdriver ModuleNotFoundError: No module named 'selenium' Notice that the test failed, but not in the way we expected. Should I have written a separate test that selenium was installed? I could have, but since Python throws an import error anyway, it's not that big of a problem to not have a separate test for it. If you're getting this error as well, then the following should fix things up: (env) $ pip install selenium After Selenium is installed, then you should get the expected error message. We should expect a connection error because we haven't set up Flask yet, so there's no server listening.","title":"Getting Flask Set Up and Your First Functional Test"},{"location":"ch1/#getting-flask-up-and-running","text":"I know I haven't installed Flask in this virtual environment, yet, so I know I'll need to do that first. Django has a CLI to help you build your core site, but since Flask is a lightweight Framework with few moving parts, we don't get that. At the same time, we have far fewer files to deal with and far fewer moving parts, so it's a toss up. Flask is a great tool for smaller projects.","title":"Getting Flask Up and Running"},{"location":"ch1/#step-one-install-flask","text":"Installing Flask is pretty easy. Using pip package manager we just need to install Flask. Make sure that your virtual environment is activated (env) $ pip install Flask At this point, it would also be valuable to create a requirements.txt file. This file allows you to easily set up your app on a different machine without having to move all of the dependencies. You will be using the \"freeze\" command that is build into pip. This command echos the list of dependencies that have been installed in this virtual environment using pip install. Try it out in the terminal and you'll see something like this: (env) $ pip freeze Click==7.0 Flask==1.1.1 itsdangerous==1.1.0 Jinja2==2.11.1 MarkupSafe==1.1.1 selenium==3.141.0 urllib3==1.25.8 Werkzeug==1.0.0 When I installed Flask, I also installed its dependencies (Click, itsdangerous, Jinja2, urllib3, werkzeug). You don't need to do this every time, this was just to show you how pip freeze works. Now you'll need to somehow write the output of pip freeze into a text file called requirements.txt You could copy and past from the terminal, but that's too much work. Instead, you can use the > or >> symbol to write the output of a command directly to a file like so: (env) $ pip freeze > requirements.txt If I use the > symbol, it will either create or overwrite the file to the right of the symbol. NOTICE: if you overwrite data will be lost This is the correct choice in this case because each time we update our requirements.txt file, we want to overwrite it. If we were appending to a file for some other reason, then we would use >> which either creates or appends to the file to the right of the symbol.","title":"Step One: Install Flask"},{"location":"ch1/#step-two-set-up-your-directory","text":"Understanding where your files live is crucial in programming. If the files are not in the right place or if your directory is misshapen, you'll have lots of problems. Django's CLI tool does much of this for you. In Flask, we're on our own. Right now your folder structure within your flask directory should look like this: |--functional_tests.py |--geckodriver.log |--requirements.txt |--env (Virtual Environment Directory) | |--[...] We need to create a directory and three files. We need to create a directory called \"app\" and a file called superlists.py that are both siblings of functional_tests.py. This means they are direct children of our flask directory. We also need to create two files called __init__.py and routes.py that is a child of the \"app\" directory. Here are the commands in the terminal. (env) $ mkdir app && touch superlists.py app/__init__.py app/routes.py You can also enter them as three separate commands if you wish. If this was successful, your flask directory should look like this: |--functional_tests.py |--geckodriver.log |--requirements.txt |--superlists.py |--app | |--__init__.py | |--routes.py |--env (Virtual Environment Directory) | |--[...] If your directory doesn't look exactly like this then go back and check for mistakes before you move on. Now that those files are all created, you can start coding so that the tests will pass. You will be editing superlists.py, __init__.py and routes.py. The first is the script that launches the Flask application. from app import app superlists.py The second is the core of the app (for now). from flask import Flask app = Flask(__name__) from app import routes __init__.py The third is a file that manages the routes. from app import app @app.route('/') @app.route('/index') def index(): return \"Hello, Flask!\" We'll be discussing all of these later on in great detail. Once you've created all of these files, you'll need to start your Flask app so that you can run your tests again. This will require you to have 2 terminals open. In the first terminal, start the Flask app: (env) $ flask run and in the second terminal (make sure you've navigated to your project directory and activated your virtual environment): (env) $ python functional_tests.py At this point, the functional tests will open a new browser and call the Flask app. As soon as that loads, you can close the browser. In your terminal, you should get no error messages. If that's the case, you've successfully completed this. If not, you'll need to go through and revise your code until it works. Make sure to read any error messages for a clue as to what to fix. Now, you'll want to initialize your flask project directory as a git repository. Create a gitignore file that contains at least the following: # Byte-compiled / optimized / DLL files __pycache__/ # Unit test / coverage reports .pytest_cache/ # Flask stuff: db.sqlite3 db.sqlite3-journal instance/ .webassets-cache # Environments env/ # Visual Studio Code .vscode/ .gitignore Then create a new github repository and push your local repository to github. You're done with getting started!","title":"Step Two: Set Up Your Directory"}]}