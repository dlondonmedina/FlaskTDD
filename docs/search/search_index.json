{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TDD in Flask This book is a supplement to Test-Driven Development with Python: Obey the Testing Goat: Using Django, Selenium, and Javascript . In this version, much of the content is not copied over. Instead this provides modified exercises and examples using Flask instead of Django. If you have a bit more experience with Python or want to use a more robust framework, I encourage you to take a look at Percival's book. If you want to learn about test-driven development but find Flask suits your purposes better, this is a supplement for you. This book is being built for a course offered at Seattle University, and therefore will contain some additional content for that course. In the future, perhaps video lectures and exercises will become available. For the exercises, starter-code is available. Please feel free to clone it here . About the Author I direct the Web, Application, and Technology Studies program at Seattle University\u2019s School of New and Continuing Studies. My research and pedagogy are deeply invested learning and its application to future contexts. My MA and PhD research focuses on how students acquire and deploy rhetorical strategies and skills within the social, material, and technological landscapes in which they work. I teach in the areas of social theory, social science research, writing, web development, and Python. At heart, I am a maker and have devoted a great deal of energy to creating projects and programs to address problems I see in the world around me. This lead me to develop a transition workshop for service members, which I taught for four years at Joint Base Lewis-McChord. I also lead a team developing Cluster\u2014a suite of tools that work like a personal writing trainer. In the summer, I teach a Python camp for underrepresented kids. Acknowledgements This book is written by Dylan Medina and is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License . It is a Flask supplement for Test-Driven Development with Python by Harry J.W. Percival. Please visit his site and consider purchasing his excellent book. This book ports the exercises from Django to Flask.","title":"Home"},{"location":"#tdd-in-flask","text":"This book is a supplement to Test-Driven Development with Python: Obey the Testing Goat: Using Django, Selenium, and Javascript . In this version, much of the content is not copied over. Instead this provides modified exercises and examples using Flask instead of Django. If you have a bit more experience with Python or want to use a more robust framework, I encourage you to take a look at Percival's book. If you want to learn about test-driven development but find Flask suits your purposes better, this is a supplement for you. This book is being built for a course offered at Seattle University, and therefore will contain some additional content for that course. In the future, perhaps video lectures and exercises will become available. For the exercises, starter-code is available. Please feel free to clone it here .","title":"TDD in Flask"},{"location":"#about-the-author","text":"I direct the Web, Application, and Technology Studies program at Seattle University\u2019s School of New and Continuing Studies. My research and pedagogy are deeply invested learning and its application to future contexts. My MA and PhD research focuses on how students acquire and deploy rhetorical strategies and skills within the social, material, and technological landscapes in which they work. I teach in the areas of social theory, social science research, writing, web development, and Python. At heart, I am a maker and have devoted a great deal of energy to creating projects and programs to address problems I see in the world around me. This lead me to develop a transition workshop for service members, which I taught for four years at Joint Base Lewis-McChord. I also lead a team developing Cluster\u2014a suite of tools that work like a personal writing trainer. In the summer, I teach a Python camp for underrepresented kids.","title":"About the Author"},{"location":"#acknowledgements","text":"This book is written by Dylan Medina and is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License . It is a Flask supplement for Test-Driven Development with Python by Harry J.W. Percival. Please visit his site and consider purchasing his excellent book. This book ports the exercises from Django to Flask.","title":"Acknowledgements"},{"location":"ch1/","text":"Introduction to TDD There are many different approaches to developing software. One of the major ones that is used, especially in enterprise scale projects, is Test-Driven Development (TDD). TDD means that before we write any code we write a test that will determine if our code is functioning the way we want it to. For instance, let's say I want to build a function that returns a list of prime factors of an integer passed into the function. Let's also say, I want that function to return None if the value passed to the function is not an integer. If we are not using a TDD approach we might start by writing our function directly. However, we'll spend a lot of time debugging and running into issues if we do so. Instead, let's think about the things that we need to test: The easiest case is when the input is incorrect. We can set up a test that will call the function with a value that is not an integer and test that we receive None as the return. We need to test that the function returns a list when it is passed an integer. We need to test that the list contains the prime factors of the input integer. A simple and dirty way to test this is to write a driver that tests all of the functionality above. It might look something like this: if __name__ == \"__main__\": out1 = prime_factors(\"apple\") if out1 is None: print(\"Out is None. Pass\") else: print(\"Does not return None. Fail\") out2 = prime_factors(315) if isinstance(out2, list): print(\"Returns a list. Pass\") if out2 == [3, 5, 7]: print(\"Out is 3, 5, 7. Pass\") else: print(\"Does not return the right list. Fail\") else: print(\"Does not return a list. Fail) From there, I'd write out my function and make sure it's called prime_factors(). If you'd like, you can try using this method, and see if you can get it working. For a small, toy task like this, you might be able to sufficiently test your program with a driver, but you end up with a messy driver at the bottom of your program that you'll want to delete later on, and it's an awful lot of lines. Doctest Fortunately, Python includes a number of test tools that can help us do TDD more easily and make our tests more effective. The first of which is doctest , and it comes built-in with Python. Doctest allows you to write your tests into the docstring of your function. If you recall, a docstring is the bit of documentation this is included in triple double quotes when you define a function. The same tests as above would look like this: def prime_factors(n): \"\"\"Return list of prime factors of n or None if not integer >>> prime_factors(\"apple\") None It must return a list type object >>> out = prime_factors(315) >>> isinstance(out, list) True It must return the right list >>> prime_factors(315) [3, 5, 7] \"\"\" Please do take a moment to explore the doctest library. We have two options to run the test. First we can include this driver at the bottom of our module. if __name__ == \"__main__\": import doctest doctest.testmod() and then run the program from our terminal: (env) $ python prime_factors.py or we can leave the driver off and call the doctest module from the terminal (this won't work if there are many imports): (env) $ python -m doctest -v prime_factors.py I generally prefer to use the second route so that I don't have extra cruft in my program. That being said, I generally use unittest instead of doctest, so I don't spend a lot of time with this library. It is a good one, though. This time, go ahead and try this out. Unittest Another tool we use in TDD is testing suites. unittest is one such testing suite, and it includes various tools that help us write automated tests for our projects. Other options for automated testing that are very popular are pytest and nose. We will be using unittest in this class, but I do encourage you to explore some of the other options. I'll write up the same set of tests using unittest now. Please note that I will have two different files, one for my code, and one for my tests: prime_factors_tests.py import unittest import prime_factors as target #1 class TestPrimeFactors(unittest.TestCase): #2 def test_bad_input(self): #3 self.assertIsNone(target.prime_factors(\"apple\")) def test_returns_list(self): l = target.prime_factors(315) self.assertIsInstance(l, list) def test_returns_correct_list(self): l = target.prime_factors(315) self.assertEqual([3, 5, 7], l) Here are a few things to pay attention to: 1. We're importing our code to be tested, so we need to make sure it is in a file called prime_factors and is in the same directory as our test suite. 2. We create a new object to run the collection of tests. The rule is that our test class name must begin with the word Test and it must extend the unittest.TestCase class. We'll talk about inheritance next week with Objects. 3. Each test function should test one discrete case that could occur when the code runs (if we're doing unittests). See the bulleted list above. Also, notice that all of the test functions begin with the word \"test\" followed by some description of what the test is looking for in snake case. If you're following along, you should have two files in your directory. One with the tests and one that is empty for our code. If so, let's try to run our tests: $ python -m unittest prime_factors_tests.py EEE ====================================================================== ERROR: test_bad_input (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 8, in test_bad_input self.assertIsNone(target.prime_factors(\"apple\")) AttributeError: module 'prime_factors' has no attribute 'prime_factors' ====================================================================== ERROR: test_returns_correct_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 15, in test_returns_correct_list l = target.prime_factors(315) AttributeError: module 'prime_factors' has no attribute 'prime_factors' ====================================================================== ERROR: test_returns_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 11, in test_returns_list l = target.prime_factors(315) AttributeError: module 'prime_factors' has no attribute 'prime_factors' ---------------------------------------------------------------------- Ran 3 tests in 0.000s FAILED (errors=3) You'll notice that the tests failed, but they failed because of errors. This is because our file for the code is empty. We can remedy this by beginning to code: prime_factors.py def prime_factors(n): pass Notice that I'm working very incrementally and slowly. So I am expecting now all my tests will fail instead of throw errors. Here we go: $ python -m unittest prime_factors_tests.py .FF ====================================================================== FAIL: test_returns_correct_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 15, in test_returns_correct_list self.assertEqual([3, 5, 7], l) AssertionError: [3, 5, 7] != None ====================================================================== FAIL: test_returns_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 11, in test_returns_list self.assertIsInstance(l, list) AssertionError: None is not an instance of <class 'list'> ---------------------------------------------------------------------- Ran 3 tests in 0.000s FAILED (failures=2) We have to failures. You'll notice the first test is not failing. This is because our function currently is not returning anything, and no return is the same as None. So the test passes. I'm going to alter the code slightly just to get to the point where everything is failing. prime_factors.py def prime_factors(n): return -1 So we try one more time and we get three failures as expected: $ python -m unittest prime_factors_tests.py FFF ====================================================================== FAIL: test_bad_input (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 7, in test_bad_input self.assertIsNone(target.prime_factors(\"apple\")) AssertionError: -1 is not None ====================================================================== FAIL: test_returns_correct_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 15, in test_returns_correct_list self.assertEqual([3, 5, 7], l) AssertionError: [3, 5, 7] != -1 ====================================================================== FAIL: test_returns_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 11, in test_returns_list self.assertIsInstance(l, list) AssertionError: -1 is not an instance of <class 'list'> ---------------------------------------------------------------------- Ran 3 tests in 0.000s FAILED (failures=3) Failed tests are a good thing. First, we know that once all of my tests pass, if I did a good job designing them, then the code will be working properly and will be less likely to have bugs. Second, I can see that these are all failing exactly as I am expecting to, so the tests are working. I just need to write my code so it satisfies the tests. My first test is checking to make sure that the function returns none if the input is not an integer. So let's get that one ot pass: prime_factors.py def prime_factors(n): if isinstance(n, int): return -1 return None This change means that the only case in which the function will not return None is if n is an integer. Let's run our tests and see: $ python -m unittest prime_factors_tests.py .FF ====================================================================== FAIL: test_returns_correct_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 15, in test_returns_correct_list self.assertEqual([3, 5, 7], l) AssertionError: [3, 5, 7] != -1 ====================================================================== FAIL: test_returns_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 11, in test_returns_list self.assertIsInstance(l, list) AssertionError: -1 is not an instance of <class 'list'> ---------------------------------------------------------------------- Ran 3 tests in 0.000s FAILED (failures=2) You'll notice that our tests still fail, but the first test passed. That's great and means progress! Now we just need to get our other tests to pass. We could have the function return an empty list to get the second test to pass, but I'm just going to finish off the code and get both tests passing at the same time. There might be some debate as to whether we should test both that the function returns a list and returns the correct list. We could say if we're testing for the correct list, we don't need to also test that the function returns a list. prime_factors.py import math def prime_factors(n): if isinstance(n, int): out = [] if n % 2 == 0: out.append(2) while n % 2 == 0: n = n / 2 for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: out.append(i) while n % i == 0: n = n / i if n > 2: out.append(n) return out return None Success! We're done! $ python -m unittest prime_factors_tests.py ... ---------------------------------------------------------------------- Ran 3 tests in 0.000s OK In the next chapter we'll be discussing different types of tests (End to End, Functional, and Unit Tests).","title":"One"},{"location":"ch1/#introduction-to-tdd","text":"There are many different approaches to developing software. One of the major ones that is used, especially in enterprise scale projects, is Test-Driven Development (TDD). TDD means that before we write any code we write a test that will determine if our code is functioning the way we want it to. For instance, let's say I want to build a function that returns a list of prime factors of an integer passed into the function. Let's also say, I want that function to return None if the value passed to the function is not an integer. If we are not using a TDD approach we might start by writing our function directly. However, we'll spend a lot of time debugging and running into issues if we do so. Instead, let's think about the things that we need to test: The easiest case is when the input is incorrect. We can set up a test that will call the function with a value that is not an integer and test that we receive None as the return. We need to test that the function returns a list when it is passed an integer. We need to test that the list contains the prime factors of the input integer. A simple and dirty way to test this is to write a driver that tests all of the functionality above. It might look something like this: if __name__ == \"__main__\": out1 = prime_factors(\"apple\") if out1 is None: print(\"Out is None. Pass\") else: print(\"Does not return None. Fail\") out2 = prime_factors(315) if isinstance(out2, list): print(\"Returns a list. Pass\") if out2 == [3, 5, 7]: print(\"Out is 3, 5, 7. Pass\") else: print(\"Does not return the right list. Fail\") else: print(\"Does not return a list. Fail) From there, I'd write out my function and make sure it's called prime_factors(). If you'd like, you can try using this method, and see if you can get it working. For a small, toy task like this, you might be able to sufficiently test your program with a driver, but you end up with a messy driver at the bottom of your program that you'll want to delete later on, and it's an awful lot of lines.","title":"Introduction to TDD"},{"location":"ch1/#doctest","text":"Fortunately, Python includes a number of test tools that can help us do TDD more easily and make our tests more effective. The first of which is doctest , and it comes built-in with Python. Doctest allows you to write your tests into the docstring of your function. If you recall, a docstring is the bit of documentation this is included in triple double quotes when you define a function. The same tests as above would look like this: def prime_factors(n): \"\"\"Return list of prime factors of n or None if not integer >>> prime_factors(\"apple\") None It must return a list type object >>> out = prime_factors(315) >>> isinstance(out, list) True It must return the right list >>> prime_factors(315) [3, 5, 7] \"\"\" Please do take a moment to explore the doctest library. We have two options to run the test. First we can include this driver at the bottom of our module. if __name__ == \"__main__\": import doctest doctest.testmod() and then run the program from our terminal: (env) $ python prime_factors.py or we can leave the driver off and call the doctest module from the terminal (this won't work if there are many imports): (env) $ python -m doctest -v prime_factors.py I generally prefer to use the second route so that I don't have extra cruft in my program. That being said, I generally use unittest instead of doctest, so I don't spend a lot of time with this library. It is a good one, though. This time, go ahead and try this out.","title":"Doctest"},{"location":"ch1/#unittest","text":"Another tool we use in TDD is testing suites. unittest is one such testing suite, and it includes various tools that help us write automated tests for our projects. Other options for automated testing that are very popular are pytest and nose. We will be using unittest in this class, but I do encourage you to explore some of the other options. I'll write up the same set of tests using unittest now. Please note that I will have two different files, one for my code, and one for my tests: prime_factors_tests.py import unittest import prime_factors as target #1 class TestPrimeFactors(unittest.TestCase): #2 def test_bad_input(self): #3 self.assertIsNone(target.prime_factors(\"apple\")) def test_returns_list(self): l = target.prime_factors(315) self.assertIsInstance(l, list) def test_returns_correct_list(self): l = target.prime_factors(315) self.assertEqual([3, 5, 7], l) Here are a few things to pay attention to: 1. We're importing our code to be tested, so we need to make sure it is in a file called prime_factors and is in the same directory as our test suite. 2. We create a new object to run the collection of tests. The rule is that our test class name must begin with the word Test and it must extend the unittest.TestCase class. We'll talk about inheritance next week with Objects. 3. Each test function should test one discrete case that could occur when the code runs (if we're doing unittests). See the bulleted list above. Also, notice that all of the test functions begin with the word \"test\" followed by some description of what the test is looking for in snake case. If you're following along, you should have two files in your directory. One with the tests and one that is empty for our code. If so, let's try to run our tests: $ python -m unittest prime_factors_tests.py EEE ====================================================================== ERROR: test_bad_input (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 8, in test_bad_input self.assertIsNone(target.prime_factors(\"apple\")) AttributeError: module 'prime_factors' has no attribute 'prime_factors' ====================================================================== ERROR: test_returns_correct_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 15, in test_returns_correct_list l = target.prime_factors(315) AttributeError: module 'prime_factors' has no attribute 'prime_factors' ====================================================================== ERROR: test_returns_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 11, in test_returns_list l = target.prime_factors(315) AttributeError: module 'prime_factors' has no attribute 'prime_factors' ---------------------------------------------------------------------- Ran 3 tests in 0.000s FAILED (errors=3) You'll notice that the tests failed, but they failed because of errors. This is because our file for the code is empty. We can remedy this by beginning to code: prime_factors.py def prime_factors(n): pass Notice that I'm working very incrementally and slowly. So I am expecting now all my tests will fail instead of throw errors. Here we go: $ python -m unittest prime_factors_tests.py .FF ====================================================================== FAIL: test_returns_correct_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 15, in test_returns_correct_list self.assertEqual([3, 5, 7], l) AssertionError: [3, 5, 7] != None ====================================================================== FAIL: test_returns_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 11, in test_returns_list self.assertIsInstance(l, list) AssertionError: None is not an instance of <class 'list'> ---------------------------------------------------------------------- Ran 3 tests in 0.000s FAILED (failures=2) We have to failures. You'll notice the first test is not failing. This is because our function currently is not returning anything, and no return is the same as None. So the test passes. I'm going to alter the code slightly just to get to the point where everything is failing. prime_factors.py def prime_factors(n): return -1 So we try one more time and we get three failures as expected: $ python -m unittest prime_factors_tests.py FFF ====================================================================== FAIL: test_bad_input (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 7, in test_bad_input self.assertIsNone(target.prime_factors(\"apple\")) AssertionError: -1 is not None ====================================================================== FAIL: test_returns_correct_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 15, in test_returns_correct_list self.assertEqual([3, 5, 7], l) AssertionError: [3, 5, 7] != -1 ====================================================================== FAIL: test_returns_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 11, in test_returns_list self.assertIsInstance(l, list) AssertionError: -1 is not an instance of <class 'list'> ---------------------------------------------------------------------- Ran 3 tests in 0.000s FAILED (failures=3) Failed tests are a good thing. First, we know that once all of my tests pass, if I did a good job designing them, then the code will be working properly and will be less likely to have bugs. Second, I can see that these are all failing exactly as I am expecting to, so the tests are working. I just need to write my code so it satisfies the tests. My first test is checking to make sure that the function returns none if the input is not an integer. So let's get that one ot pass: prime_factors.py def prime_factors(n): if isinstance(n, int): return -1 return None This change means that the only case in which the function will not return None is if n is an integer. Let's run our tests and see: $ python -m unittest prime_factors_tests.py .FF ====================================================================== FAIL: test_returns_correct_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 15, in test_returns_correct_list self.assertEqual([3, 5, 7], l) AssertionError: [3, 5, 7] != -1 ====================================================================== FAIL: test_returns_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 11, in test_returns_list self.assertIsInstance(l, list) AssertionError: -1 is not an instance of <class 'list'> ---------------------------------------------------------------------- Ran 3 tests in 0.000s FAILED (failures=2) You'll notice that our tests still fail, but the first test passed. That's great and means progress! Now we just need to get our other tests to pass. We could have the function return an empty list to get the second test to pass, but I'm just going to finish off the code and get both tests passing at the same time. There might be some debate as to whether we should test both that the function returns a list and returns the correct list. We could say if we're testing for the correct list, we don't need to also test that the function returns a list. prime_factors.py import math def prime_factors(n): if isinstance(n, int): out = [] if n % 2 == 0: out.append(2) while n % 2 == 0: n = n / 2 for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: out.append(i) while n % i == 0: n = n / i if n > 2: out.append(n) return out return None Success! We're done! $ python -m unittest prime_factors_tests.py ... ---------------------------------------------------------------------- Ran 3 tests in 0.000s OK In the next chapter we'll be discussing different types of tests (End to End, Functional, and Unit Tests).","title":"Unittest"},{"location":"ch2/","text":"Types of Tests In the first chapter we looked at an example of how to use a few different tools to test our programs. We saw how we might write a set of tests first before we write any code, and then write our code so that it passes the unit tests. We do this for a few reasons. Tests force us to think of testable actions our code might perform. This means we need to figure out what specific action or output our code should have before we write it. That's a good practice. Tests force us to consider what conditions should be passing and what conditions should be failing for our code. Tests will tell us immediately when we have written enough code. Tests can help us constrain how many features our code base has. We can only build what we've written tests for. Tests yield less buggy code and cut down on debugging time. We know our code works when it passes the tests. Now does this all mean that TDD will give us perfect code? No, it's intirely possible to write code that is full of bugs that still passes our tests and functions. There are four main categories of tests: unit tests, functional tests, and end-to-end tests. An important concept to understand before we dive into these approaches is white box and black box testing. White box testing is concerned with the inner workings of your application. This means that it tests how your functions are doing the work that they are supposed to do. White box testing cares about the code itself. Black box testing, on the other hand, is concerned with whether your application works or not. This is an important distinction, and you might think of it in these terms. Developers are concerned with white box testing because it ensures that their code has minimal bugs and achieves the correct results the way it's supposed to. Business managers are concerned with black box testing because it ensures that the code is meeting the product requirements. Unit Testing Unit testing is white box testing and involves testing individual units or individual processes in your code free from their dependencies. A good way to think about this is that unit testing should test individual funtions--even if that function is never called independently by the user. In the last chapter, I walked through the process of writing tests for a particular function, but let's look at another example. Let's say we are working on a project to build word cloud visualizations. These word clouds display the words in a text in a cloud pattern sized by frequency of each word. If we decided not to use the builtin count function in Python, we could go about building our own. This means I need a function that will take a given text, iterate through the words and count the frequency of each word. I also don't want to use the count function (for this example at least). I also want the function to be able to adjust for case sensitivity or not. Here are pre and post conditions that should be present if this function works correctly: The function should take a string as an input. It may or may not take a case as a second input, but that second input must be a boolean. The function should return some code if the input is wrong. The function should return a dictionary with words as keys and their count as values for each word in the text passage. This means I'll have seven tests that will, when passing, show me that under the right circumstances, my function is working, and if the wrong input is given to my function, it returns the right error code. Let's write some tests together again. I'll go wordcloud_tests.py import unittest import wordcloud as t class TestWordCloud(unittest.TestCase): def setUp(self): self.text = \"Peter peter of Pickeled Pepper pepper Pepper\" self.sensitive = { 'Peter': 1, 'peter': 1, 'of': 1, 'Pickeled': 1, 'Pepper': 2, 'pepper': 2 } self.insensitive = { 'peter': 2, 'of': 1, 'pickeled': 1, 'pepper': 4 } def test_returns_error_code_on_bad_text(self): self.assertEqual(t.word_count(1), -1) def test_returns_error_code_on_bad_case(self): self.assertEqual(t.word_count('Pass', 11), -1) def test_case_sensitive(self): self.assertEqual(t.word_count(self.text, True), self.sensitive) def test_case_insensitve(self): self.assertEqual(t.word_count(self.text), self.insensitive) There are two options when writing tests and writing production code. You can either write a test, then write code to pass the test, then write another test and get that one to pass, or you can write a set of tests for one particular function and then write code to get them all to pass. In this case, I wrote all of my tests first, and it gives me a sort of todo list. I know I have to write code to get all of these tests to pass, and I should only write that much code. First I'll write the code that gets the first two tests passing. wordcloud.py def word_count(text, case): return -1 The first two tests will pass, but the second two tests will fail once I've written this code. Notice that I don't have any logic in this function, but simply a return statement that will pass the test. I like this approach because it is very little code to write, and still it satisfies the test cases. Next I want to write the code to get the case sensitive version to work. wordcloud.py def word_count(text, case): if isinstance(text, str) and isinstance(case, bool): counts = {} for word in text.split(): if word in counts.keys(): counts[word] += 1 else: counts[word] = 1 return counts return -1 Once again, you can try this out, but all of the tests except for the last one should be passing now. We're making progress, but now I need to think about how I want to implement the case where we don't want to be case sensitive. An easy way to do this is simply set all the words to lower case and then use the same logic as above. def word_count(text, case): if isinstance(text, str) and isinstance(case, bool): counts = {} if not case: text = text.lower() for word in text.split(): if word in counts.keys(): counts[word] += 1 else: counts[word] = 1 return counts return -1 Now all of my tests are passing, but there's one more feature I want to add. Since word clouds often are used to show the importance of meaningful words, I want to not count words that contain digits or are just string representations of numbers. So if my text included \"dinn3r\" or \"2\", those strings should be ignored. I might be tempted to implement this directly, but I need to write tests first, and I'll just add them to the test code I already have (notice I changed the text to be checked): wordcloud_tests.py import unittest import wordcloud as t class TestWordCloud(unittest.TestCase): def setUp(self): self.text = \"Peter peter of Pickeled \\ Pepper pepper Pepper 123 p3pper\" self.sensitive = { 'Peter': 1, 'peter': 1, 'of': 1, 'Pickeled': 1, 'Pepper': 2, 'pepper': 2 } self.insensitive = { 'peter': 2, 'of': 1, 'pickeled': 1, 'pepper': 4 } def test_returns_error_code_on_bad_text(self): self.assertEqual(t.word_count(1), -1) def test_returns_error_code_on_bad_case(self): self.assertEqual(t.word_count('Pass', 11), -1) def test_case_sensitive(self): self.assertEqual(t.word_count(self.text, True), self.sensitive) def test_case_insensitve(self): self.assertEqual(t.word_count(self.text), self.insensitive) def test_ignores_digits(self): self.assertEqual(t.word_count(self.text), self.insensitive) Next, write code to get that test to pass. wordcloud.py def word_count(text, case): if isinstance(text, str) and isinstance(case, bool): counts = {} if not case: text = text.lower() for word in text.split(): # make sure no characters in the word are digits if not any(map(word.isdigit, word)): if word in counts.keys(): counts[word] += 1 else: counts[word] = 1 return counts return -1 All of my tests are passing now, so basically I know that my code is working as expected. I haven't done anything to ensure that the user uses the code correctly, but at this point that's okay. There's just one more small change I would like to make and add some documentation. I want to make case a kwarg instead of an arg. I want to do this so I can set a default setting. I want the function to not be case sensitive unless it is asked to be sensitive. Kwargs are cool because you can set a default value for an argument, and that makes it so that we don't need to pass True or False to the function in some of the cases. Only when we want to be case sensitive. I made a small refactor as below with documentation added. wordcloud.py def word_count(text, case=False): \"\"\" This function calculates word frequency in a text. This function should not count digit strings. Args: text (str): the text to be searched. Kwargs: case (bool): Should the search be case sensive Returns: dict. counts keyed by word, or return code:: -1 -- Error \"\"\" if isinstance(text, str) and isinstance(case, bool): counts = {} for word in text.split(): if not any(map(word.isdigit, word)): if not case: word = word.lower() if word in counts.keys(): counts[word] += 1 else: counts[word] = 1 return counts return -1 Functional Testing If unit tests test to see if the code is working correctly, functional tests test to see if a particular functionality of a program is working correctly. This means we are not so concerned with the inner workings of our functions, but instead we are concerned with the functions that an application provides a user. We will cover functional tests as we start building our Flask app, but imagine for now our word cloud application. The user enters a text file and the application creates an image object based on the text. For a functional test, I'd create a mockup of an expected image object based on a particular text, and then pass that text to the function and compare the output with the expected like so: functional_tests.py import unittest import wordcloud as t class TestWordCloudFunctional(unittest.TestCase): def setUp(self): self.text = \"My text ...\" self.cloud = '' with open('img.png', 'rb') as f: self.cloud = f.read() def test_can_create_word_cloud(self): self.assertEqual(t.make_cloud(self.text), self.cloud) I'm imagining that we'll have to create a function called make_cloud, which probably will call the word_cound and so on.","title":"Two"},{"location":"ch2/#types-of-tests","text":"In the first chapter we looked at an example of how to use a few different tools to test our programs. We saw how we might write a set of tests first before we write any code, and then write our code so that it passes the unit tests. We do this for a few reasons. Tests force us to think of testable actions our code might perform. This means we need to figure out what specific action or output our code should have before we write it. That's a good practice. Tests force us to consider what conditions should be passing and what conditions should be failing for our code. Tests will tell us immediately when we have written enough code. Tests can help us constrain how many features our code base has. We can only build what we've written tests for. Tests yield less buggy code and cut down on debugging time. We know our code works when it passes the tests. Now does this all mean that TDD will give us perfect code? No, it's intirely possible to write code that is full of bugs that still passes our tests and functions. There are four main categories of tests: unit tests, functional tests, and end-to-end tests. An important concept to understand before we dive into these approaches is white box and black box testing. White box testing is concerned with the inner workings of your application. This means that it tests how your functions are doing the work that they are supposed to do. White box testing cares about the code itself. Black box testing, on the other hand, is concerned with whether your application works or not. This is an important distinction, and you might think of it in these terms. Developers are concerned with white box testing because it ensures that their code has minimal bugs and achieves the correct results the way it's supposed to. Business managers are concerned with black box testing because it ensures that the code is meeting the product requirements.","title":"Types of Tests"},{"location":"ch2/#unit-testing","text":"Unit testing is white box testing and involves testing individual units or individual processes in your code free from their dependencies. A good way to think about this is that unit testing should test individual funtions--even if that function is never called independently by the user. In the last chapter, I walked through the process of writing tests for a particular function, but let's look at another example. Let's say we are working on a project to build word cloud visualizations. These word clouds display the words in a text in a cloud pattern sized by frequency of each word. If we decided not to use the builtin count function in Python, we could go about building our own. This means I need a function that will take a given text, iterate through the words and count the frequency of each word. I also don't want to use the count function (for this example at least). I also want the function to be able to adjust for case sensitivity or not. Here are pre and post conditions that should be present if this function works correctly: The function should take a string as an input. It may or may not take a case as a second input, but that second input must be a boolean. The function should return some code if the input is wrong. The function should return a dictionary with words as keys and their count as values for each word in the text passage. This means I'll have seven tests that will, when passing, show me that under the right circumstances, my function is working, and if the wrong input is given to my function, it returns the right error code. Let's write some tests together again. I'll go wordcloud_tests.py import unittest import wordcloud as t class TestWordCloud(unittest.TestCase): def setUp(self): self.text = \"Peter peter of Pickeled Pepper pepper Pepper\" self.sensitive = { 'Peter': 1, 'peter': 1, 'of': 1, 'Pickeled': 1, 'Pepper': 2, 'pepper': 2 } self.insensitive = { 'peter': 2, 'of': 1, 'pickeled': 1, 'pepper': 4 } def test_returns_error_code_on_bad_text(self): self.assertEqual(t.word_count(1), -1) def test_returns_error_code_on_bad_case(self): self.assertEqual(t.word_count('Pass', 11), -1) def test_case_sensitive(self): self.assertEqual(t.word_count(self.text, True), self.sensitive) def test_case_insensitve(self): self.assertEqual(t.word_count(self.text), self.insensitive) There are two options when writing tests and writing production code. You can either write a test, then write code to pass the test, then write another test and get that one to pass, or you can write a set of tests for one particular function and then write code to get them all to pass. In this case, I wrote all of my tests first, and it gives me a sort of todo list. I know I have to write code to get all of these tests to pass, and I should only write that much code. First I'll write the code that gets the first two tests passing. wordcloud.py def word_count(text, case): return -1 The first two tests will pass, but the second two tests will fail once I've written this code. Notice that I don't have any logic in this function, but simply a return statement that will pass the test. I like this approach because it is very little code to write, and still it satisfies the test cases. Next I want to write the code to get the case sensitive version to work. wordcloud.py def word_count(text, case): if isinstance(text, str) and isinstance(case, bool): counts = {} for word in text.split(): if word in counts.keys(): counts[word] += 1 else: counts[word] = 1 return counts return -1 Once again, you can try this out, but all of the tests except for the last one should be passing now. We're making progress, but now I need to think about how I want to implement the case where we don't want to be case sensitive. An easy way to do this is simply set all the words to lower case and then use the same logic as above. def word_count(text, case): if isinstance(text, str) and isinstance(case, bool): counts = {} if not case: text = text.lower() for word in text.split(): if word in counts.keys(): counts[word] += 1 else: counts[word] = 1 return counts return -1 Now all of my tests are passing, but there's one more feature I want to add. Since word clouds often are used to show the importance of meaningful words, I want to not count words that contain digits or are just string representations of numbers. So if my text included \"dinn3r\" or \"2\", those strings should be ignored. I might be tempted to implement this directly, but I need to write tests first, and I'll just add them to the test code I already have (notice I changed the text to be checked): wordcloud_tests.py import unittest import wordcloud as t class TestWordCloud(unittest.TestCase): def setUp(self): self.text = \"Peter peter of Pickeled \\ Pepper pepper Pepper 123 p3pper\" self.sensitive = { 'Peter': 1, 'peter': 1, 'of': 1, 'Pickeled': 1, 'Pepper': 2, 'pepper': 2 } self.insensitive = { 'peter': 2, 'of': 1, 'pickeled': 1, 'pepper': 4 } def test_returns_error_code_on_bad_text(self): self.assertEqual(t.word_count(1), -1) def test_returns_error_code_on_bad_case(self): self.assertEqual(t.word_count('Pass', 11), -1) def test_case_sensitive(self): self.assertEqual(t.word_count(self.text, True), self.sensitive) def test_case_insensitve(self): self.assertEqual(t.word_count(self.text), self.insensitive) def test_ignores_digits(self): self.assertEqual(t.word_count(self.text), self.insensitive) Next, write code to get that test to pass. wordcloud.py def word_count(text, case): if isinstance(text, str) and isinstance(case, bool): counts = {} if not case: text = text.lower() for word in text.split(): # make sure no characters in the word are digits if not any(map(word.isdigit, word)): if word in counts.keys(): counts[word] += 1 else: counts[word] = 1 return counts return -1 All of my tests are passing now, so basically I know that my code is working as expected. I haven't done anything to ensure that the user uses the code correctly, but at this point that's okay. There's just one more small change I would like to make and add some documentation. I want to make case a kwarg instead of an arg. I want to do this so I can set a default setting. I want the function to not be case sensitive unless it is asked to be sensitive. Kwargs are cool because you can set a default value for an argument, and that makes it so that we don't need to pass True or False to the function in some of the cases. Only when we want to be case sensitive. I made a small refactor as below with documentation added. wordcloud.py def word_count(text, case=False): \"\"\" This function calculates word frequency in a text. This function should not count digit strings. Args: text (str): the text to be searched. Kwargs: case (bool): Should the search be case sensive Returns: dict. counts keyed by word, or return code:: -1 -- Error \"\"\" if isinstance(text, str) and isinstance(case, bool): counts = {} for word in text.split(): if not any(map(word.isdigit, word)): if not case: word = word.lower() if word in counts.keys(): counts[word] += 1 else: counts[word] = 1 return counts return -1","title":"Unit Testing"},{"location":"ch2/#functional-testing","text":"If unit tests test to see if the code is working correctly, functional tests test to see if a particular functionality of a program is working correctly. This means we are not so concerned with the inner workings of our functions, but instead we are concerned with the functions that an application provides a user. We will cover functional tests as we start building our Flask app, but imagine for now our word cloud application. The user enters a text file and the application creates an image object based on the text. For a functional test, I'd create a mockup of an expected image object based on a particular text, and then pass that text to the function and compare the output with the expected like so: functional_tests.py import unittest import wordcloud as t class TestWordCloudFunctional(unittest.TestCase): def setUp(self): self.text = \"My text ...\" self.cloud = '' with open('img.png', 'rb') as f: self.cloud = f.read() def test_can_create_word_cloud(self): self.assertEqual(t.make_cloud(self.text), self.cloud) I'm imagining that we'll have to create a function called make_cloud, which probably will call the word_cound and so on.","title":"Functional Testing"},{"location":"ch3/","text":"Getting Flask Set Up and Your First Functional Test The first functional test checks three things: Is the selenium library installed and can we import webdriver Is there a server serving listening and responding at localhost on port 5000 This is different from the Django. Is that server responding with the page_source attribute set to \"Flask\" Here is the code: from selenium import webdriver browser = webdriver.Firefox() browser.get('http://localhost:5000') assert 'Flask' in browser.page_source functional_tests.py As I follow along with this, I get this error: $ python functional_tests.py Traceback (most recent call last): File \"functional_tests.py\", line 1, in <module> from selenium import webdriver ModuleNotFoundError: No module named 'selenium' Notice that the test failed, but not in the way we expected. Should I have written a separate test that selenium was installed? I could have, but since Python throws an import error anyway, it's not that big of a problem to not have a separate test for it. If you're getting this error as well, then the following should fix things up: (env) $ pip install selenium After Selenium is installed, then you should get the expected error message. We should expect a connection error because we haven't set up Flask yet, so there's no server listening. Getting Flask Up and Running I know I haven't installed Flask in this virtual environment, yet, so I know I'll need to do that first. Django has a CLI to help you build your core site, but since Flask is a lightweight Framework with few moving parts, we don't get that. At the same time, we have far fewer files to deal with and far fewer moving parts, so it's a toss up. Flask is a great tool for smaller projects. Step One: Install Flask Installing Flask is pretty easy. Using pip package manager we just need to install Flask. Make sure that your virtual environment is activated (env) $ pip install Flask At this point, it would also be valuable to create a requirements.txt file. This file allows you to easily set up your app on a different machine without having to move all of the dependencies. You will be using the \"freeze\" command that is build into pip. This command echos the list of dependencies that have been installed in this virtual environment using pip install. Try it out in the terminal and you'll see something like this: (env) $ pip freeze Click==7.0 Flask==1.1.1 itsdangerous==1.1.0 Jinja2==2.11.1 MarkupSafe==1.1.1 selenium==3.141.0 urllib3==1.25.8 Werkzeug==1.0.0 When I installed Flask, I also installed its dependencies (Click, itsdangerous, Jinja2, urllib3, werkzeug). You don't need to do this every time, this was just to show you how pip freeze works. Now you'll need to somehow write the output of pip freeze into a text file called requirements.txt You could copy and past from the terminal, but that's too much work. Instead, you can use the > or >> symbol to write the output of a command directly to a file like so: (env) $ pip freeze > requirements.txt If I use the > symbol, it will either create or overwrite the file to the right of the symbol. NOTICE: if you overwrite data will be lost This is the correct choice in this case because each time we update our requirements.txt file, we want to overwrite it. If we were appending to a file for some other reason, then we would use >> which either creates or appends to the file to the right of the symbol. Step Two: Set Up Your Directory Understanding where your files live is crucial in programming. If the files are not in the right place or if your directory is misshapen, you'll have lots of problems. Django's CLI tool does much of this for you. In Flask, we're on our own. Right now your folder structure within your flask directory should look like this: |--functional_tests.py |--geckodriver.log |--requirements.txt |--env (Virtual Environment Directory) | |--[...] We need to create a directory and three files. We need to create a directory called \"app\" and a file called superlists.py that are both siblings of functional_tests.py. This means they are direct children of our flask directory. We also need to create two files called __init__.py and routes.py that is a child of the \"app\" directory. Here are the commands in the terminal. (env) $ mkdir app && touch superlists.py app/__init__.py app/routes.py You can also enter them as three separate commands if you wish. If this was successful, your flask directory should look like this: |--functional_tests.py |--geckodriver.log |--requirements.txt |--superlists.py |--app | |--__init__.py | |--routes.py |--env (Virtual Environment Directory) | |--[...] If your directory doesn't look exactly like this then go back and check for mistakes before you move on. Now that those files are all created, you can start coding so that the tests will pass. You will be editing superlists.py, __init__.py and routes.py. The first is the script that launches the Flask application. from app import app superlists.py The second is the core of the app (for now). from flask import Flask app = Flask(__name__) from app import routes __init__.py The third is a file that manages the routes. from app import app @app.route('/') @app.route('/index') def index(): return \"Hello, Flask!\" We'll be discussing all of these later on in great detail. Once you've created all of these files, you'll need to start your Flask app so that you can run your tests again. This will require you to have 2 terminals open. In the first terminal, start the Flask app: (env) $ flask run and in the second terminal (make sure you've navigated to your project directory and activated your virtual environment): (env) $ python functional_tests.py At this point, the functional tests will open a new browser and call the Flask app. As soon as that loads, you can close the browser. In your terminal, you should get no error messages. If that's the case, you've successfully completed this. If not, you'll need to go through and revise your code until it works. Make sure to read any error messages for a clue as to what to fix. Now, you'll want to initialize your flask project directory as a git repository. Create a gitignore file that contains at least the following: # Byte-compiled / optimized / DLL files __pycache__/ # Unit test / coverage reports .pytest_cache/ # Flask stuff: db.sqlite3 db.sqlite3-journal instance/ .webassets-cache # Environments env/ # Visual Studio Code .vscode/ .gitignore Then create a new github repository and push your local repository to github. You're done with getting started!","title":"Three"},{"location":"ch3/#getting-flask-set-up-and-your-first-functional-test","text":"The first functional test checks three things: Is the selenium library installed and can we import webdriver Is there a server serving listening and responding at localhost on port 5000 This is different from the Django. Is that server responding with the page_source attribute set to \"Flask\" Here is the code: from selenium import webdriver browser = webdriver.Firefox() browser.get('http://localhost:5000') assert 'Flask' in browser.page_source functional_tests.py As I follow along with this, I get this error: $ python functional_tests.py Traceback (most recent call last): File \"functional_tests.py\", line 1, in <module> from selenium import webdriver ModuleNotFoundError: No module named 'selenium' Notice that the test failed, but not in the way we expected. Should I have written a separate test that selenium was installed? I could have, but since Python throws an import error anyway, it's not that big of a problem to not have a separate test for it. If you're getting this error as well, then the following should fix things up: (env) $ pip install selenium After Selenium is installed, then you should get the expected error message. We should expect a connection error because we haven't set up Flask yet, so there's no server listening.","title":"Getting Flask Set Up and Your First Functional Test"},{"location":"ch3/#getting-flask-up-and-running","text":"I know I haven't installed Flask in this virtual environment, yet, so I know I'll need to do that first. Django has a CLI to help you build your core site, but since Flask is a lightweight Framework with few moving parts, we don't get that. At the same time, we have far fewer files to deal with and far fewer moving parts, so it's a toss up. Flask is a great tool for smaller projects.","title":"Getting Flask Up and Running"},{"location":"ch3/#step-one-install-flask","text":"Installing Flask is pretty easy. Using pip package manager we just need to install Flask. Make sure that your virtual environment is activated (env) $ pip install Flask At this point, it would also be valuable to create a requirements.txt file. This file allows you to easily set up your app on a different machine without having to move all of the dependencies. You will be using the \"freeze\" command that is build into pip. This command echos the list of dependencies that have been installed in this virtual environment using pip install. Try it out in the terminal and you'll see something like this: (env) $ pip freeze Click==7.0 Flask==1.1.1 itsdangerous==1.1.0 Jinja2==2.11.1 MarkupSafe==1.1.1 selenium==3.141.0 urllib3==1.25.8 Werkzeug==1.0.0 When I installed Flask, I also installed its dependencies (Click, itsdangerous, Jinja2, urllib3, werkzeug). You don't need to do this every time, this was just to show you how pip freeze works. Now you'll need to somehow write the output of pip freeze into a text file called requirements.txt You could copy and past from the terminal, but that's too much work. Instead, you can use the > or >> symbol to write the output of a command directly to a file like so: (env) $ pip freeze > requirements.txt If I use the > symbol, it will either create or overwrite the file to the right of the symbol. NOTICE: if you overwrite data will be lost This is the correct choice in this case because each time we update our requirements.txt file, we want to overwrite it. If we were appending to a file for some other reason, then we would use >> which either creates or appends to the file to the right of the symbol.","title":"Step One: Install Flask"},{"location":"ch3/#step-two-set-up-your-directory","text":"Understanding where your files live is crucial in programming. If the files are not in the right place or if your directory is misshapen, you'll have lots of problems. Django's CLI tool does much of this for you. In Flask, we're on our own. Right now your folder structure within your flask directory should look like this: |--functional_tests.py |--geckodriver.log |--requirements.txt |--env (Virtual Environment Directory) | |--[...] We need to create a directory and three files. We need to create a directory called \"app\" and a file called superlists.py that are both siblings of functional_tests.py. This means they are direct children of our flask directory. We also need to create two files called __init__.py and routes.py that is a child of the \"app\" directory. Here are the commands in the terminal. (env) $ mkdir app && touch superlists.py app/__init__.py app/routes.py You can also enter them as three separate commands if you wish. If this was successful, your flask directory should look like this: |--functional_tests.py |--geckodriver.log |--requirements.txt |--superlists.py |--app | |--__init__.py | |--routes.py |--env (Virtual Environment Directory) | |--[...] If your directory doesn't look exactly like this then go back and check for mistakes before you move on. Now that those files are all created, you can start coding so that the tests will pass. You will be editing superlists.py, __init__.py and routes.py. The first is the script that launches the Flask application. from app import app superlists.py The second is the core of the app (for now). from flask import Flask app = Flask(__name__) from app import routes __init__.py The third is a file that manages the routes. from app import app @app.route('/') @app.route('/index') def index(): return \"Hello, Flask!\" We'll be discussing all of these later on in great detail. Once you've created all of these files, you'll need to start your Flask app so that you can run your tests again. This will require you to have 2 terminals open. In the first terminal, start the Flask app: (env) $ flask run and in the second terminal (make sure you've navigated to your project directory and activated your virtual environment): (env) $ python functional_tests.py At this point, the functional tests will open a new browser and call the Flask app. As soon as that loads, you can close the browser. In your terminal, you should get no error messages. If that's the case, you've successfully completed this. If not, you'll need to go through and revise your code until it works. Make sure to read any error messages for a clue as to what to fix. Now, you'll want to initialize your flask project directory as a git repository. Create a gitignore file that contains at least the following: # Byte-compiled / optimized / DLL files __pycache__/ # Unit test / coverage reports .pytest_cache/ # Flask stuff: db.sqlite3 db.sqlite3-journal instance/ .webassets-cache # Environments env/ # Visual Studio Code .vscode/ .gitignore Then create a new github repository and push your local repository to github. You're done with getting started!","title":"Step Two: Set Up Your Directory"},{"location":"ch4/","text":"Introducing the unittest Module A note to begin: One thing to notice before we go much further is that we have a number of tools running at the same time to do our tests. Our Flask server that is launched when we type flask run in our terminal. This web server runs on your local machine, is not visible to the outside world, and listens at the IP address 127.0.0.1 on port 5000. In the URL bar, this will look like 127.0.0.1:5000 . Our Flask app that the Flask server calls when it receives requests. Our functional_test.py script, which opens a web browser to send particular requests to the Flask server, and evaluates the server's responses. I recommend, perhaps, diagramming these for yourself in some fashion if it helps you keep things in order. Unittests Our last iteration of our app was extremely simple. It didn't even use any HTML and didn't properly return a web-page; just the string \"Hello, Flask!\" That's not particularly useful if we're trying to build a little web-app, but it's a start. Now we're moving on to bigger and better things. You'll actually have a proper webpage. Our first step will be to modify our functional test so that it looks for a title property. We'll alo add the story that Percival mentions So let's go to the functional test: from selenium import webdriver browser = webdriver.Firefox() # Edith (our test) has heard about a cool new online to-do app. She goes # to check out its homepage browser.get('http://127.0.0.1:5000') # or http://localhost:5000 # She notices the page title and header mention to-do lists assert 'To-Do' in browser.title # She is invited to enter a to-do item straight away # She types \"Buy peacock feathers\" into a text box (Edith's hobby # is tying fly-fishing lures) # When she hits enter, the page updates, and now the page lists # \"1: Buy peacock feathers\" as an item in a to-do list # There is still a text box inviting her to add another item. She # enters \"Use peacock feathers to make a fly\" (Edith is very methodical) # The page updates again, and now shows both items on her list # Edith wonders whether the site will remember her list. Then she sees # that the site has generated a unique URL for her -- there is some # explanatory text to that effect. # She visits that URL - her to-do list is still there. # Satisfied, she goes back to sleep browser.quit() functional_tests.py Comments There are lot of opinions when it comes to how we add comments to our code. In a traditional CS program, we'd expect students to write extensive comments. This is to help the instructor see what you believe you are doing with a particular line of code or function. Likewise, the practice of writing such comments is useful for you to become conscious of what your code is doing. Comments can also be used as a sort of pseudocode to describe what functions your code will need to accomplish (as in the above example). In professional settings, there is a debate as to how many comments are necessary. On the one hand, some argue that your code should be clearly written enough that you don't need any comments. If your code needs comments to explain what's going on, you probably have a problem with your code. They also argue that if you change your code in the future without changing your comments, the comments can become misleading and more of a hinderance for future developers. On the other hand, some argue that comments provide crucial insight to you and other developers about what the code is supposed to do. They give future developers a sense of what you were thinking when you were writing the code. They are also important if you are writing an API or other code that future developers will extend. Additionally, comments are frequently used to generate documentation. For instance Sphinx and other documentation generation tools can automatically create docs based on the comments. Beyond all of this, if you're working for a company, that company will likely have its own approach to comments, and probably a majority of your first period there will be reading the code and comments that you will later be working on. This is all to say, you'll have to decide how much you want to comment your code based on the project. A general rule of thumb is that if the code doesn't obviously tell you what is happening, it's worth commenting. For example the first comment is probably not needed, but the second is (I also probably wouldn't write that generator just to save a few lines of code anyway): # Increment age by 1 age += 1 n = int(input(\"How many players? \")) # prompt users for name and age for each player age_map = {input(\"Name?\"): int(input(\"Age?\")) for i in range(n)} Back to our Tests If we start up our Flask server: (env) $ flask run and in another shell run our functional tests, you'll get an error like this: (env) $ python functional_tests.py Traceback (most recent call last): File \"functional_tests.py\", line 6, in <module> assert 'To-Do' in browser.title AssertionError We are getting the error that we are expecting! However, we want to move over to the unittest framework to make our test a little bit more robust. After all, we'll be building an entire testing suite for our application: every operation we want should be tested. This will be very similar to the test in Percival's book, but before that, take a moment to consider the unittest library. unittest The unittest library is a framework for writing unit tests. A unit test is an automated test that checks the functionality of one unit of a particular application. For instance, one unit of our webpage is the title that shows up on the browser tab. A unit test will test that that is as it should be. Likewise, it might test a single function of our application. When writing a unit test, we need to provide all of the conditions or dependencies except the one variable that is being tested. So our browser title test needs to just test that the browser title contains particular content. It shouldn't check that the browser starts up or anything that appears on the page or that the URL is correct. A functional test is a test that checks a particular functionality of our application. For instance, a functional test might check that we can input a new item into a list and when we do so the item gets added to the database. Unlike a unit test that might have distinct tests for user input and writing to the database, the functional test tries to see that the components work together properly. Another way to think of this: unit tests check a discrete section of code. Functional tests simulate user experience. So, now lets update our functional_tests.py file. You'll notice that this is a functional test because it tests a component of our application as a user would encounter it. We'll write unittests later. from selenium import webdriver import unittest class NewVisitorTest(unittest.TestCase): def setUp(self): self.browser = webdriver.Firefox() def tearDown(self): self.browser.quit() def test_can_start_a_list_and_retrieve_it_later(self): # Call homepage self.browser.get('http://127.0.0.1:5000') # Old way: # assert 'To-Do' in browser.title # Using unittest methods self.assertIn('To-Do', self.browser.title) self.fail('Finish writing the test!') # She is invited to enter a to-do item straight away # She types \"Buy peacock feathers\" into a text box (Edith's hobby # is tying fly-fishing lures) # When she hits enter, the page updates, and now the page lists # \"1: Buy peacock feathers\" as an item in a to-do list # There is still a text box inviting her to add another item. She # enters \"Use peacock feathers to make a fly\" (Edith is very methodical) # The page updates again, and now shows both items on her list # Edith wonders whether the site will remember her list. Then she sees # that the site has generated a unique URL for her -- there is some # explanatory text to that effect. # She visits that URL - her to-do list is still there. # Satisfied, she goes back to sleep if __name__ in '__main__': unittest.main(warnings='ignore') Once again, we want to test it. If you stopped your Flask server, launch it again. Then let's run our functional tests and see the results: (env) $ python functional_tests.py F ====================================================================== FAIL: test_can_start_a_list_and_retrieve_it_later (__main__.NewVisitorTest) ---------------------------------------------------------------------- Traceback (most recent call last): File \"functional_tests.py\", line 20, in test_can_start_a_list_and_retrieve_it_later self.assertIn('To-Do', self.browser.title) AssertionError: 'To-Do' not found in '' ---------------------------------------------------------------------- Ran 1 test in 37.913s FAILED (failures=1) Woo! Our tests are failing as they should be. Notice, we haven't added anything to our app in this chapter, and that's intentional. We now have a test that will pass once our app is returning a page that has the correct title and that will be our next step. For now, it would be a good moment to commit your project and push it to github.","title":"Four"},{"location":"ch4/#introducing-the-unittest-module","text":"","title":"Introducing the unittest Module"},{"location":"ch4/#a-note-to-begin","text":"One thing to notice before we go much further is that we have a number of tools running at the same time to do our tests. Our Flask server that is launched when we type flask run in our terminal. This web server runs on your local machine, is not visible to the outside world, and listens at the IP address 127.0.0.1 on port 5000. In the URL bar, this will look like 127.0.0.1:5000 . Our Flask app that the Flask server calls when it receives requests. Our functional_test.py script, which opens a web browser to send particular requests to the Flask server, and evaluates the server's responses. I recommend, perhaps, diagramming these for yourself in some fashion if it helps you keep things in order.","title":"A note to begin:"},{"location":"ch4/#unittests","text":"Our last iteration of our app was extremely simple. It didn't even use any HTML and didn't properly return a web-page; just the string \"Hello, Flask!\" That's not particularly useful if we're trying to build a little web-app, but it's a start. Now we're moving on to bigger and better things. You'll actually have a proper webpage. Our first step will be to modify our functional test so that it looks for a title property. We'll alo add the story that Percival mentions So let's go to the functional test: from selenium import webdriver browser = webdriver.Firefox() # Edith (our test) has heard about a cool new online to-do app. She goes # to check out its homepage browser.get('http://127.0.0.1:5000') # or http://localhost:5000 # She notices the page title and header mention to-do lists assert 'To-Do' in browser.title # She is invited to enter a to-do item straight away # She types \"Buy peacock feathers\" into a text box (Edith's hobby # is tying fly-fishing lures) # When she hits enter, the page updates, and now the page lists # \"1: Buy peacock feathers\" as an item in a to-do list # There is still a text box inviting her to add another item. She # enters \"Use peacock feathers to make a fly\" (Edith is very methodical) # The page updates again, and now shows both items on her list # Edith wonders whether the site will remember her list. Then she sees # that the site has generated a unique URL for her -- there is some # explanatory text to that effect. # She visits that URL - her to-do list is still there. # Satisfied, she goes back to sleep browser.quit() functional_tests.py","title":"Unittests"},{"location":"ch4/#comments","text":"There are lot of opinions when it comes to how we add comments to our code. In a traditional CS program, we'd expect students to write extensive comments. This is to help the instructor see what you believe you are doing with a particular line of code or function. Likewise, the practice of writing such comments is useful for you to become conscious of what your code is doing. Comments can also be used as a sort of pseudocode to describe what functions your code will need to accomplish (as in the above example). In professional settings, there is a debate as to how many comments are necessary. On the one hand, some argue that your code should be clearly written enough that you don't need any comments. If your code needs comments to explain what's going on, you probably have a problem with your code. They also argue that if you change your code in the future without changing your comments, the comments can become misleading and more of a hinderance for future developers. On the other hand, some argue that comments provide crucial insight to you and other developers about what the code is supposed to do. They give future developers a sense of what you were thinking when you were writing the code. They are also important if you are writing an API or other code that future developers will extend. Additionally, comments are frequently used to generate documentation. For instance Sphinx and other documentation generation tools can automatically create docs based on the comments. Beyond all of this, if you're working for a company, that company will likely have its own approach to comments, and probably a majority of your first period there will be reading the code and comments that you will later be working on. This is all to say, you'll have to decide how much you want to comment your code based on the project. A general rule of thumb is that if the code doesn't obviously tell you what is happening, it's worth commenting. For example the first comment is probably not needed, but the second is (I also probably wouldn't write that generator just to save a few lines of code anyway): # Increment age by 1 age += 1 n = int(input(\"How many players? \")) # prompt users for name and age for each player age_map = {input(\"Name?\"): int(input(\"Age?\")) for i in range(n)}","title":"Comments"},{"location":"ch4/#back-to-our-tests","text":"If we start up our Flask server: (env) $ flask run and in another shell run our functional tests, you'll get an error like this: (env) $ python functional_tests.py Traceback (most recent call last): File \"functional_tests.py\", line 6, in <module> assert 'To-Do' in browser.title AssertionError We are getting the error that we are expecting! However, we want to move over to the unittest framework to make our test a little bit more robust. After all, we'll be building an entire testing suite for our application: every operation we want should be tested. This will be very similar to the test in Percival's book, but before that, take a moment to consider the unittest library.","title":"Back to our Tests"},{"location":"ch4/#unittest","text":"The unittest library is a framework for writing unit tests. A unit test is an automated test that checks the functionality of one unit of a particular application. For instance, one unit of our webpage is the title that shows up on the browser tab. A unit test will test that that is as it should be. Likewise, it might test a single function of our application. When writing a unit test, we need to provide all of the conditions or dependencies except the one variable that is being tested. So our browser title test needs to just test that the browser title contains particular content. It shouldn't check that the browser starts up or anything that appears on the page or that the URL is correct. A functional test is a test that checks a particular functionality of our application. For instance, a functional test might check that we can input a new item into a list and when we do so the item gets added to the database. Unlike a unit test that might have distinct tests for user input and writing to the database, the functional test tries to see that the components work together properly. Another way to think of this: unit tests check a discrete section of code. Functional tests simulate user experience. So, now lets update our functional_tests.py file. You'll notice that this is a functional test because it tests a component of our application as a user would encounter it. We'll write unittests later. from selenium import webdriver import unittest class NewVisitorTest(unittest.TestCase): def setUp(self): self.browser = webdriver.Firefox() def tearDown(self): self.browser.quit() def test_can_start_a_list_and_retrieve_it_later(self): # Call homepage self.browser.get('http://127.0.0.1:5000') # Old way: # assert 'To-Do' in browser.title # Using unittest methods self.assertIn('To-Do', self.browser.title) self.fail('Finish writing the test!') # She is invited to enter a to-do item straight away # She types \"Buy peacock feathers\" into a text box (Edith's hobby # is tying fly-fishing lures) # When she hits enter, the page updates, and now the page lists # \"1: Buy peacock feathers\" as an item in a to-do list # There is still a text box inviting her to add another item. She # enters \"Use peacock feathers to make a fly\" (Edith is very methodical) # The page updates again, and now shows both items on her list # Edith wonders whether the site will remember her list. Then she sees # that the site has generated a unique URL for her -- there is some # explanatory text to that effect. # She visits that URL - her to-do list is still there. # Satisfied, she goes back to sleep if __name__ in '__main__': unittest.main(warnings='ignore') Once again, we want to test it. If you stopped your Flask server, launch it again. Then let's run our functional tests and see the results: (env) $ python functional_tests.py F ====================================================================== FAIL: test_can_start_a_list_and_retrieve_it_later (__main__.NewVisitorTest) ---------------------------------------------------------------------- Traceback (most recent call last): File \"functional_tests.py\", line 20, in test_can_start_a_list_and_retrieve_it_later self.assertIn('To-Do', self.browser.title) AssertionError: 'To-Do' not found in '' ---------------------------------------------------------------------- Ran 1 test in 37.913s FAILED (failures=1) Woo! Our tests are failing as they should be. Notice, we haven't added anything to our app in this chapter, and that's intentional. We now have a test that will pass once our app is returning a page that has the correct title and that will be our next step. For now, it would be a good moment to commit your project and push it to github.","title":"unittest"},{"location":"ch5/","text":"Your Flask App We will be building the Superlists app in Flask. The approach and the code will be a bit different, but our tests will be pretty close to the Django Superlists apps discussed in Percival's book . Since Flask is a microframework, we don't have the same CLI to build a new application or feature within our app. In Django, when you run the command $ python manage.py startapp lists Django creates a brand new app with a bunch of files associated with that application. It includes an admin interface, all of your database models, and your views. This makes building with Django relatively easy and quick, but on the other hand, if you are, say, building an app that doesn't require a database or admin interface or users, then Django gives you a lot of extra stuff that you don't need, still needs to be maintained, and might contain vulnerabilities that will be patched in the future. How do we start our app with Flask?","title":"Five"},{"location":"ch5/#your-flask-app","text":"We will be building the Superlists app in Flask. The approach and the code will be a bit different, but our tests will be pretty close to the Django Superlists apps discussed in Percival's book . Since Flask is a microframework, we don't have the same CLI to build a new application or feature within our app. In Django, when you run the command $ python manage.py startapp lists Django creates a brand new app with a bunch of files associated with that application. It includes an admin interface, all of your database models, and your views. This makes building with Django relatively easy and quick, but on the other hand, if you are, say, building an app that doesn't require a database or admin interface or users, then Django gives you a lot of extra stuff that you don't need, still needs to be maintained, and might contain vulnerabilities that will be patched in the future. How do we start our app with Flask?","title":"Your Flask App"}]}