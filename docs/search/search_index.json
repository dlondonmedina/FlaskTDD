{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TDD in Flask This book is a supplement to Test-Driven Development with Python: Obey the Testing Goat: Using Django, Selenium, and Javascript . In this version, much of the content is not copied over. Instead this provides modified exercises and examples using Flask instead of Django. If you have a bit more experience with Python or want to use a more robust framework, I encourage you to take a look at Percival's book. If you want to learn about test-driven development but find Flask suits your purposes better, this is a supplement for you. This book is being built for a course offered at Seattle University, and therefore will contain some additional content for that course. In the future, perhaps video lectures and exercises will become available. For the exercises, starter-code is available. Please feel free to clone it here . About the Author I direct the Web, Application, and Technology Studies program at Seattle University\u2019s School of New and Continuing Studies. My research and pedagogy are deeply invested learning and its application to future contexts. My MA and PhD research focuses on how students acquire and deploy rhetorical strategies and skills within the social, material, and technological landscapes in which they work. I teach in the areas of social theory, social science research, writing, web development, and Python. At heart, I am a maker and have devoted a great deal of energy to creating projects and programs to address problems I see in the world around me. This lead me to develop a transition workshop for service members, which I taught for four years at Joint Base Lewis-McChord. I also lead a team developing Cluster\u2014a suite of tools that work like a personal writing trainer. In the summer, I teach a Python camp for underrepresented kids. Acknowledgements This book is written by Dylan Medina and is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License . It is a Flask supplement for Test-Driven Development with Python by Harry J.W. Percival. Please visit his site and consider purchasing his excellent book. This book ports the exercises from Django to Flask.","title":"Home"},{"location":"#tdd-in-flask","text":"This book is a supplement to Test-Driven Development with Python: Obey the Testing Goat: Using Django, Selenium, and Javascript . In this version, much of the content is not copied over. Instead this provides modified exercises and examples using Flask instead of Django. If you have a bit more experience with Python or want to use a more robust framework, I encourage you to take a look at Percival's book. If you want to learn about test-driven development but find Flask suits your purposes better, this is a supplement for you. This book is being built for a course offered at Seattle University, and therefore will contain some additional content for that course. In the future, perhaps video lectures and exercises will become available. For the exercises, starter-code is available. Please feel free to clone it here .","title":"TDD in Flask"},{"location":"#about-the-author","text":"I direct the Web, Application, and Technology Studies program at Seattle University\u2019s School of New and Continuing Studies. My research and pedagogy are deeply invested learning and its application to future contexts. My MA and PhD research focuses on how students acquire and deploy rhetorical strategies and skills within the social, material, and technological landscapes in which they work. I teach in the areas of social theory, social science research, writing, web development, and Python. At heart, I am a maker and have devoted a great deal of energy to creating projects and programs to address problems I see in the world around me. This lead me to develop a transition workshop for service members, which I taught for four years at Joint Base Lewis-McChord. I also lead a team developing Cluster\u2014a suite of tools that work like a personal writing trainer. In the summer, I teach a Python camp for underrepresented kids.","title":"About the Author"},{"location":"#acknowledgements","text":"This book is written by Dylan Medina and is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License . It is a Flask supplement for Test-Driven Development with Python by Harry J.W. Percival. Please visit his site and consider purchasing his excellent book. This book ports the exercises from Django to Flask.","title":"Acknowledgements"},{"location":"ch1/","text":"Introduction to TDD There are many different approaches to developing software. One of the major ones that is used, especially in enterprise scale projects, is Test-Driven Development (TDD). TDD means that before we write any code we write a test that will determine if our code is functioning the way we want it to. For instance, let's say I want to build a function that returns a list of prime factors of an integer passed into the function. Let's also say, I want that function to return None if the value passed to the function is not an integer. If we are not using a TDD approach we might start by writing our function directly. However, we'll spend a lot of time debugging and running into issues if we do so. Instead, let's think about the things that we need to test: The easiest case is when the input is incorrect. We can set up a test that will call the function with a value that is not an integer and test that we receive None as the return. We need to test that the function returns a list when it is passed an integer. We need to test that the list contains the prime factors of the input integer. A simple and dirty way to test this is to write a driver that tests all of the functionality above. It might look something like this: if __name__ == \"__main__\": out1 = prime_factors(\"apple\") if out1 is None: print(\"Out is None. Pass\") else: print(\"Does not return None. Fail\") out2 = prime_factors(315) if isinstance(out2, list): print(\"Returns a list. Pass\") if out2 == [3, 5, 7]: print(\"Out is 3, 5, 7. Pass\") else: print(\"Does not return the right list. Fail\") else: print(\"Does not return a list. Fail) From there, I'd write out my function and make sure it's called prime_factors(). If you'd like, you can try using this method, and see if you can get it working. For a small, toy task like this, you might be able to sufficiently test your program with a driver, but you end up with a messy driver at the bottom of your program that you'll want to delete later on, and it's an awful lot of lines. Doctest Fortunately, Python includes a number of test tools that can help us do TDD more easily and make our tests more effective. The first of which is doctest , and it comes built-in with Python. Doctest allows you to write your tests into the docstring of your function. If you recall, a docstring is the bit of documentation this is included in triple double quotes when you define a function. The same tests as above would look like this: def prime_factors(n): \"\"\"Return list of prime factors of n or None if not integer >>> prime_factors(\"apple\") None It must return a list type object >>> out = prime_factors(315) >>> isinstance(out, list) True It must return the right list >>> prime_factors(315) [3, 5, 7] \"\"\" Please do take a moment to explore the doctest library. We have two options to run the test. First we can include this driver at the bottom of our module. if __name__ == \"__main__\": import doctest doctest.testmod() and then run the program from our terminal: (env) $ python prime_factors.py or we can leave the driver off and call the doctest module from the terminal (this won't work if there are many imports): (env) $ python -m doctest -v prime_factors.py I generally prefer to use the second route so that I don't have extra cruft in my program. That being said, I generally use unittest instead of doctest, so I don't spend a lot of time with this library. It is a good one, though. This time, go ahead and try this out. Unittest Another tool we use in TDD is testing suites. unittest is one such testing suite, and it includes various tools that help us write automated tests for our projects. Other options for automated testing that are very popular are pytest and nose. We will be using unittest in this class, but I do encourage you to explore some of the other options. I'll write up the same set of tests using unittest now. Please note that I will have two different files, one for my code, and one for my tests: prime_factors_tests.py import unittest import prime_factors as target #1 class TestPrimeFactors(unittest.TestCase): #2 def test_bad_input(self): #3 self.assertIsNone(target.prime_factors(\"apple\")) def test_returns_list(self): l = target.prime_factors(315) self.assertIsInstance(l, list) def test_returns_correct_list(self): l = target.prime_factors(315) self.assertEqual([3, 5, 7], l) Here are a few things to pay attention to: 1. We're importing our code to be tested, so we need to make sure it is in a file called prime_factors and is in the same directory as our test suite. 2. We create a new object to run the collection of tests. The rule is that our test class name must begin with the word Test and it must extend the unittest.TestCase class. We'll talk about inheritance next week with Objects. 3. Each test function should test one discrete case that could occur when the code runs (if we're doing unittests). See the bulleted list above. Also, notice that all of the test functions begin with the word \"test\" followed by some description of what the test is looking for in snake case. If you're following along, you should have two files in your directory. One with the tests and one that is empty for our code. If so, let's try to run our tests: $ python -m unittest prime_factors_tests.py EEE ====================================================================== ERROR: test_bad_input (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 8, in test_bad_input self.assertIsNone(target.prime_factors(\"apple\")) AttributeError: module 'prime_factors' has no attribute 'prime_factors' ====================================================================== ERROR: test_returns_correct_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 15, in test_returns_correct_list l = target.prime_factors(315) AttributeError: module 'prime_factors' has no attribute 'prime_factors' ====================================================================== ERROR: test_returns_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 11, in test_returns_list l = target.prime_factors(315) AttributeError: module 'prime_factors' has no attribute 'prime_factors' ---------------------------------------------------------------------- Ran 3 tests in 0.000s FAILED (errors=3) You'll notice that the tests failed, but they failed because of errors. This is because our file for the code is empty. We can remedy this by beginning to code: prime_factors.py def prime_factors(n): pass Notice that I'm working very incrementally and slowly. So I am expecting now all my tests will fail instead of throw errors. Here we go: $ python -m unittest prime_factors_tests.py .FF ====================================================================== FAIL: test_returns_correct_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 15, in test_returns_correct_list self.assertEqual([3, 5, 7], l) AssertionError: [3, 5, 7] != None ====================================================================== FAIL: test_returns_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 11, in test_returns_list self.assertIsInstance(l, list) AssertionError: None is not an instance of <class 'list'> ---------------------------------------------------------------------- Ran 3 tests in 0.000s FAILED (failures=2) We have to failures. You'll notice the first test is not failing. This is because our function currently is not returning anything, and no return is the same as None. So the test passes. I'm going to alter the code slightly just to get to the point where everything is failing. prime_factors.py def prime_factors(n): return -1 So we try one more time and we get three failures as expected: $ python -m unittest prime_factors_tests.py FFF ====================================================================== FAIL: test_bad_input (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 7, in test_bad_input self.assertIsNone(target.prime_factors(\"apple\")) AssertionError: -1 is not None ====================================================================== FAIL: test_returns_correct_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 15, in test_returns_correct_list self.assertEqual([3, 5, 7], l) AssertionError: [3, 5, 7] != -1 ====================================================================== FAIL: test_returns_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 11, in test_returns_list self.assertIsInstance(l, list) AssertionError: -1 is not an instance of <class 'list'> ---------------------------------------------------------------------- Ran 3 tests in 0.000s FAILED (failures=3) Failed tests are a good thing. First, we know that once all of my tests pass, if I did a good job designing them, then the code will be working properly and will be less likely to have bugs. Second, I can see that these are all failing exactly as I am expecting to, so the tests are working. I just need to write my code so it satisfies the tests. My first test is checking to make sure that the function returns none if the input is not an integer. So let's get that one ot pass: prime_factors.py def prime_factors(n): if isinstance(n, int): return -1 return None This change means that the only case in which the function will not return None is if n is an integer. Let's run our tests and see: $ python -m unittest prime_factors_tests.py .FF ====================================================================== FAIL: test_returns_correct_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 15, in test_returns_correct_list self.assertEqual([3, 5, 7], l) AssertionError: [3, 5, 7] != -1 ====================================================================== FAIL: test_returns_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 11, in test_returns_list self.assertIsInstance(l, list) AssertionError: -1 is not an instance of <class 'list'> ---------------------------------------------------------------------- Ran 3 tests in 0.000s FAILED (failures=2) You'll notice that our tests still fail, but the first test passed. That's great and means progress! Now we just need to get our other tests to pass. We could have the function return an empty list to get the second test to pass, but I'm just going to finish off the code and get both tests passing at the same time. There might be some debate as to whether we should test both that the function returns a list and returns the correct list. We could say if we're testing for the correct list, we don't need to also test that the function returns a list. prime_factors.py import math def prime_factors(n): if isinstance(n, int): out = [] if n % 2 == 0: out.append(2) while n % 2 == 0: n = n / 2 for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: out.append(i) while n % i == 0: n = n / i if n > 2: out.append(n) return out return None Success! We're done! $ python -m unittest prime_factors_tests.py ... ---------------------------------------------------------------------- Ran 3 tests in 0.000s OK In the next chapter we'll be discussing different types of tests (End to End, Functional, and Unit Tests).","title":"1. Intro to TDD"},{"location":"ch1/#introduction-to-tdd","text":"There are many different approaches to developing software. One of the major ones that is used, especially in enterprise scale projects, is Test-Driven Development (TDD). TDD means that before we write any code we write a test that will determine if our code is functioning the way we want it to. For instance, let's say I want to build a function that returns a list of prime factors of an integer passed into the function. Let's also say, I want that function to return None if the value passed to the function is not an integer. If we are not using a TDD approach we might start by writing our function directly. However, we'll spend a lot of time debugging and running into issues if we do so. Instead, let's think about the things that we need to test: The easiest case is when the input is incorrect. We can set up a test that will call the function with a value that is not an integer and test that we receive None as the return. We need to test that the function returns a list when it is passed an integer. We need to test that the list contains the prime factors of the input integer. A simple and dirty way to test this is to write a driver that tests all of the functionality above. It might look something like this: if __name__ == \"__main__\": out1 = prime_factors(\"apple\") if out1 is None: print(\"Out is None. Pass\") else: print(\"Does not return None. Fail\") out2 = prime_factors(315) if isinstance(out2, list): print(\"Returns a list. Pass\") if out2 == [3, 5, 7]: print(\"Out is 3, 5, 7. Pass\") else: print(\"Does not return the right list. Fail\") else: print(\"Does not return a list. Fail) From there, I'd write out my function and make sure it's called prime_factors(). If you'd like, you can try using this method, and see if you can get it working. For a small, toy task like this, you might be able to sufficiently test your program with a driver, but you end up with a messy driver at the bottom of your program that you'll want to delete later on, and it's an awful lot of lines.","title":"Introduction to TDD"},{"location":"ch1/#doctest","text":"Fortunately, Python includes a number of test tools that can help us do TDD more easily and make our tests more effective. The first of which is doctest , and it comes built-in with Python. Doctest allows you to write your tests into the docstring of your function. If you recall, a docstring is the bit of documentation this is included in triple double quotes when you define a function. The same tests as above would look like this: def prime_factors(n): \"\"\"Return list of prime factors of n or None if not integer >>> prime_factors(\"apple\") None It must return a list type object >>> out = prime_factors(315) >>> isinstance(out, list) True It must return the right list >>> prime_factors(315) [3, 5, 7] \"\"\" Please do take a moment to explore the doctest library. We have two options to run the test. First we can include this driver at the bottom of our module. if __name__ == \"__main__\": import doctest doctest.testmod() and then run the program from our terminal: (env) $ python prime_factors.py or we can leave the driver off and call the doctest module from the terminal (this won't work if there are many imports): (env) $ python -m doctest -v prime_factors.py I generally prefer to use the second route so that I don't have extra cruft in my program. That being said, I generally use unittest instead of doctest, so I don't spend a lot of time with this library. It is a good one, though. This time, go ahead and try this out.","title":"Doctest"},{"location":"ch1/#unittest","text":"Another tool we use in TDD is testing suites. unittest is one such testing suite, and it includes various tools that help us write automated tests for our projects. Other options for automated testing that are very popular are pytest and nose. We will be using unittest in this class, but I do encourage you to explore some of the other options. I'll write up the same set of tests using unittest now. Please note that I will have two different files, one for my code, and one for my tests: prime_factors_tests.py import unittest import prime_factors as target #1 class TestPrimeFactors(unittest.TestCase): #2 def test_bad_input(self): #3 self.assertIsNone(target.prime_factors(\"apple\")) def test_returns_list(self): l = target.prime_factors(315) self.assertIsInstance(l, list) def test_returns_correct_list(self): l = target.prime_factors(315) self.assertEqual([3, 5, 7], l) Here are a few things to pay attention to: 1. We're importing our code to be tested, so we need to make sure it is in a file called prime_factors and is in the same directory as our test suite. 2. We create a new object to run the collection of tests. The rule is that our test class name must begin with the word Test and it must extend the unittest.TestCase class. We'll talk about inheritance next week with Objects. 3. Each test function should test one discrete case that could occur when the code runs (if we're doing unittests). See the bulleted list above. Also, notice that all of the test functions begin with the word \"test\" followed by some description of what the test is looking for in snake case. If you're following along, you should have two files in your directory. One with the tests and one that is empty for our code. If so, let's try to run our tests: $ python -m unittest prime_factors_tests.py EEE ====================================================================== ERROR: test_bad_input (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 8, in test_bad_input self.assertIsNone(target.prime_factors(\"apple\")) AttributeError: module 'prime_factors' has no attribute 'prime_factors' ====================================================================== ERROR: test_returns_correct_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 15, in test_returns_correct_list l = target.prime_factors(315) AttributeError: module 'prime_factors' has no attribute 'prime_factors' ====================================================================== ERROR: test_returns_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 11, in test_returns_list l = target.prime_factors(315) AttributeError: module 'prime_factors' has no attribute 'prime_factors' ---------------------------------------------------------------------- Ran 3 tests in 0.000s FAILED (errors=3) You'll notice that the tests failed, but they failed because of errors. This is because our file for the code is empty. We can remedy this by beginning to code: prime_factors.py def prime_factors(n): pass Notice that I'm working very incrementally and slowly. So I am expecting now all my tests will fail instead of throw errors. Here we go: $ python -m unittest prime_factors_tests.py .FF ====================================================================== FAIL: test_returns_correct_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 15, in test_returns_correct_list self.assertEqual([3, 5, 7], l) AssertionError: [3, 5, 7] != None ====================================================================== FAIL: test_returns_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 11, in test_returns_list self.assertIsInstance(l, list) AssertionError: None is not an instance of <class 'list'> ---------------------------------------------------------------------- Ran 3 tests in 0.000s FAILED (failures=2) We have to failures. You'll notice the first test is not failing. This is because our function currently is not returning anything, and no return is the same as None. So the test passes. I'm going to alter the code slightly just to get to the point where everything is failing. prime_factors.py def prime_factors(n): return -1 So we try one more time and we get three failures as expected: $ python -m unittest prime_factors_tests.py FFF ====================================================================== FAIL: test_bad_input (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 7, in test_bad_input self.assertIsNone(target.prime_factors(\"apple\")) AssertionError: -1 is not None ====================================================================== FAIL: test_returns_correct_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 15, in test_returns_correct_list self.assertEqual([3, 5, 7], l) AssertionError: [3, 5, 7] != -1 ====================================================================== FAIL: test_returns_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 11, in test_returns_list self.assertIsInstance(l, list) AssertionError: -1 is not an instance of <class 'list'> ---------------------------------------------------------------------- Ran 3 tests in 0.000s FAILED (failures=3) Failed tests are a good thing. First, we know that once all of my tests pass, if I did a good job designing them, then the code will be working properly and will be less likely to have bugs. Second, I can see that these are all failing exactly as I am expecting to, so the tests are working. I just need to write my code so it satisfies the tests. My first test is checking to make sure that the function returns none if the input is not an integer. So let's get that one ot pass: prime_factors.py def prime_factors(n): if isinstance(n, int): return -1 return None This change means that the only case in which the function will not return None is if n is an integer. Let's run our tests and see: $ python -m unittest prime_factors_tests.py .FF ====================================================================== FAIL: test_returns_correct_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 15, in test_returns_correct_list self.assertEqual([3, 5, 7], l) AssertionError: [3, 5, 7] != -1 ====================================================================== FAIL: test_returns_list (prime_factors_tests.TestPrimeFactors) ---------------------------------------------------------------------- Traceback (most recent call last): File \"prime_factors_tests.py\", line 11, in test_returns_list self.assertIsInstance(l, list) AssertionError: -1 is not an instance of <class 'list'> ---------------------------------------------------------------------- Ran 3 tests in 0.000s FAILED (failures=2) You'll notice that our tests still fail, but the first test passed. That's great and means progress! Now we just need to get our other tests to pass. We could have the function return an empty list to get the second test to pass, but I'm just going to finish off the code and get both tests passing at the same time. There might be some debate as to whether we should test both that the function returns a list and returns the correct list. We could say if we're testing for the correct list, we don't need to also test that the function returns a list. prime_factors.py import math def prime_factors(n): if isinstance(n, int): out = [] if n % 2 == 0: out.append(2) while n % 2 == 0: n = n / 2 for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: out.append(i) while n % i == 0: n = n / i if n > 2: out.append(n) return out return None Success! We're done! $ python -m unittest prime_factors_tests.py ... ---------------------------------------------------------------------- Ran 3 tests in 0.000s OK In the next chapter we'll be discussing different types of tests (End to End, Functional, and Unit Tests).","title":"Unittest"},{"location":"ch10/","text":"Flask Templates If you recall from the last page on Flask we created an app in our file init .py in the app folder. Then we wrapped the app with our routes (specifically the index function that returns text). When we type flask run in our terminal the built in Flask server (the service that runs our app) starts up listening on the ip address 127.0.0.1 port 5000. 127.0.0.1 is a local ip address that your computer's network card establishes for internal traffic. In other words, if I browse to 127.0.0.1 in my web browser (note: you can enter ip addresses directly into the URL bar in the web browser), my browser sends a request to my own network card and any server that happens to be running on my computer listening at that address. If you have an Apache server on your computer (Linux has one by default), then the Apache server will be listening for traffic on that address and will return some configuration info as a webpage. This IP address is a local address and cannot be accessed from the outside world, so on every computer, the local host address is the same. The port (5000) indicates which service at a particular IP address we're directing traffic to. By default, http traffic goes to port 80 and https traffic goes to port 443. Our Flask server runs at port 5000. Once the Flask server is listening on our local host, when we try to visit it, the server sends the request to our app, which has specified routes and actions to perform when particular routes are requested. Let's take a look at a sample URL to break that down a bit. https://127.0.0.1/gallery.html If I were to type that into my browser's URL bar, my browser would make a request using the https protocol, which means that the request would be encrypted, to the IP address 127.0.0.1 (port 443 by default). Along with that request, it would say \"give me the resource gallery.html.\" The Apache server listening at that IP address and port would receive the request and look for a file called gallery.html. If that file exists, then the server will send the file back to the browser (or client) with a response code of 200 (meaning, success). If that file or resource does not exist, then the server would send back response code 404 (meaning, error: resource not found). As the browser receives the page gallery.html from the server, it would read through the header to see if there are any additional files to include like style sheets or javascript files. It will make additional requests to the server (or other servers) to gather those additional resources. The browser then loads all of those resources, applies any relevant scripts and styles, and gives you a lovely web page that you can see in the browser window. That's basically how static web sites work. They are a bunch of html files living on a server. Flask is similar but instead of simply being a static set of html files, it is a dynamic application. So, let's look at another URL to explain this. https://127.0.0.1/index In this case, my browser makes a request using the https protocol to IP address 127.0.0.1 (port 443 by default), exactly like last time. This time, however, the request is asking not for a static html file, but rather a resource called \"index.\" Now Flask knows about this particular resource because we created the route \"/index\" in our routes.py file and applied that route to the application. The application running on the Flask server knows that when a browser requests that resource (\"/index\") or that route, it needs to call the index() method. If we look at that method, we know that it returns \"Hello, Flask!\" So, the app gathers that and sends it back to the client. This is why you get a page with Hello, Flask! at the top of it. The method at a particular route could be more complex and could generate more stuff, which we're going to talk about on this page, but overall, this is how the Flask server handles traffic. It looks at everything after the base domain (127.0.0.1 or www.example.com, or whatever) and calls all of the appropriate functions, which gather data from a database (or put data into a database), pull up templates, populate those templates with data, and finally send the populated templates as html strings to the browser to display just as if they were static html pages (just built on the fly). Templates A template is little more than an html document with variables. The problem with html files and static pages is that you cannot change the content in them without using javascript. Let's say I want to create a blog that's going to have a million posts. To do this statically, I'd need to either have one page with a million spots for blog entries with the blog entries already written out, or I'd need a million files where all of the content (menus, footers, borders, etc) are all exactly the same, but the text and author of the particular post might be different. Here is an example of what a static blog page might look like: <html> <head> <title>Blog post 200</title> </head> <body> <nav> <ul> <li>Home</li> <li>Author</li> <li> Posts <ul> <li>1</li> <li>2</li> <li>3</li> <li>4</li> <li>...</li> <li>200</li> </ul> </li> <li>Contact</li> </ul> </nav> <h1>Post 200</h1> <h2>Dylan Medina</h2> <p>Lorem ipsum dolor sit amet consectetur, adipisicing elit. Magnam dolorum earum, quae blanditiis minima quis ipsam labore, ad, veniam iste quod ipsa aliquam! Alias numquam quas neque repellendus eaque. Sunt. Lorem ipsum dolor sit amet, consectetur adipisicing elit. Beatae tempore deserunt ipsam libero reiciendis consequatur fugit sit saepe repudiandae! Quos quaerat fugiat voluptatibus accusantium esse earum, similique eveniet nam dolor! Culpa odio optio eaque porro aliquid accusantium veritatis iste voluptates fugiat vel, deserunt, placeat officia. Sequi at error, possimus totam, tempore pariatur est voluptatum, quis asperiores laboriosam rerum temporibus necessitatibus. Quis delectus expedita quas explicabo debitis laudantium. Fugiat, alias in incidunt voluptates adipisci at nemo error dignissimos eos. Mollitia voluptas expedita rem veritatis minima ex doloribus reprehenderit accusantium beatae. Dignissimos! Ipsam numquam quo quod illum esse est, ullam ea veritatis voluptatem iusto qui, voluptatum quisquam corporis blanditiis voluptate vel quaerat dicta, officiis delectus possimus voluptas ratione pariatur doloremque. Rerum, harum! Numquam fugiat rerum molestiae assumenda necessitatibus eveniet accusamus at ut sed unde. Dicta odio autem corporis sunt commodi, rerum excepturi quos libero labore. Mollitia inventore eveniet dicta, aliquid enim ullam!</p> </body> </html> Now imagine I had a million files exactly like that, but different content in the author field and the paragraph. It seems super wasteful, even if I copy and paste all of the structure. Let's say I want to make a change to the menu (add another post to the Posts sub menu, for instance); I'd have to change the menu on every single file. Likewise, all of that content would exist as a million files on my server. Really a gross kind of site to both build and maintain. However, static sites are making a comeback as templating gets more powerful. A template allows us to create a single static html file (or \"template\") that has areas that are populated by dynamic content. For instance, in my million post blog, I could simply create a template that has a variable space for the author, title, and post. Then I have a single html file with variables that get populated by text by the server as it prepares to send a response to the client browser. A template using Jinja, which is what Flask uses by default, of the million post blog would look like this: <html> <head> <title>Blog Post {{ title }}</title> </head> <body> <nav> <ul> <li>Home</li> <li>Author</li> <li> Posts <ul> {% for t in post_titles %} <li>{{ t }}</li> {% endfor %} </ul> </li> <li>Contact</li> </ul> </nav> <h1>Post {{ title }}</h1> <h2>{{ author }}</h2> <p>{{ body_content }}</p> </body> </html> You can see above, title is now a dynamic value that will be populated when the request is made. Likewise, instead of a menu with a huge list of posts, I have a for loop which will create linkes for posts from some list (post_titles) that is passed to the template. The author is also a variable that is passed to the template, and so is the body_content. I now have a single html file (you'll learn that Jinja templates can also extend each other, so you might have one base.html file, then a few templates that extend the base template for different types of pages) that can hold any blog post content. A function in my flask app (probably that takes an input parameter) will populate that template with the relevant data depending on the specific input parameter. So, if I wanted to request post 200, the browser might send a request to the url https://127.0.0.1/blog/200 . The Flask app listening at 127.0.0.1 would look for a route blog with the parameter 200. Ideally, there will be a method call that occurs at that route. The method would probably pull the content for post 200 out of the database and fill it into the template that it renders. What database, what template, and how that data all gets massaged together will depend on my specific design, but the basic operation will be the same. There's not much more to it. In Flask, templates are pretty easy. In general, \"programming\" kinds of operations (like loops and conditionals) are surrounded by {% %}, the most difficult character sequence to type ever. Then variables are surrounded by double moustaches {{ }}. You pass those variables to the template with the render_template method. Other Frontend Options It is possible to send data back as JSON or some other data structure as well. It is not uncommon for people to use Flask as the back end of the website. It manages data and states. Then you might use a Javascript framework like Vue or React for the front end. These frameworks often provide a better, easier to build and maintain front end user interface. However, this is beyond the scope of what we are doing here. It's just worth knowing these exist.","title":"10. Intro to Templates"},{"location":"ch10/#flask-templates","text":"If you recall from the last page on Flask we created an app in our file init .py in the app folder. Then we wrapped the app with our routes (specifically the index function that returns text). When we type flask run in our terminal the built in Flask server (the service that runs our app) starts up listening on the ip address 127.0.0.1 port 5000. 127.0.0.1 is a local ip address that your computer's network card establishes for internal traffic. In other words, if I browse to 127.0.0.1 in my web browser (note: you can enter ip addresses directly into the URL bar in the web browser), my browser sends a request to my own network card and any server that happens to be running on my computer listening at that address. If you have an Apache server on your computer (Linux has one by default), then the Apache server will be listening for traffic on that address and will return some configuration info as a webpage. This IP address is a local address and cannot be accessed from the outside world, so on every computer, the local host address is the same. The port (5000) indicates which service at a particular IP address we're directing traffic to. By default, http traffic goes to port 80 and https traffic goes to port 443. Our Flask server runs at port 5000. Once the Flask server is listening on our local host, when we try to visit it, the server sends the request to our app, which has specified routes and actions to perform when particular routes are requested. Let's take a look at a sample URL to break that down a bit. https://127.0.0.1/gallery.html If I were to type that into my browser's URL bar, my browser would make a request using the https protocol, which means that the request would be encrypted, to the IP address 127.0.0.1 (port 443 by default). Along with that request, it would say \"give me the resource gallery.html.\" The Apache server listening at that IP address and port would receive the request and look for a file called gallery.html. If that file exists, then the server will send the file back to the browser (or client) with a response code of 200 (meaning, success). If that file or resource does not exist, then the server would send back response code 404 (meaning, error: resource not found). As the browser receives the page gallery.html from the server, it would read through the header to see if there are any additional files to include like style sheets or javascript files. It will make additional requests to the server (or other servers) to gather those additional resources. The browser then loads all of those resources, applies any relevant scripts and styles, and gives you a lovely web page that you can see in the browser window. That's basically how static web sites work. They are a bunch of html files living on a server. Flask is similar but instead of simply being a static set of html files, it is a dynamic application. So, let's look at another URL to explain this. https://127.0.0.1/index In this case, my browser makes a request using the https protocol to IP address 127.0.0.1 (port 443 by default), exactly like last time. This time, however, the request is asking not for a static html file, but rather a resource called \"index.\" Now Flask knows about this particular resource because we created the route \"/index\" in our routes.py file and applied that route to the application. The application running on the Flask server knows that when a browser requests that resource (\"/index\") or that route, it needs to call the index() method. If we look at that method, we know that it returns \"Hello, Flask!\" So, the app gathers that and sends it back to the client. This is why you get a page with Hello, Flask! at the top of it. The method at a particular route could be more complex and could generate more stuff, which we're going to talk about on this page, but overall, this is how the Flask server handles traffic. It looks at everything after the base domain (127.0.0.1 or www.example.com, or whatever) and calls all of the appropriate functions, which gather data from a database (or put data into a database), pull up templates, populate those templates with data, and finally send the populated templates as html strings to the browser to display just as if they were static html pages (just built on the fly).","title":"Flask Templates"},{"location":"ch10/#templates","text":"A template is little more than an html document with variables. The problem with html files and static pages is that you cannot change the content in them without using javascript. Let's say I want to create a blog that's going to have a million posts. To do this statically, I'd need to either have one page with a million spots for blog entries with the blog entries already written out, or I'd need a million files where all of the content (menus, footers, borders, etc) are all exactly the same, but the text and author of the particular post might be different. Here is an example of what a static blog page might look like: <html> <head> <title>Blog post 200</title> </head> <body> <nav> <ul> <li>Home</li> <li>Author</li> <li> Posts <ul> <li>1</li> <li>2</li> <li>3</li> <li>4</li> <li>...</li> <li>200</li> </ul> </li> <li>Contact</li> </ul> </nav> <h1>Post 200</h1> <h2>Dylan Medina</h2> <p>Lorem ipsum dolor sit amet consectetur, adipisicing elit. Magnam dolorum earum, quae blanditiis minima quis ipsam labore, ad, veniam iste quod ipsa aliquam! Alias numquam quas neque repellendus eaque. Sunt. Lorem ipsum dolor sit amet, consectetur adipisicing elit. Beatae tempore deserunt ipsam libero reiciendis consequatur fugit sit saepe repudiandae! Quos quaerat fugiat voluptatibus accusantium esse earum, similique eveniet nam dolor! Culpa odio optio eaque porro aliquid accusantium veritatis iste voluptates fugiat vel, deserunt, placeat officia. Sequi at error, possimus totam, tempore pariatur est voluptatum, quis asperiores laboriosam rerum temporibus necessitatibus. Quis delectus expedita quas explicabo debitis laudantium. Fugiat, alias in incidunt voluptates adipisci at nemo error dignissimos eos. Mollitia voluptas expedita rem veritatis minima ex doloribus reprehenderit accusantium beatae. Dignissimos! Ipsam numquam quo quod illum esse est, ullam ea veritatis voluptatem iusto qui, voluptatum quisquam corporis blanditiis voluptate vel quaerat dicta, officiis delectus possimus voluptas ratione pariatur doloremque. Rerum, harum! Numquam fugiat rerum molestiae assumenda necessitatibus eveniet accusamus at ut sed unde. Dicta odio autem corporis sunt commodi, rerum excepturi quos libero labore. Mollitia inventore eveniet dicta, aliquid enim ullam!</p> </body> </html> Now imagine I had a million files exactly like that, but different content in the author field and the paragraph. It seems super wasteful, even if I copy and paste all of the structure. Let's say I want to make a change to the menu (add another post to the Posts sub menu, for instance); I'd have to change the menu on every single file. Likewise, all of that content would exist as a million files on my server. Really a gross kind of site to both build and maintain. However, static sites are making a comeback as templating gets more powerful. A template allows us to create a single static html file (or \"template\") that has areas that are populated by dynamic content. For instance, in my million post blog, I could simply create a template that has a variable space for the author, title, and post. Then I have a single html file with variables that get populated by text by the server as it prepares to send a response to the client browser. A template using Jinja, which is what Flask uses by default, of the million post blog would look like this: <html> <head> <title>Blog Post {{ title }}</title> </head> <body> <nav> <ul> <li>Home</li> <li>Author</li> <li> Posts <ul> {% for t in post_titles %} <li>{{ t }}</li> {% endfor %} </ul> </li> <li>Contact</li> </ul> </nav> <h1>Post {{ title }}</h1> <h2>{{ author }}</h2> <p>{{ body_content }}</p> </body> </html> You can see above, title is now a dynamic value that will be populated when the request is made. Likewise, instead of a menu with a huge list of posts, I have a for loop which will create linkes for posts from some list (post_titles) that is passed to the template. The author is also a variable that is passed to the template, and so is the body_content. I now have a single html file (you'll learn that Jinja templates can also extend each other, so you might have one base.html file, then a few templates that extend the base template for different types of pages) that can hold any blog post content. A function in my flask app (probably that takes an input parameter) will populate that template with the relevant data depending on the specific input parameter. So, if I wanted to request post 200, the browser might send a request to the url https://127.0.0.1/blog/200 . The Flask app listening at 127.0.0.1 would look for a route blog with the parameter 200. Ideally, there will be a method call that occurs at that route. The method would probably pull the content for post 200 out of the database and fill it into the template that it renders. What database, what template, and how that data all gets massaged together will depend on my specific design, but the basic operation will be the same. There's not much more to it. In Flask, templates are pretty easy. In general, \"programming\" kinds of operations (like loops and conditionals) are surrounded by {% %}, the most difficult character sequence to type ever. Then variables are surrounded by double moustaches {{ }}. You pass those variables to the template with the render_template method.","title":"Templates"},{"location":"ch10/#other-frontend-options","text":"It is possible to send data back as JSON or some other data structure as well. It is not uncommon for people to use Flask as the back end of the website. It manages data and states. Then you might use a Javascript framework like Vue or React for the front end. These frameworks often provide a better, easier to build and maintain front end user interface. However, this is beyond the scope of what we are doing here. It's just worth knowing these exist.","title":"Other Frontend Options"},{"location":"ch11/","text":"Back to Flask One More Background Lesson If you recall, our __init__.py file looked like this: app/__init__.py from flask import Flask app = Flask(__name__) @app.route('/') def hello_flask(): return 'Hello Flask!' You may have noticed the line @app.route('/') and wondered what was going on. What is happening is we are using what is called a decorator in Python. The @ symbol is a decorator. Here I want to take a moment to go into detail about how decorators work. Decorators If you recall, functions can take parameters. Hopefully this is pretty clear to you at this point, but if not, it's worth a review. def word_frequency(word_list, text): out = {} for word in word_list: if word not in out.keys(): out[word] = text.count(word) return out This function takes two parameters: a word list and a text. I'd assume the first is a list of words and the second is a string. The point is these are flexible and they are the way that we pass data into a function. It's pretty obvious that primitive datatypes and also data structures can be passed into a function as a parameter, but that's not all. Functions can also take objects and functions as parameters. Here is an example of a function taking a function as a parameter: def say_hello(func): #1 print(\"Hello!\") func() #2 print(\"Goodbye!\") def sing_a_song(): #3 print(\"la la la la la!\") def greetings(): #4 print(\"It certainly is good to meet you!\") # Driver if __name__ == \"__main__\": say_hello(sing_a_song) #5 say_hello(greetings) #6 At #1, we are defining a function called say_hello that takes one parameter func , which we can assume is a function. At #2, the function that is passed in as a parameter is called or is executed. At #3, we define a simple function called sing_a_song that prints a string to the screen. At #4, we define a second simple function called greetings, which has the same functionality as sing_a_song, except it prints a different string. At #5, in our driver we call the function say_hello and pass it sing_a_song to its parameter. At #6, in our driver we call the function say_hello and pass it greetings to its parameter. You'll notice that like any parameter, a function parameter can receive any function. If you want, take a moment to type this into a file and run it. Here is the output. ~/$ python example.py Hello! la la la la la! Goodbye! Hello! It certainly is good to meet you! Goodbye! Just as we can pass a function to another function as a parameter, we can also have a function return another function or sub-function. my_script.py def wordsearch(print=False): def search(word, text): return text.count(word) def printer(word, text): print(text.count(word)) if print: return printer return search if __name__ == \"__main__\": text = \"This is a string with lots of strings. Cat's like string.\" word = \"string\" func = wordsearch() func2 = wordsearch(True) x = func(text, word) print(\"The result of function 1 plus 1 = {}\".format(x + 1)) func2(text, word) The output of the above script: ~$ python3 my_script.py The result of function 1 plus 1 = 4 3 Notice, what I'm doing is I have a function that takes a parameter of True or False. If it's True, then the function returns the wrapped function that prints the results of the wordsearch directly. If the parameter is false, it returns a function that returns the results of the wordsearch to the interpreter. The next step is you can create a function that takes a function as a parameter, wraps that function with some additional functionality and then returns that newly wrapped function. This is a great way to add functionality to a function without creating a brand new function. Let's take a look: my_script.py def word_search(text, word): \"\"\"This function returns True if the word is in the text, or False otherwise\"\"\" return word in text def lower_case_word_search(func): def wrapper(text, word): text = text.lower() word = word.lower() return func(text, word) return wrapper if __name__ == \"__main__\": text = \"This is a string with lots of Strings. Cat's like String.\" word = \"string\" print(word_search(text, word)) revised_search = lower_case_word_search(word_search()) print(revised_search(text, word)) Again, the output: ~$ python3 my_script.py 1 3 If you understand this notion of passing functions as parameters, returning functions, and wrapping functions with additional functionality by passing them through functions, then decorators are pretty easy. A decorator uses the @ symbol and references a function name. Take the code in the previous example. Let's say I wanted to add the lower case functionality to my word_search for the entire scope of my program. We can use a decorator to do so. decorator.py def lower_case_word_search(func): def wrapper(text, word): text = text.lower() word = word.lower() return func(text, word) return wrapper @lower_case_word_search def word_search(text, word): \"\"\"This function returns True if the word is in the text, or False otherwise\"\"\" return word in text The @lower_case_word_search wraps the following function word_search() in lower_case_word_search() . So, this example is the same as writing word_search = lower_case_word_search(word_search()) . From here on, any time we call word_search() it will be wrapped in the function that makes the strings lowercase first. If this doesn't make sense, read up on decorators, and feel free to chat with the instructor. But let's get back to routes.py app/routes.py from app import app @app.route('/') @app.route('/index') def index(): return \"Hello Flask!\" We're on the two lines that begin with the @ symbol. Each line references the route method that is part of the Flask class that we instantiated in __init__.py . The parameter that's being passed to route() is a URL rule that defines a URL endpoint that we add some functionality to. In other words, if our app is hosted at www.example.com then anytime our server receives a request to www.example.com or www.example.com/index the index function will be called, which returns \"Hello Flask!\" The rest of route() that's wrapping the index() function defined here, then takes that string (Hello Flask!), and builds an HTML page and sends it back to the client that made the request. Conclusion I wanted to add all of this detail to the instructions because I want you to think about the Python concepts that you can learn from building a Flask app. You'll notice that we've talked about a class (Flask), we've talked about instantiating it. We've talked about importing, and we've learned about decorators and the way that we use decorators in Flask to add our own functionality (index()) to functionality that's built into the framework (app.route()).","title":"11. Decorators"},{"location":"ch11/#back-to-flask","text":"","title":"Back to Flask"},{"location":"ch11/#one-more-background-lesson","text":"If you recall, our __init__.py file looked like this: app/__init__.py from flask import Flask app = Flask(__name__) @app.route('/') def hello_flask(): return 'Hello Flask!' You may have noticed the line @app.route('/') and wondered what was going on. What is happening is we are using what is called a decorator in Python. The @ symbol is a decorator. Here I want to take a moment to go into detail about how decorators work.","title":"One More Background Lesson"},{"location":"ch11/#decorators","text":"If you recall, functions can take parameters. Hopefully this is pretty clear to you at this point, but if not, it's worth a review. def word_frequency(word_list, text): out = {} for word in word_list: if word not in out.keys(): out[word] = text.count(word) return out This function takes two parameters: a word list and a text. I'd assume the first is a list of words and the second is a string. The point is these are flexible and they are the way that we pass data into a function. It's pretty obvious that primitive datatypes and also data structures can be passed into a function as a parameter, but that's not all. Functions can also take objects and functions as parameters. Here is an example of a function taking a function as a parameter: def say_hello(func): #1 print(\"Hello!\") func() #2 print(\"Goodbye!\") def sing_a_song(): #3 print(\"la la la la la!\") def greetings(): #4 print(\"It certainly is good to meet you!\") # Driver if __name__ == \"__main__\": say_hello(sing_a_song) #5 say_hello(greetings) #6 At #1, we are defining a function called say_hello that takes one parameter func , which we can assume is a function. At #2, the function that is passed in as a parameter is called or is executed. At #3, we define a simple function called sing_a_song that prints a string to the screen. At #4, we define a second simple function called greetings, which has the same functionality as sing_a_song, except it prints a different string. At #5, in our driver we call the function say_hello and pass it sing_a_song to its parameter. At #6, in our driver we call the function say_hello and pass it greetings to its parameter. You'll notice that like any parameter, a function parameter can receive any function. If you want, take a moment to type this into a file and run it. Here is the output. ~/$ python example.py Hello! la la la la la! Goodbye! Hello! It certainly is good to meet you! Goodbye! Just as we can pass a function to another function as a parameter, we can also have a function return another function or sub-function. my_script.py def wordsearch(print=False): def search(word, text): return text.count(word) def printer(word, text): print(text.count(word)) if print: return printer return search if __name__ == \"__main__\": text = \"This is a string with lots of strings. Cat's like string.\" word = \"string\" func = wordsearch() func2 = wordsearch(True) x = func(text, word) print(\"The result of function 1 plus 1 = {}\".format(x + 1)) func2(text, word) The output of the above script: ~$ python3 my_script.py The result of function 1 plus 1 = 4 3 Notice, what I'm doing is I have a function that takes a parameter of True or False. If it's True, then the function returns the wrapped function that prints the results of the wordsearch directly. If the parameter is false, it returns a function that returns the results of the wordsearch to the interpreter. The next step is you can create a function that takes a function as a parameter, wraps that function with some additional functionality and then returns that newly wrapped function. This is a great way to add functionality to a function without creating a brand new function. Let's take a look: my_script.py def word_search(text, word): \"\"\"This function returns True if the word is in the text, or False otherwise\"\"\" return word in text def lower_case_word_search(func): def wrapper(text, word): text = text.lower() word = word.lower() return func(text, word) return wrapper if __name__ == \"__main__\": text = \"This is a string with lots of Strings. Cat's like String.\" word = \"string\" print(word_search(text, word)) revised_search = lower_case_word_search(word_search()) print(revised_search(text, word)) Again, the output: ~$ python3 my_script.py 1 3 If you understand this notion of passing functions as parameters, returning functions, and wrapping functions with additional functionality by passing them through functions, then decorators are pretty easy. A decorator uses the @ symbol and references a function name. Take the code in the previous example. Let's say I wanted to add the lower case functionality to my word_search for the entire scope of my program. We can use a decorator to do so. decorator.py def lower_case_word_search(func): def wrapper(text, word): text = text.lower() word = word.lower() return func(text, word) return wrapper @lower_case_word_search def word_search(text, word): \"\"\"This function returns True if the word is in the text, or False otherwise\"\"\" return word in text The @lower_case_word_search wraps the following function word_search() in lower_case_word_search() . So, this example is the same as writing word_search = lower_case_word_search(word_search()) . From here on, any time we call word_search() it will be wrapped in the function that makes the strings lowercase first. If this doesn't make sense, read up on decorators, and feel free to chat with the instructor. But let's get back to routes.py app/routes.py from app import app @app.route('/') @app.route('/index') def index(): return \"Hello Flask!\" We're on the two lines that begin with the @ symbol. Each line references the route method that is part of the Flask class that we instantiated in __init__.py . The parameter that's being passed to route() is a URL rule that defines a URL endpoint that we add some functionality to. In other words, if our app is hosted at www.example.com then anytime our server receives a request to www.example.com or www.example.com/index the index function will be called, which returns \"Hello Flask!\" The rest of route() that's wrapping the index() function defined here, then takes that string (Hello Flask!), and builds an HTML page and sends it back to the client that made the request.","title":"Decorators"},{"location":"ch11/#conclusion","text":"I wanted to add all of this detail to the instructions because I want you to think about the Python concepts that you can learn from building a Flask app. You'll notice that we've talked about a class (Flask), we've talked about instantiating it. We've talked about importing, and we've learned about decorators and the way that we use decorators in Flask to add our own functionality (index()) to functionality that's built into the framework (app.route()).","title":"Conclusion"},{"location":"ch12/","text":"Adding some Templates Generally, when we do test-driven development, we are testing the functionality of our code rather than the value of constants that we might be using. Constants are values that are set or perhaps hard coded and do not change throughout the lifecycle of the application. For instance, if I have a user class and that user class generates a constant ID when it is instantiated, I won't check that the value of that ID is a particular value. On the other hand, if I have a function that retrieves the user ID, then I would test that that function does in fact return a user ID (even a particular value). The key is, I'm not testing the value itself, but rather the function's ability to return it. This will become a bit more clear as we go on. When we build Flask apps, generally we treat our templates as constant. They have variables, certainly, but we wouldn't want to write unittests that check for certain that the layout is a particular way. There are frameworks for testing user interfaces, but we're not going to get into that here. That being said, we do want to test that our Flask functions are working properly. So we're going to pick up our application again and start expanding it. At this point your file structure should look something like this: blog/ app/ __init__.py env/ tests/ blog_tests.py blog_web_tests.py requirements.txt app.py And the files that we have coded will look like this: app.py from app import app __init__.py from flask import Flask app = Flask(__name__) @app.rout('/') def hello_flask(): return 'Hello Flask!' blog_tests.py import unittest from app import app class TestBlog(unittest.TestCase): def setUp(self): self.client = app.test_client() def test_hello_flask(self): resp = self.client.get('/') self.assertEqual(b'Hello Flask!', resp.data) _blog_web_tests.py import unittest import requests class TestBlog(unittest.TestCase): def setUp(self): self.url = 'http://127.0.0.1:5000/' def test_hello_flask(self): resp = requests.get(self.url) self.assertIn('Hello Flask!', resp.text) My goal for this coding session is to create functionality in my app that returns a landing page for my website. The landing page needs to have a title. It should also have a menu structure. Maybe I also want to have a page heading that greets the user in a dynamic manner (meaning the greeting should change based on who is accessing the site), and a short blurb describing my website. I want to be able to use the test_client() to test my site, so I'll be abandoning the blog_web_tests.py file for a bit. I'll be refactoring the code so that my Flask function is no longer called hello_flask. Finally, I want to create a second route with a second template that will show a single blog post. For now, I'll be hard coding a bit of the data, but next time we'll use a form and database. Start a Template We're going to obey the testing goat and start by writing up a new test to test my landing page. I'm going to start pretty simple and test that the HTML is properly formed and that the title is correct. Since I'm refactoring, I'm going to remove the test that I'd built before and replace it. blog_tests.py import unittest from app import app class TestBlog(unittest.TestCase): def setUp(self): self.client = app.test_client() def test_home_page_returns(self): resp = self.client.get('/') self.assertEqual(200, resp.status_code) def test_home_page_returns_correct_html(self): resp = self.client.get('/') html = resp.data.decode('utf-8') self.assertTrue(html.startswith('<!DOCTYPE html>')) self.assertIn('<title>Fancy-Pants Blog</title>', html) self.assertTrue(html.endswith('</html>')) test_home_page_returns() The first test is a basic text to see if my route is working properly and returning the success status code. The bit of logic that is testing that is here: self.assertEqual(200, resp.status_code) test_home_page_returns_correct_html Now that I know that my route is returning the correct status code, I want to check that it's returning a properly formed html document. What this will test, since I know how my templates will work, is that the base.html and index.html are being assembled and rendered properly. This means that the page starts with <!DOCTYPE html> and ends with </html> . self.assertIn('<title>Fancy-Pants Blog</title>`, html) This second part of the test is useful because it is checking that the title content is being loaded by the Flask index() method. I run my tests next. Once again, we go to our trusty bash terminal, navigate to our project directory. Then activate our Virtual Environment and run our tests. It's worth noting that I run the tests from the blog directory (as opposed to changing into the tests directory). This helps make sure my app is found in the test. (env) ~/Projects/blog$ python -m unittest tests/blog_tests.py .F ====================================================================== FAIL: test_home_page_returns_correct_html (tests.blog_tests.TestBlog) ---------------------------------------------------------------------- Traceback (most recent call last): File \"Projects/blog/tests/blog_tests.py\", line 17, in test_home_page_returns_correct_html self.assertTrue(html.startswith('<!DOCTYPE html>')) AssertionError: False is not true ---------------------------------------------------------------------- Ran 2 tests in 0.004s FAILED (failures=1) We see that the first passes, which is to be expected because we already have an app that's responding. The second test fails, also as expected, because we don't have a template constructed yet and our route isn't returning any html at all. That's test driven development for you. We start with failing tests. The first thing I want to do to get my tests to pass is to create some new files and folders. I'll do this from the terminal, but you can create the files however you want. First, I need to make a templates directory inside of my app directory. This templates directory needs to be a sibling of wherever my app is located. If I had just written the app all in one file, I would put templates in the blog directory. When I tell Flask to render a template, it looks for them in a directory called templates that is a sibling of our app (so, __init__.py). (env) ~/Projects/blog$ ls app app.py env __pycache__ requirements.txt tests (env) ~/Projects/blog$ mkdir app/templates (env) ~/Projects/blog$ touch app/templates/base.html app/templates/index.html Second, I create two files called base.html and index.html . The base template is the masthead that will contain my header, footer, and all other content that will be repeated on every single page of the site. The index template will extend the base template and add specific content for the index page. The contents of the files are as follows: base.html <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>{{ title }}</title> </head> <body> {% block content %} {% endblock %} </body> </html> Notice that the base.html file contains the head and a variable for the title. We'll be filling that based on the page. The <title> element contains the text that is shown on the browser tab. The file also contains a block element for the content. In the future, we'll probably wrap that in a div that styles it, but for now, it's just an empty block of content. Next we need to write our index.html file. index.html {% extends 'base.html' %} {% block content %} <h1>Greetings!</h1> {% endblock %} Lovely, whatever is between the block called content and the end of that block will be populated into base.html where the corresponding tags are. You can do the same with menus or footers. Finally, we need to update our Flask app itself to render and return a template rather than a string. Fortunately, Flask has a method called render_template built in that allows us to render a particular template, which means to assemble the data and the template(s) into a single html document that will be sent over the network to the client. __init__.py from flask import Flask, render_template app = Flask(__name__) @app.route('/') @app.route('/index') def index(): title = 'Fancy-Pants Blog' return render_template('index.html', title=title) All that's left on this part is to run our tests. (env) Projects/blog$ python -m unittest tests/blog_tests.py .. ---------------------------------------------------------------------- Ran 2 tests in 0.007s OK Add a menu Menus for websites are usually unordered lists with links attached to them. Ordinarily and unordered list looks like this: Item One Item Two Item Three or <ul> <li>Item One</li> <li>Item Two</li> <li>Item Three</li> </ul> but a menu list is styled to make it look like a menu: Item One Item Two Item Three #sample-menu { list-style-type: none; margin: 0; padding: 0; overflow: hidden; background-color: #333333; } #sample-menu li { float: left; } #sample-menu li a { display: block; color: white; text-align: center; padding: 16px; text-decoration: none; } #sample-menu li a:hover { background-color: #111111; } Here are the style rules that turn the same html list into a menu. #sample-menu { list-style-type: none; margin: 0; padding: 0; overflow: hidden; background-color: #333333; } #sample-menu li { float: left; } #sample-menu li a { display: block; color: white; text-align: center; padding: 16px; text-decoration: none; } #sample-menu li a:hover { background-color: #111111; } For now, however, we don't need to worry about making a nicely styled menu. Let's just make a list that will become our navigation bar menu later on. I also want my menu to be a bit dynamic just because I want to be able to adjust how many menu links I have from my Flask app. So I'm going to write my test first. blog_tests.py from bs4 import BeautifulSoup import unittest from app import app class TestBlog(unittest.TestCase): def setUp(self): self.client = app.test_client() def test_home_page_returns(self): resp = self.client.get('/') self.assertEqual(200, resp.status_code) def test_home_page_returns_correct_html(self): resp = self.client.get('/') html = resp.data.decode('utf-8') self.assertTrue(html.startswith('<!DOCTYPE html>')) self.assertIn('<title>Fancy-Pants Blog</title>', html) self.assertTrue(html.endswith('</html>')) def test_menu(self): resp = self.client.get('/') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') menu = [link.get_text() for link in soup.select('.menu-item')] self.assertListEqual(['About', 'CV', 'Blog'], menu) from bs4 import BeautifulSoup It's much nicer to deal with html if I use a parser. Beautiful Soup is an excellent parser for html (and xml). I'm using that to extract the text from the menu links. You'll see I'm then able to assert two lists equal to each other without all the extra html tags. test_menu() You'll see that the test is a little bit longer and requires a bit of extra setup. First I get the html response and decode it. Then I parse it with Beautiful Soup. This creates a soup object that I can search efficiently. menu = [link.get_text() for link in soup.select('.menu-item')] is a bit of Python magic. I'm using a list generator, and what this says is iterate through all of the elements in the html that have the class 'menu-item'. For each of those, get the text (whatever content is inside of the tags), and add it to a list, which is then stored to a variable called menu. Of course, this fails, gloriously: (env) ~/Projects/blog$ python -m unittest tests/blog_tests.py ..F ====================================================================== FAIL: test_menu_text (tests.blog_tests.TestBlog) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/Projects/blog/tests/blog_tests.py\", line 27, in test_menu_text self.assertListEqual(['About', 'CV', 'Blog'], menu) AssertionError: Lists differ: ['About', 'CV', 'Blog'] != [] First list contains 3 additional elements. First extra element 0: 'About' - ['About', 'CV', 'Blog'] + [] ---------------------------------------------------------------------- Ran 3 tests in 0.009s FAILED (failures=1) Next, I want to write a test that checks to see if each of the menu items is a link to a particular address. Menu addresses usually use relative paths so https://example.com/blog might have the address <a href='blog'> . I want to check these also because my function needs to build this menu dynamically. So I'll create the test for that now, too. blog_tests.py from bs4 import BeautifulSoup import unittest from app import app class TestBlog(unittest.TestCase): def setUp(self): self.client = app.test_client() def test_home_page_returns(self): resp = self.client.get('/') self.assertEqual(200, resp.status_code) def test_home_page_returns_correct_html(self): resp = self.client.get('/') html = resp.data.decode('utf-8') self.assertTrue(html.startswith('<!DOCTYPE html>')) self.assertIn('<title>Fancy-Pants Blog</title>', html) self.assertTrue(html.endswith('</html>')) def test_menu_text(self): resp = self.client.get('/') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') menu = [link.get_text() for link in soup.select('.menu-item')] self.assertListEqual(['About', 'CV', 'Blog'], menu) def test_menu_links(self): resp = self.client.get('/') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') menu = [link.get('href') for link in soup.select('.menu-item a')] self.assertListEqual(['about', 'cv', 'blog'], menu) The only difference in the test_menu_links and test_menu_test is that in the former I get the <a> element and extract the href, and the latter I extract the text. The results of the tests are about the same: (env) ~/Projects/blog$ python -m unittest tests/blog_tests.py ..FF ====================================================================== FAIL: test_menu_links (tests.blog_tests.TestBlog) ---------------------------------------------------------------------- Traceback (most recent call last): File \"blog/tests/blog_tests.py\", line 34, in test_menu_links self.assertListEqual(['about', 'cv', 'blog'], menu) AssertionError: Lists differ: ['about', 'cv', 'blog'] != [] First list contains 3 additional elements. First extra element 0: 'about' - ['about', 'cv', 'blog'] + [] ====================================================================== FAIL: test_menu_text (tests.blog_tests.TestBlog) ---------------------------------------------------------------------- Traceback (most recent call last): File \"blog/tests/blog_tests.py\", line 27, in test_menu_text self.assertListEqual(['About', 'CV', 'Blog'], menu) AssertionError: Lists differ: ['About', 'CV', 'Blog'] != [] First list contains 3 additional elements. First extra element 0: 'About' - ['About', 'CV', 'Blog'] + [] ---------------------------------------------------------------------- Ran 4 tests in 0.125s FAILED (failures=2) We're failing in the right way so now I need to add the links and the text for a menu system. I could hardcode these into my base.html file, but I'd rather make those dynamic. Perhaps I want to make this generic so I can create different menus if I want to reuse this code in the future. Perhaps I want to allow my menu to adjust dynamically, or in th future, I might create an administrator console that allows the user to adjust the menu without altering the code. So, I'm going to first adjust my template: base.html <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>{{ data.title }}</title> </head> <body> <ul> {% for item in data.menu %} <li class=\"menu-item\"><a href=\"{{ item.link }}\">{{ item.text }}</a></li> {% endfor %} </ul> {% block content %} {% endblock %} </body> </html> First you'll notice that I changed the variable for the title into data.title. This means that I'll be putting all of my data into a single object before shipping it to my templates, so data is going to be a dictionary with \"title\" as one of the keys. You'll also notice that I'm accessing the \"menu\" key of the data dictionary. I know this will be a list of menu items, so I use a for loop to iterate through those. For each menu item, I add the link and the text values. Finally, I need to modify my index() method from my app so that it passes the appropriate data to the template. As you will see, I've created a data dictionary that conforms to what my template is expecting. __init__.py from flask import Flask, render_template app = Flask(__name__) @app.route('/') @app.route('/index') def index(): data = { 'title': 'Fancy-Pants Blog', 'menu': [ { 'link': 'about', 'text': 'About' }, { 'link' : 'cv', 'text': 'CV' }, { 'link' : 'blog', 'text' : 'Blog' } ] } return render_template('index.html', data=data) It's not a massive change except I created the data dictionary instead of a title variable. Also, I'm passing all the data to the template as one parameter. I could technically pass a bunch of keyword/argument pairs to the render_template function but it's easier for me to keep track of if I bundle all the data together. Now my tests pass: (env) ~/Projects/blog$ python -m unittest tests/blog_tests.py .... ---------------------------------------------------------------------- Ran 4 tests in 0.011s OK Finally, I want to set up so that I have a heading on my landing page that says, either \"Hello Stranger\" or \"Hello some name\" depending on whether a name has been added to the url. So https://localhost/dylan should say \"Hello dylan.\" Let's write our unit test first. blog_tests.py from bs4 import BeautifulSoup import unittest from app import app class TestBlog(unittest.TestCase): def setUp(self): self.client = app.test_client() def test_home_page_returns(self): resp = self.client.get('/') self.assertEqual(200, resp.status_code) def test_home_page_returns_correct_html(self): resp = self.client.get('/') html = resp.data.decode('utf-8') self.assertTrue(html.startswith('<!DOCTYPE html>')) self.assertIn('<title>Fancy-Pants Blog</title>', html) self.assertTrue(html.endswith('</html>')) def test_menu_text(self): resp = self.client.get('/') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') menu = [link.get_text() for link in soup.select('.menu-item')] self.assertListEqual(['About', 'CV', 'Blog'], menu) def test_menu_links(self): resp = self.client.get('/') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') menu = [link.get('href') for link in soup.select('.menu-item a')] self.assertListEqual(['about', 'cv', 'blog'], menu) def test_heading_no_name(self): resp = self.client.get('/') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') head = soup.h1.get_text() self.assertEqual('Hello Stranger', head) def test_heading_name(self): resp = self.client.get('/Dylan') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') head = soup.h1.get_text() self.assertEqual('Hello Dylan', head) You'll notice I'm getting the text of the <h1> element. Now I know that my template will need that element, and I know I want to add it only to the index.html page. I also know that that tag will require some flow control. index.html {% extends 'base.html' %} {% block content %} {% if name %} <h1>Hello {{ name }}</h1> {% else %} <h1>Hello Stranger</h1> {% endif %} {% endblock %} Finally, we need to adjust our index() method a bit to take the parameter off of the URL. There is much you could learn about URL encoding, but we're not going to much into it here. __init__.py from flask import Flask, render_template app = Flask(__name__) @app.route('/') @app.route('/<name>') def index(name = None): data = { 'title': 'Fancy-Pants Blog', 'menu': [ { 'link': 'about', 'text': 'About' }, { 'link' : 'cv', 'text': 'CV' }, { 'link' : 'blog', 'text' : 'Blog' } ] } return render_template('index.html', data=data, name=name) Here and in the template above, I'm adding an additional keyword value pair for the parameters to render_template. I could also bundle the title into the data object, but adding an extra parameter maybe makes it easier to see. You'll notice that I don't need to specify which template gets which piece of data. As long as I'm using good, unique names for each variable, render_template is smart enough to sort all of that out. Now run my test and we see: (env) ~/Projects/blog$ python -m unittest tests/blog_tests.py ...... ---------------------------------------------------------------------- Ran 6 tests in 0.014s OK Great! My app is working successfully. Hopefully, you have a better sense of how templates work and how we can write unit tests to test our templates. It's worth noting that the content of the templates that I'm testing is that which is generated dynamically by my functions. I'm not testing any constant content that is hardcoded into the html. Next chapter, we're going to learn how to create forms, and then in the following chapter we'll learn how to store data in a database.","title":"12. Templates the TDD Way"},{"location":"ch12/#adding-some-templates","text":"Generally, when we do test-driven development, we are testing the functionality of our code rather than the value of constants that we might be using. Constants are values that are set or perhaps hard coded and do not change throughout the lifecycle of the application. For instance, if I have a user class and that user class generates a constant ID when it is instantiated, I won't check that the value of that ID is a particular value. On the other hand, if I have a function that retrieves the user ID, then I would test that that function does in fact return a user ID (even a particular value). The key is, I'm not testing the value itself, but rather the function's ability to return it. This will become a bit more clear as we go on. When we build Flask apps, generally we treat our templates as constant. They have variables, certainly, but we wouldn't want to write unittests that check for certain that the layout is a particular way. There are frameworks for testing user interfaces, but we're not going to get into that here. That being said, we do want to test that our Flask functions are working properly. So we're going to pick up our application again and start expanding it. At this point your file structure should look something like this: blog/ app/ __init__.py env/ tests/ blog_tests.py blog_web_tests.py requirements.txt app.py And the files that we have coded will look like this: app.py from app import app __init__.py from flask import Flask app = Flask(__name__) @app.rout('/') def hello_flask(): return 'Hello Flask!' blog_tests.py import unittest from app import app class TestBlog(unittest.TestCase): def setUp(self): self.client = app.test_client() def test_hello_flask(self): resp = self.client.get('/') self.assertEqual(b'Hello Flask!', resp.data) _blog_web_tests.py import unittest import requests class TestBlog(unittest.TestCase): def setUp(self): self.url = 'http://127.0.0.1:5000/' def test_hello_flask(self): resp = requests.get(self.url) self.assertIn('Hello Flask!', resp.text) My goal for this coding session is to create functionality in my app that returns a landing page for my website. The landing page needs to have a title. It should also have a menu structure. Maybe I also want to have a page heading that greets the user in a dynamic manner (meaning the greeting should change based on who is accessing the site), and a short blurb describing my website. I want to be able to use the test_client() to test my site, so I'll be abandoning the blog_web_tests.py file for a bit. I'll be refactoring the code so that my Flask function is no longer called hello_flask. Finally, I want to create a second route with a second template that will show a single blog post. For now, I'll be hard coding a bit of the data, but next time we'll use a form and database.","title":"Adding some Templates"},{"location":"ch12/#start-a-template","text":"We're going to obey the testing goat and start by writing up a new test to test my landing page. I'm going to start pretty simple and test that the HTML is properly formed and that the title is correct. Since I'm refactoring, I'm going to remove the test that I'd built before and replace it. blog_tests.py import unittest from app import app class TestBlog(unittest.TestCase): def setUp(self): self.client = app.test_client() def test_home_page_returns(self): resp = self.client.get('/') self.assertEqual(200, resp.status_code) def test_home_page_returns_correct_html(self): resp = self.client.get('/') html = resp.data.decode('utf-8') self.assertTrue(html.startswith('<!DOCTYPE html>')) self.assertIn('<title>Fancy-Pants Blog</title>', html) self.assertTrue(html.endswith('</html>')) test_home_page_returns() The first test is a basic text to see if my route is working properly and returning the success status code. The bit of logic that is testing that is here: self.assertEqual(200, resp.status_code) test_home_page_returns_correct_html Now that I know that my route is returning the correct status code, I want to check that it's returning a properly formed html document. What this will test, since I know how my templates will work, is that the base.html and index.html are being assembled and rendered properly. This means that the page starts with <!DOCTYPE html> and ends with </html> . self.assertIn('<title>Fancy-Pants Blog</title>`, html) This second part of the test is useful because it is checking that the title content is being loaded by the Flask index() method. I run my tests next. Once again, we go to our trusty bash terminal, navigate to our project directory. Then activate our Virtual Environment and run our tests. It's worth noting that I run the tests from the blog directory (as opposed to changing into the tests directory). This helps make sure my app is found in the test. (env) ~/Projects/blog$ python -m unittest tests/blog_tests.py .F ====================================================================== FAIL: test_home_page_returns_correct_html (tests.blog_tests.TestBlog) ---------------------------------------------------------------------- Traceback (most recent call last): File \"Projects/blog/tests/blog_tests.py\", line 17, in test_home_page_returns_correct_html self.assertTrue(html.startswith('<!DOCTYPE html>')) AssertionError: False is not true ---------------------------------------------------------------------- Ran 2 tests in 0.004s FAILED (failures=1) We see that the first passes, which is to be expected because we already have an app that's responding. The second test fails, also as expected, because we don't have a template constructed yet and our route isn't returning any html at all. That's test driven development for you. We start with failing tests. The first thing I want to do to get my tests to pass is to create some new files and folders. I'll do this from the terminal, but you can create the files however you want. First, I need to make a templates directory inside of my app directory. This templates directory needs to be a sibling of wherever my app is located. If I had just written the app all in one file, I would put templates in the blog directory. When I tell Flask to render a template, it looks for them in a directory called templates that is a sibling of our app (so, __init__.py). (env) ~/Projects/blog$ ls app app.py env __pycache__ requirements.txt tests (env) ~/Projects/blog$ mkdir app/templates (env) ~/Projects/blog$ touch app/templates/base.html app/templates/index.html Second, I create two files called base.html and index.html . The base template is the masthead that will contain my header, footer, and all other content that will be repeated on every single page of the site. The index template will extend the base template and add specific content for the index page. The contents of the files are as follows: base.html <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>{{ title }}</title> </head> <body> {% block content %} {% endblock %} </body> </html> Notice that the base.html file contains the head and a variable for the title. We'll be filling that based on the page. The <title> element contains the text that is shown on the browser tab. The file also contains a block element for the content. In the future, we'll probably wrap that in a div that styles it, but for now, it's just an empty block of content. Next we need to write our index.html file. index.html {% extends 'base.html' %} {% block content %} <h1>Greetings!</h1> {% endblock %} Lovely, whatever is between the block called content and the end of that block will be populated into base.html where the corresponding tags are. You can do the same with menus or footers. Finally, we need to update our Flask app itself to render and return a template rather than a string. Fortunately, Flask has a method called render_template built in that allows us to render a particular template, which means to assemble the data and the template(s) into a single html document that will be sent over the network to the client. __init__.py from flask import Flask, render_template app = Flask(__name__) @app.route('/') @app.route('/index') def index(): title = 'Fancy-Pants Blog' return render_template('index.html', title=title) All that's left on this part is to run our tests. (env) Projects/blog$ python -m unittest tests/blog_tests.py .. ---------------------------------------------------------------------- Ran 2 tests in 0.007s OK","title":"Start a Template"},{"location":"ch12/#add-a-menu","text":"Menus for websites are usually unordered lists with links attached to them. Ordinarily and unordered list looks like this: Item One Item Two Item Three or <ul> <li>Item One</li> <li>Item Two</li> <li>Item Three</li> </ul> but a menu list is styled to make it look like a menu: Item One Item Two Item Three #sample-menu { list-style-type: none; margin: 0; padding: 0; overflow: hidden; background-color: #333333; } #sample-menu li { float: left; } #sample-menu li a { display: block; color: white; text-align: center; padding: 16px; text-decoration: none; } #sample-menu li a:hover { background-color: #111111; } Here are the style rules that turn the same html list into a menu. #sample-menu { list-style-type: none; margin: 0; padding: 0; overflow: hidden; background-color: #333333; } #sample-menu li { float: left; } #sample-menu li a { display: block; color: white; text-align: center; padding: 16px; text-decoration: none; } #sample-menu li a:hover { background-color: #111111; } For now, however, we don't need to worry about making a nicely styled menu. Let's just make a list that will become our navigation bar menu later on. I also want my menu to be a bit dynamic just because I want to be able to adjust how many menu links I have from my Flask app. So I'm going to write my test first. blog_tests.py from bs4 import BeautifulSoup import unittest from app import app class TestBlog(unittest.TestCase): def setUp(self): self.client = app.test_client() def test_home_page_returns(self): resp = self.client.get('/') self.assertEqual(200, resp.status_code) def test_home_page_returns_correct_html(self): resp = self.client.get('/') html = resp.data.decode('utf-8') self.assertTrue(html.startswith('<!DOCTYPE html>')) self.assertIn('<title>Fancy-Pants Blog</title>', html) self.assertTrue(html.endswith('</html>')) def test_menu(self): resp = self.client.get('/') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') menu = [link.get_text() for link in soup.select('.menu-item')] self.assertListEqual(['About', 'CV', 'Blog'], menu) from bs4 import BeautifulSoup It's much nicer to deal with html if I use a parser. Beautiful Soup is an excellent parser for html (and xml). I'm using that to extract the text from the menu links. You'll see I'm then able to assert two lists equal to each other without all the extra html tags. test_menu() You'll see that the test is a little bit longer and requires a bit of extra setup. First I get the html response and decode it. Then I parse it with Beautiful Soup. This creates a soup object that I can search efficiently. menu = [link.get_text() for link in soup.select('.menu-item')] is a bit of Python magic. I'm using a list generator, and what this says is iterate through all of the elements in the html that have the class 'menu-item'. For each of those, get the text (whatever content is inside of the tags), and add it to a list, which is then stored to a variable called menu. Of course, this fails, gloriously: (env) ~/Projects/blog$ python -m unittest tests/blog_tests.py ..F ====================================================================== FAIL: test_menu_text (tests.blog_tests.TestBlog) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/Projects/blog/tests/blog_tests.py\", line 27, in test_menu_text self.assertListEqual(['About', 'CV', 'Blog'], menu) AssertionError: Lists differ: ['About', 'CV', 'Blog'] != [] First list contains 3 additional elements. First extra element 0: 'About' - ['About', 'CV', 'Blog'] + [] ---------------------------------------------------------------------- Ran 3 tests in 0.009s FAILED (failures=1) Next, I want to write a test that checks to see if each of the menu items is a link to a particular address. Menu addresses usually use relative paths so https://example.com/blog might have the address <a href='blog'> . I want to check these also because my function needs to build this menu dynamically. So I'll create the test for that now, too. blog_tests.py from bs4 import BeautifulSoup import unittest from app import app class TestBlog(unittest.TestCase): def setUp(self): self.client = app.test_client() def test_home_page_returns(self): resp = self.client.get('/') self.assertEqual(200, resp.status_code) def test_home_page_returns_correct_html(self): resp = self.client.get('/') html = resp.data.decode('utf-8') self.assertTrue(html.startswith('<!DOCTYPE html>')) self.assertIn('<title>Fancy-Pants Blog</title>', html) self.assertTrue(html.endswith('</html>')) def test_menu_text(self): resp = self.client.get('/') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') menu = [link.get_text() for link in soup.select('.menu-item')] self.assertListEqual(['About', 'CV', 'Blog'], menu) def test_menu_links(self): resp = self.client.get('/') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') menu = [link.get('href') for link in soup.select('.menu-item a')] self.assertListEqual(['about', 'cv', 'blog'], menu) The only difference in the test_menu_links and test_menu_test is that in the former I get the <a> element and extract the href, and the latter I extract the text. The results of the tests are about the same: (env) ~/Projects/blog$ python -m unittest tests/blog_tests.py ..FF ====================================================================== FAIL: test_menu_links (tests.blog_tests.TestBlog) ---------------------------------------------------------------------- Traceback (most recent call last): File \"blog/tests/blog_tests.py\", line 34, in test_menu_links self.assertListEqual(['about', 'cv', 'blog'], menu) AssertionError: Lists differ: ['about', 'cv', 'blog'] != [] First list contains 3 additional elements. First extra element 0: 'about' - ['about', 'cv', 'blog'] + [] ====================================================================== FAIL: test_menu_text (tests.blog_tests.TestBlog) ---------------------------------------------------------------------- Traceback (most recent call last): File \"blog/tests/blog_tests.py\", line 27, in test_menu_text self.assertListEqual(['About', 'CV', 'Blog'], menu) AssertionError: Lists differ: ['About', 'CV', 'Blog'] != [] First list contains 3 additional elements. First extra element 0: 'About' - ['About', 'CV', 'Blog'] + [] ---------------------------------------------------------------------- Ran 4 tests in 0.125s FAILED (failures=2) We're failing in the right way so now I need to add the links and the text for a menu system. I could hardcode these into my base.html file, but I'd rather make those dynamic. Perhaps I want to make this generic so I can create different menus if I want to reuse this code in the future. Perhaps I want to allow my menu to adjust dynamically, or in th future, I might create an administrator console that allows the user to adjust the menu without altering the code. So, I'm going to first adjust my template: base.html <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>{{ data.title }}</title> </head> <body> <ul> {% for item in data.menu %} <li class=\"menu-item\"><a href=\"{{ item.link }}\">{{ item.text }}</a></li> {% endfor %} </ul> {% block content %} {% endblock %} </body> </html> First you'll notice that I changed the variable for the title into data.title. This means that I'll be putting all of my data into a single object before shipping it to my templates, so data is going to be a dictionary with \"title\" as one of the keys. You'll also notice that I'm accessing the \"menu\" key of the data dictionary. I know this will be a list of menu items, so I use a for loop to iterate through those. For each menu item, I add the link and the text values. Finally, I need to modify my index() method from my app so that it passes the appropriate data to the template. As you will see, I've created a data dictionary that conforms to what my template is expecting. __init__.py from flask import Flask, render_template app = Flask(__name__) @app.route('/') @app.route('/index') def index(): data = { 'title': 'Fancy-Pants Blog', 'menu': [ { 'link': 'about', 'text': 'About' }, { 'link' : 'cv', 'text': 'CV' }, { 'link' : 'blog', 'text' : 'Blog' } ] } return render_template('index.html', data=data) It's not a massive change except I created the data dictionary instead of a title variable. Also, I'm passing all the data to the template as one parameter. I could technically pass a bunch of keyword/argument pairs to the render_template function but it's easier for me to keep track of if I bundle all the data together. Now my tests pass: (env) ~/Projects/blog$ python -m unittest tests/blog_tests.py .... ---------------------------------------------------------------------- Ran 4 tests in 0.011s OK Finally, I want to set up so that I have a heading on my landing page that says, either \"Hello Stranger\" or \"Hello some name\" depending on whether a name has been added to the url. So https://localhost/dylan should say \"Hello dylan.\" Let's write our unit test first. blog_tests.py from bs4 import BeautifulSoup import unittest from app import app class TestBlog(unittest.TestCase): def setUp(self): self.client = app.test_client() def test_home_page_returns(self): resp = self.client.get('/') self.assertEqual(200, resp.status_code) def test_home_page_returns_correct_html(self): resp = self.client.get('/') html = resp.data.decode('utf-8') self.assertTrue(html.startswith('<!DOCTYPE html>')) self.assertIn('<title>Fancy-Pants Blog</title>', html) self.assertTrue(html.endswith('</html>')) def test_menu_text(self): resp = self.client.get('/') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') menu = [link.get_text() for link in soup.select('.menu-item')] self.assertListEqual(['About', 'CV', 'Blog'], menu) def test_menu_links(self): resp = self.client.get('/') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') menu = [link.get('href') for link in soup.select('.menu-item a')] self.assertListEqual(['about', 'cv', 'blog'], menu) def test_heading_no_name(self): resp = self.client.get('/') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') head = soup.h1.get_text() self.assertEqual('Hello Stranger', head) def test_heading_name(self): resp = self.client.get('/Dylan') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') head = soup.h1.get_text() self.assertEqual('Hello Dylan', head) You'll notice I'm getting the text of the <h1> element. Now I know that my template will need that element, and I know I want to add it only to the index.html page. I also know that that tag will require some flow control. index.html {% extends 'base.html' %} {% block content %} {% if name %} <h1>Hello {{ name }}</h1> {% else %} <h1>Hello Stranger</h1> {% endif %} {% endblock %} Finally, we need to adjust our index() method a bit to take the parameter off of the URL. There is much you could learn about URL encoding, but we're not going to much into it here. __init__.py from flask import Flask, render_template app = Flask(__name__) @app.route('/') @app.route('/<name>') def index(name = None): data = { 'title': 'Fancy-Pants Blog', 'menu': [ { 'link': 'about', 'text': 'About' }, { 'link' : 'cv', 'text': 'CV' }, { 'link' : 'blog', 'text' : 'Blog' } ] } return render_template('index.html', data=data, name=name) Here and in the template above, I'm adding an additional keyword value pair for the parameters to render_template. I could also bundle the title into the data object, but adding an extra parameter maybe makes it easier to see. You'll notice that I don't need to specify which template gets which piece of data. As long as I'm using good, unique names for each variable, render_template is smart enough to sort all of that out. Now run my test and we see: (env) ~/Projects/blog$ python -m unittest tests/blog_tests.py ...... ---------------------------------------------------------------------- Ran 6 tests in 0.014s OK Great! My app is working successfully. Hopefully, you have a better sense of how templates work and how we can write unit tests to test our templates. It's worth noting that the content of the templates that I'm testing is that which is generated dynamically by my functions. I'm not testing any constant content that is hardcoded into the html. Next chapter, we're going to learn how to create forms, and then in the following chapter we'll learn how to store data in a database.","title":"Add a menu"},{"location":"ch13/","text":"Forms In the last couple of chapters, we have coverd HTML and Flask Templates. These allow us to create user interfaces, or web pages at least, that are rendered by the web browser into something that looks a little better than just simple strings of text. These imagine the user as a consumer of content, but we want to do more than this. For our user interface or our frontend, we really want the user to be able to interact with our application. As with any user-facing program, interaction is about allowing the user to provide some sort of input, performing an action, and returning some sort of output that responds to that input. When you post on social media, for instance, you are providing input (text or a picture), which is sent to the application server. That input is then added to the stream or your wall or wherever that particular social media application shares the input. On Facebook, users input text and images in a form on the main application. That is then posted to the user's \"wall.\" The main way that web applications receive data is through forms that are included in the user interface. CRUD Many websites allow users to add content. Anything from a blogging platform to social media and so on. These websites frequently follow the CRUD design pattern, which stands for \"Create,\" \"Read,\" \"Update,\" and \"Delete.\" Each of these represents a function that a user can perform. The Create functionality allows users to create some content that is saved by the website, probably in a database. The Read functionality allows the user to retrieve a specific bit of content from the website. The Update functionality allows the user to change something about content they have already added (e.g. when you edit a post on Facebook that has already been posted). Finally, the Delete functionality allows the user to remove content from the website. Usually the site will have some access control throught authentication to prevent unauthorized users from altering or deleting (or even creating) data that is saved by the application. If an application allows the users to add content then their will be a couple of components that are necessary to the application that are not built into Flask by default. First is Forms and the second is databases or data storage technologies. Forms are HTML elements that give the user specific types of fields to provide input. Databases are storage technologies that organize and store content that has been submitted to the application. HTML Forms HTML forms are rendered by the browser to give the user a place to input data. At its most basic, an HTML form is comprised of three types of tags: <form> , <input> , and <label> tags. The first is a block level element, meaning it defines a block of space on the screen that spans form left to right margin of its container. The next two are inline elements that give the user a field to input data and a label to help screenreaders identify a particular input. Here is a basic example and the html code. <form action=\"/login\" method=\"post\"> <label for=\"username\">Username:</label><br> <input type=\"text\" id=\"username\" name=\"username\"><br> <label for=\"password\">Password:</label><br> <input type=\"password\" id=\"password\" name=\"password\"><br> <input type=\"submit\" value=\"submit\"> </form> Username: Password: There are plenty of excellent tutorials on HTML that will help you learn about all of the features of HTML forms, and so I am not going to repeat that here. In short, the form, when submitted, will send whatever data is in the input fields (keyed to the input name) to the action (another route) via the POST method. It is entirely possible for us to create forms in our templates when we use Flask. However, you'll see as we go through Flask that it is sometimes better to use a library rather than building something from scratch. This is because, first, we don't want to reinvent the wheel. Second, if the library is well maintained and has been around for a bit, it will probably be a bit more reliable than what we could build ourselves because it has had many eyes looking at it and debugging it. Beyond the concern of repeating code that already works just fine, dealing with forms, and really accepting any user input, can pose security concerns. In the early days of dynamic websites, it was possible, for example, to send a SQL statement that either returned the entire contents of a database or even deleted the entire contents of a database through a webform. If the developer didn't include a bunch of processing to prevent it, those commands would be executed. When we use libraries to manage our forms for us, we can feel pretty confident (especially if we've read the documentation and the code) that the libraries are dealing with those security concerns for us behind the scenes. That is the case with Flask-WTF. Enter WTForms and Flask-WTF Instead of writing our forms in our templates, we wil be using Flask-WTF to help us build forms. I encourage you to take a moment and read the documentation. Instead of us building the forms in HTML, we add a form to our application we create a Form class that will then be rendered into our template at runtime. To get started with Flask-WTF and our forms, I want to create a new test that will at least check to see that my form is being rendered. blog_tests.py from bs4 import BeautifulSoup import unittest from app import app class TestBlog(unittest.TestCase): def setUp(self): self.client = app.test_client() def test_home_page_returns(self): resp = self.client.get('/') self.assertEqual(200, resp.status_code) def test_home_page_returns_correct_html(self): resp = self.client.get('/') html = resp.data.decode('utf-8') self.assertTrue(html.startswith('<!DOCTYPE html>')) self.assertIn('<title>Fancy-Pants Blog</title>', html) self.assertTrue(html.endswith('</html>')) def test_menu_text(self): resp = self.client.get('/') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') menu = [link.get_text() for link in soup.select('.menu-item')] self.assertListEqual(['About', 'CV', 'Blog'], menu) def test_menu_links(self): resp = self.client.get('/') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') menu = [link.get('href') for link in soup.select('.menu-item a')] self.assertListEqual(['about', 'cv', 'blog'], menu) def test_heading_no_name(self): resp = self.client.get('/') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') head = soup.h1.get_text() self.assertEqual('Hello Stranger', head) def test_heading_name(self): resp = self.client.get('/Dylan') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') head = soup.h1.get_text() self.assertEqual('Hello Dylan', head) def test_blog_post_page(self): resp = self.client.get('/blog') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') heading = soup.h1.get_text() self.assertEqual(heading, 'Blog Posts') def test_blog_post(self): resp = self.client.get('/blog') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') head = soup.h1.get_text() self.assertEqual('Hello Dylan', head) def test_form(self): resp = self.client.get('/post') html = resp.data.decode('utf-8') self.assertIn('<form method=\"post\">', html) self.assertIn('</form>', html) def test_form_fields(self): resp = self.client.get('/post') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') fields = [i.attrs['name'] for i in soup.find_all('input')] self.assertListEqual(fields[1:], ['post_title', 'author', 'submit']) self.assertEqual(soup.textarea.attrs['name'], 'text') test_form() This test checks to make sure that the opening and closing form tags are present in the response. This is a pretty simple test. test_form_fields() I also want to test that my form has the expected fields. I am testing by name because that will also ensure that they are valid fields. I run those tests, and of course they are failing as to be expected: (env) ~/Projects/blog$ python -m unittest tests/blog_tests.py FF...... ====================================================================== FAIL: test_form (tests.blog_tests.TestBlog) ---------------------------------------------------------------------- Traceback (most recent call last): File \"~/Projects/blog/tests/blog_tests.py\", line 53, in test_form self.assertIn('<form>', html) AssertionError: '<form>' not found in '<!DOCTYPE html>\\n<html lang=\"en\">\\n<head>\\n <meta charset=\"UTF-8\">\\n <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\\n <title>Fancy-Pants Blog</title>\\n</head>\\n<body>\\n <ul>\\n \\n <li class=\"menu-item\"><a href=\"about\">About</a></li>\\n \\n <li class=\"menu-item\"><a href=\"cv\">CV</a></li>\\n \\n <li class=\"menu-item\"><a href=\"blog\">Blog</a></li>\\n \\n </ul>\\n \\n\\n<h1>Hello post</h1>\\n\\n\\n</body>\\n</html>' ====================================================================== FAIL: test_form_fields (tests.blog_tests.TestBlog) ---------------------------------------------------------------------- Traceback (most recent call last): File \"~/Projects/blog/tests/blog_tests.py\", line 61, in test_form_fields self.assertListEqual(fields, ['title', 'author', 'text']) AssertionError: Lists differ: [] != ['title', 'author', 'text'] Second list contains 3 additional elements. First extra element 0: 'title' - [] + ['title', 'author', 'text'] ---------------------------------------------------------------------- Ran 8 tests in 0.032s FAILED (failures=2) Now we need to do some setup. First we will need to install Flask-WTF and create a file where our forms will live. (env) ~/Projects/blog$ pip install Flask-WTF (env) ~/Projects/blog$ touch app/forms.py Now we'll create our first form. This form will accept a title, an author name, and a text area in which the user could enter a blog post. forms.py from flask_wtf import FlaskForm from wtforms import StringField, TextAreaField, SubmitField from wtforms.validators import DataRequired class NewEntryForm(FlaskForm): post_title = StringField('Title', validators=[DataRequired()]) author = StringField('Author', validators=[DataRequired()]) text = TextAreaField('Text', validators=[DataRequired()]) submit = SubmitField('Submit') import statments You'll notice that we are importing a bunch of different things from flask_wtf and wtforms. The FlaskForm is a class that we will be extending. It is a wrapper that allows Flask to use WTForms easily. Second, there are imports from wtforms that include the field classes and the validators for those fields. When we instantiate each of this, we create a field that will be rendered into an HTML input. class NewEntryForm(FlaskForm) This is how we extend a class in Python. Our NewEntryForm class gains all of the methods and properties of the FlaskForm. The Fields Each of these fields (title, author, text, submit) are instances of classes from wtforms. They have a corresponding input type in HTML. The first parameter is the label for the field, which helps screen readers. The validators are automatically run. This one checks to make sure that the user has entered data or the form won't submit. Our next step is to add our forms to our application and add some configuration to our application. __init__.py from flask import Flask, render_template from .forms import NewEntryForm app = Flask(__name__) app.config['SECRET_KEY'] = 'us@randomStrin1her0' @app.route('/') @app.route('/<name>') def index(name = None): data = { 'title': 'Fancy-Pants Blog', 'menu': [ { 'link': 'about', 'text': 'About' }, { 'link' : 'cv', 'text': 'CV' }, { 'link' : 'blog', 'text' : 'Blog' } ] } return render_template('index.html', data=data, name=name) @app.route('/blog') def blog(): data = { \"title\": \"Fancy-Pants Blog\", \"menu\": [ { \"link\": \"about\", \"text\": \"About\" }, { \"link\": \"blog\", \"text\": \"Blog\" } ], \"posts\": [ { \"title\": \"Post One\", \"author\": \"Jimmy\", \"text\": \"Lorem ipsum dolor sit amet, consectetur adipisicing elit. Dolor doloremque totam adipisci ex dolores vitae enim soluta quo provident! Voluptatem tenetur harum magni pariatur. Aliquid laborum dolores harum dignissimos quibusdam!\" }, { \"title\": \"About Chickens\", \"author\": \"Jimmy\", \"text\": \"Lorem ipsum dolor sit amet, consectetur adipisicing elit. Dolor doloremque totam adipisci ex dolores vitae enim soluta quo provident! Voluptatem tenetur harum magni pariatur. Aliquid laborum dolores harum dignissimos quibusdam!\" }, { \"title\": \"Trampled by Turtles\", \"author\": \"Jimmy\", \"text\": \"Lorem ipsum dolor sit amet, consectetur adipisicing elit. Dolor doloremque totam adipisci ex dolores vitae enim soluta quo provident! Voluptatem tenetur harum magni pariatur. Aliquid laborum dolores harum dignissimos quibusdam!\" } ] } return render_template('blog.html', data=data) @app.route('/post', methods=['GET', 'POST']) def new_post(): data = { 'title': 'Blog', 'post_title': None, 'author': None, 'text': None } form = NewEntryForm() if form.validate_on_submit(): data['post_title'] = form.data.title data['author'] = form.data.author data['text'] = form.data.text form.data.title = '' form.data.author = '' form.data.text = '' return render_template('post.html', form=form, data=data) First, we imported our form and then we configured our app to have a secret key. We also added the new_post() method to our flask app. A couple things to notice about this: The route includes a method parameter. The method of all routes by default is GET. If we want a route to accept POST requests, then we need to specify that that is an allowed method. This route accepts both GET and POST requests. If the request is GET, it returns the form and any data. If it is post, it validates the form and would add that data to a database if we had one set up yet. You'll see that our render_template recieves an extra parameter: form. The template will have both data and a form. We'll add that next. The form.data property is the property that contains all of the values returned by the form when the user POSTS. The values are stored as key-value pairs by the \"name\" attribute of the <input> field. So form.data.title will get us the value submited in the <input type='text' name='title'> field. One more piece to add. We need to add to our template so that that form is rendered. I also need to actually create the template. So first, I create the file post.html in my templates directory. post.html {% extends 'base.html' %} {% extends 'base.html' %} {% block content %} {% if data.post_title %} <div> <h2>{{ data.post_title }}</h2> <h3>{{ data.author }}</h3> <p>{{ data.text }}</p> </div> {% endif %} <form method=\"post\"> {{ form.hidden_tag() }} {{ form.post_title.label }} {{ form.post_title() }} {{ form.author.label }} {{ form.author() }} {{ form.text.label }} {{ form.text() }} {{ form.submit.label }} {{ form.submit() }} </form> {% end block %} You'll notice that we're including all of the properties of our form that we defined in our forms.py file and instantiated our new_post() method. You'll notice taht we are including both the label and the field itself and the field itself is a function call (which creates the input field). You'll also see we added a hidden_tag which helps prevent cross-site forgery--or it ensures that the data is coming from this form and not a form created by someone trying to exploit my website. Now when we run our tests, we see that we get all of them to pass: (env) ~/Projects/blog$ python -m unittest tests/blog_tests.py ........ ---------------------------------------------------------------------- Ran 8 tests in 0.021s OK There is one issue with this. My unittests pass, but when I launch my Flask server and try to run this application and submit some data through my forms, which for now should just get added to the page, I run into a 500 server error. When this happens, I go to my terminal that is running Flask and I get this error message: (env) ~/Projects/blog$ flask run * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Debug mode: off * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) [2020-05-20 10:00:11,972] ERROR in app: Exception on /post [POST] Traceback (most recent call last): File \"~/Projects/blog/env/lib/python3.6/site-packages/flask/app.py\", line 2447, in wsgi_app response = self.full_dispatch_request() File \"~/Projects/blog/env/lib/python3.6/site-packages/flask/app.py\", line 1952, in full_dispatch_request rv = self.handle_user_exception(e) File \"~/Projects/blog/env/lib/python3.6/site-packages/flask/app.py\", line 1821, in handle_user_exception reraise(exc_type, exc_value, tb) File \"~/Projects/blog/env/lib/python3.6/site-packages/flask/_compat.py\", line 39, in reraise raise value File \"~/Projects/blog/env/lib/python3.6/site-packages/flask/app.py\", line 1950, in full_dispatch_request rv = self.dispatch_request() File \"~/Projects/blog/env/lib/python3.6/site-packages/flask/app.py\", line 1936, in dispatch_request return self.view_functions[rule.endpoint](**req.view_args) File \"~/Projects/blog/app/__init__.py\", line 77, in new_post data.post_title = form.data.post_title AttributeError: 'dict' object has no attribute 'post_title' 127.0.0.1 - - [20/May/2020 10:00:11] \"POST /post HTTP/1.1\" 500 - The last few lines are important, and they are telling me that for some reason my form.data has no attribute 'post_title'. After a bit of scrutiny, I found the problem is located in how I access form data. We used to be able to get that data using dot notation. So to get the value from the post_title field of the form, I used to be able to write form.data.post_title , but that doesn't work anymore. Instead, I have to access it using the dictionary key: form.data['post_title'] , so that means I need to change up my new_post() method: __init__.py from flask import Flask, render_template from .forms import NewEntryForm app = Flask(__name__) app.config['SECRET_KEY'] = 'us@randomStrin1her0' @app.route('/') @app.route('/<name>') def index(name = None): data = { 'title': 'Fancy-Pants Blog', 'menu': [ { 'link': 'about', 'text': 'About' }, { 'link' : 'cv', 'text': 'CV' }, { 'link' : 'blog', 'text' : 'Blog' } ] } return render_template('index.html', data=data, name=name) @app.route('/blog') def blog(): data = { \"title\": \"Fancy-Pants Blog\", \"menu\": [ { \"link\": \"about\", \"text\": \"About\" }, { \"link\": \"blog\", \"text\": \"Blog\" } ], \"posts\": [ { \"title\": \"Post One\", \"author\": \"Jimmy\", \"text\": \"Lorem ipsum dolor sit amet, consectetur adipisicing elit. Dolor doloremque totam adipisci ex dolores vitae enim soluta quo provident! Voluptatem tenetur harum magni pariatur. Aliquid laborum dolores harum dignissimos quibusdam!\" }, { \"title\": \"About Chickens\", \"author\": \"Jimmy\", \"text\": \"Lorem ipsum dolor sit amet, consectetur adipisicing elit. Dolor doloremque totam adipisci ex dolores vitae enim soluta quo provident! Voluptatem tenetur harum magni pariatur. Aliquid laborum dolores harum dignissimos quibusdam!\" }, { \"title\": \"Trampled by Turtles\", \"author\": \"Jimmy\", \"text\": \"Lorem ipsum dolor sit amet, consectetur adipisicing elit. Dolor doloremque totam adipisci ex dolores vitae enim soluta quo provident! Voluptatem tenetur harum magni pariatur. Aliquid laborum dolores harum dignissimos quibusdam!\" } ] } return render_template('blog.html', data=data) @app.route('/post', methods=['GET', 'POST']) def new_post(): data = { 'title': 'Blog', 'post_title': None, 'author': None, 'text': None } form = NewEntryForm() if form.validate_on_submit(): data['post_title'] = form.data['post_title'] data['author'] = form.data['author'] data['text'] = form.data['text'] form.data['post_title'] = '' form.data['author'] = '' form.data['text'] = '' return render_template('post.html', form=form, data=data) Now when I run my tests and when I manually test out the form, everything works fine. In the next section, we'll learn how to take that form data and store it to a database rather than simply adding it to a page.","title":"13. Forms the TDD way"},{"location":"ch13/#forms","text":"In the last couple of chapters, we have coverd HTML and Flask Templates. These allow us to create user interfaces, or web pages at least, that are rendered by the web browser into something that looks a little better than just simple strings of text. These imagine the user as a consumer of content, but we want to do more than this. For our user interface or our frontend, we really want the user to be able to interact with our application. As with any user-facing program, interaction is about allowing the user to provide some sort of input, performing an action, and returning some sort of output that responds to that input. When you post on social media, for instance, you are providing input (text or a picture), which is sent to the application server. That input is then added to the stream or your wall or wherever that particular social media application shares the input. On Facebook, users input text and images in a form on the main application. That is then posted to the user's \"wall.\" The main way that web applications receive data is through forms that are included in the user interface.","title":"Forms"},{"location":"ch13/#crud","text":"Many websites allow users to add content. Anything from a blogging platform to social media and so on. These websites frequently follow the CRUD design pattern, which stands for \"Create,\" \"Read,\" \"Update,\" and \"Delete.\" Each of these represents a function that a user can perform. The Create functionality allows users to create some content that is saved by the website, probably in a database. The Read functionality allows the user to retrieve a specific bit of content from the website. The Update functionality allows the user to change something about content they have already added (e.g. when you edit a post on Facebook that has already been posted). Finally, the Delete functionality allows the user to remove content from the website. Usually the site will have some access control throught authentication to prevent unauthorized users from altering or deleting (or even creating) data that is saved by the application. If an application allows the users to add content then their will be a couple of components that are necessary to the application that are not built into Flask by default. First is Forms and the second is databases or data storage technologies. Forms are HTML elements that give the user specific types of fields to provide input. Databases are storage technologies that organize and store content that has been submitted to the application.","title":"CRUD"},{"location":"ch13/#html-forms","text":"HTML forms are rendered by the browser to give the user a place to input data. At its most basic, an HTML form is comprised of three types of tags: <form> , <input> , and <label> tags. The first is a block level element, meaning it defines a block of space on the screen that spans form left to right margin of its container. The next two are inline elements that give the user a field to input data and a label to help screenreaders identify a particular input. Here is a basic example and the html code. <form action=\"/login\" method=\"post\"> <label for=\"username\">Username:</label><br> <input type=\"text\" id=\"username\" name=\"username\"><br> <label for=\"password\">Password:</label><br> <input type=\"password\" id=\"password\" name=\"password\"><br> <input type=\"submit\" value=\"submit\"> </form> Username: Password: There are plenty of excellent tutorials on HTML that will help you learn about all of the features of HTML forms, and so I am not going to repeat that here. In short, the form, when submitted, will send whatever data is in the input fields (keyed to the input name) to the action (another route) via the POST method. It is entirely possible for us to create forms in our templates when we use Flask. However, you'll see as we go through Flask that it is sometimes better to use a library rather than building something from scratch. This is because, first, we don't want to reinvent the wheel. Second, if the library is well maintained and has been around for a bit, it will probably be a bit more reliable than what we could build ourselves because it has had many eyes looking at it and debugging it. Beyond the concern of repeating code that already works just fine, dealing with forms, and really accepting any user input, can pose security concerns. In the early days of dynamic websites, it was possible, for example, to send a SQL statement that either returned the entire contents of a database or even deleted the entire contents of a database through a webform. If the developer didn't include a bunch of processing to prevent it, those commands would be executed. When we use libraries to manage our forms for us, we can feel pretty confident (especially if we've read the documentation and the code) that the libraries are dealing with those security concerns for us behind the scenes. That is the case with Flask-WTF.","title":"HTML Forms"},{"location":"ch13/#enter-wtforms-and-flask-wtf","text":"Instead of writing our forms in our templates, we wil be using Flask-WTF to help us build forms. I encourage you to take a moment and read the documentation. Instead of us building the forms in HTML, we add a form to our application we create a Form class that will then be rendered into our template at runtime. To get started with Flask-WTF and our forms, I want to create a new test that will at least check to see that my form is being rendered. blog_tests.py from bs4 import BeautifulSoup import unittest from app import app class TestBlog(unittest.TestCase): def setUp(self): self.client = app.test_client() def test_home_page_returns(self): resp = self.client.get('/') self.assertEqual(200, resp.status_code) def test_home_page_returns_correct_html(self): resp = self.client.get('/') html = resp.data.decode('utf-8') self.assertTrue(html.startswith('<!DOCTYPE html>')) self.assertIn('<title>Fancy-Pants Blog</title>', html) self.assertTrue(html.endswith('</html>')) def test_menu_text(self): resp = self.client.get('/') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') menu = [link.get_text() for link in soup.select('.menu-item')] self.assertListEqual(['About', 'CV', 'Blog'], menu) def test_menu_links(self): resp = self.client.get('/') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') menu = [link.get('href') for link in soup.select('.menu-item a')] self.assertListEqual(['about', 'cv', 'blog'], menu) def test_heading_no_name(self): resp = self.client.get('/') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') head = soup.h1.get_text() self.assertEqual('Hello Stranger', head) def test_heading_name(self): resp = self.client.get('/Dylan') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') head = soup.h1.get_text() self.assertEqual('Hello Dylan', head) def test_blog_post_page(self): resp = self.client.get('/blog') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') heading = soup.h1.get_text() self.assertEqual(heading, 'Blog Posts') def test_blog_post(self): resp = self.client.get('/blog') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') head = soup.h1.get_text() self.assertEqual('Hello Dylan', head) def test_form(self): resp = self.client.get('/post') html = resp.data.decode('utf-8') self.assertIn('<form method=\"post\">', html) self.assertIn('</form>', html) def test_form_fields(self): resp = self.client.get('/post') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') fields = [i.attrs['name'] for i in soup.find_all('input')] self.assertListEqual(fields[1:], ['post_title', 'author', 'submit']) self.assertEqual(soup.textarea.attrs['name'], 'text') test_form() This test checks to make sure that the opening and closing form tags are present in the response. This is a pretty simple test. test_form_fields() I also want to test that my form has the expected fields. I am testing by name because that will also ensure that they are valid fields. I run those tests, and of course they are failing as to be expected: (env) ~/Projects/blog$ python -m unittest tests/blog_tests.py FF...... ====================================================================== FAIL: test_form (tests.blog_tests.TestBlog) ---------------------------------------------------------------------- Traceback (most recent call last): File \"~/Projects/blog/tests/blog_tests.py\", line 53, in test_form self.assertIn('<form>', html) AssertionError: '<form>' not found in '<!DOCTYPE html>\\n<html lang=\"en\">\\n<head>\\n <meta charset=\"UTF-8\">\\n <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\\n <title>Fancy-Pants Blog</title>\\n</head>\\n<body>\\n <ul>\\n \\n <li class=\"menu-item\"><a href=\"about\">About</a></li>\\n \\n <li class=\"menu-item\"><a href=\"cv\">CV</a></li>\\n \\n <li class=\"menu-item\"><a href=\"blog\">Blog</a></li>\\n \\n </ul>\\n \\n\\n<h1>Hello post</h1>\\n\\n\\n</body>\\n</html>' ====================================================================== FAIL: test_form_fields (tests.blog_tests.TestBlog) ---------------------------------------------------------------------- Traceback (most recent call last): File \"~/Projects/blog/tests/blog_tests.py\", line 61, in test_form_fields self.assertListEqual(fields, ['title', 'author', 'text']) AssertionError: Lists differ: [] != ['title', 'author', 'text'] Second list contains 3 additional elements. First extra element 0: 'title' - [] + ['title', 'author', 'text'] ---------------------------------------------------------------------- Ran 8 tests in 0.032s FAILED (failures=2) Now we need to do some setup. First we will need to install Flask-WTF and create a file where our forms will live. (env) ~/Projects/blog$ pip install Flask-WTF (env) ~/Projects/blog$ touch app/forms.py Now we'll create our first form. This form will accept a title, an author name, and a text area in which the user could enter a blog post. forms.py from flask_wtf import FlaskForm from wtforms import StringField, TextAreaField, SubmitField from wtforms.validators import DataRequired class NewEntryForm(FlaskForm): post_title = StringField('Title', validators=[DataRequired()]) author = StringField('Author', validators=[DataRequired()]) text = TextAreaField('Text', validators=[DataRequired()]) submit = SubmitField('Submit') import statments You'll notice that we are importing a bunch of different things from flask_wtf and wtforms. The FlaskForm is a class that we will be extending. It is a wrapper that allows Flask to use WTForms easily. Second, there are imports from wtforms that include the field classes and the validators for those fields. When we instantiate each of this, we create a field that will be rendered into an HTML input. class NewEntryForm(FlaskForm) This is how we extend a class in Python. Our NewEntryForm class gains all of the methods and properties of the FlaskForm. The Fields Each of these fields (title, author, text, submit) are instances of classes from wtforms. They have a corresponding input type in HTML. The first parameter is the label for the field, which helps screen readers. The validators are automatically run. This one checks to make sure that the user has entered data or the form won't submit. Our next step is to add our forms to our application and add some configuration to our application. __init__.py from flask import Flask, render_template from .forms import NewEntryForm app = Flask(__name__) app.config['SECRET_KEY'] = 'us@randomStrin1her0' @app.route('/') @app.route('/<name>') def index(name = None): data = { 'title': 'Fancy-Pants Blog', 'menu': [ { 'link': 'about', 'text': 'About' }, { 'link' : 'cv', 'text': 'CV' }, { 'link' : 'blog', 'text' : 'Blog' } ] } return render_template('index.html', data=data, name=name) @app.route('/blog') def blog(): data = { \"title\": \"Fancy-Pants Blog\", \"menu\": [ { \"link\": \"about\", \"text\": \"About\" }, { \"link\": \"blog\", \"text\": \"Blog\" } ], \"posts\": [ { \"title\": \"Post One\", \"author\": \"Jimmy\", \"text\": \"Lorem ipsum dolor sit amet, consectetur adipisicing elit. Dolor doloremque totam adipisci ex dolores vitae enim soluta quo provident! Voluptatem tenetur harum magni pariatur. Aliquid laborum dolores harum dignissimos quibusdam!\" }, { \"title\": \"About Chickens\", \"author\": \"Jimmy\", \"text\": \"Lorem ipsum dolor sit amet, consectetur adipisicing elit. Dolor doloremque totam adipisci ex dolores vitae enim soluta quo provident! Voluptatem tenetur harum magni pariatur. Aliquid laborum dolores harum dignissimos quibusdam!\" }, { \"title\": \"Trampled by Turtles\", \"author\": \"Jimmy\", \"text\": \"Lorem ipsum dolor sit amet, consectetur adipisicing elit. Dolor doloremque totam adipisci ex dolores vitae enim soluta quo provident! Voluptatem tenetur harum magni pariatur. Aliquid laborum dolores harum dignissimos quibusdam!\" } ] } return render_template('blog.html', data=data) @app.route('/post', methods=['GET', 'POST']) def new_post(): data = { 'title': 'Blog', 'post_title': None, 'author': None, 'text': None } form = NewEntryForm() if form.validate_on_submit(): data['post_title'] = form.data.title data['author'] = form.data.author data['text'] = form.data.text form.data.title = '' form.data.author = '' form.data.text = '' return render_template('post.html', form=form, data=data) First, we imported our form and then we configured our app to have a secret key. We also added the new_post() method to our flask app. A couple things to notice about this: The route includes a method parameter. The method of all routes by default is GET. If we want a route to accept POST requests, then we need to specify that that is an allowed method. This route accepts both GET and POST requests. If the request is GET, it returns the form and any data. If it is post, it validates the form and would add that data to a database if we had one set up yet. You'll see that our render_template recieves an extra parameter: form. The template will have both data and a form. We'll add that next. The form.data property is the property that contains all of the values returned by the form when the user POSTS. The values are stored as key-value pairs by the \"name\" attribute of the <input> field. So form.data.title will get us the value submited in the <input type='text' name='title'> field. One more piece to add. We need to add to our template so that that form is rendered. I also need to actually create the template. So first, I create the file post.html in my templates directory. post.html {% extends 'base.html' %} {% extends 'base.html' %} {% block content %} {% if data.post_title %} <div> <h2>{{ data.post_title }}</h2> <h3>{{ data.author }}</h3> <p>{{ data.text }}</p> </div> {% endif %} <form method=\"post\"> {{ form.hidden_tag() }} {{ form.post_title.label }} {{ form.post_title() }} {{ form.author.label }} {{ form.author() }} {{ form.text.label }} {{ form.text() }} {{ form.submit.label }} {{ form.submit() }} </form> {% end block %} You'll notice that we're including all of the properties of our form that we defined in our forms.py file and instantiated our new_post() method. You'll notice taht we are including both the label and the field itself and the field itself is a function call (which creates the input field). You'll also see we added a hidden_tag which helps prevent cross-site forgery--or it ensures that the data is coming from this form and not a form created by someone trying to exploit my website. Now when we run our tests, we see that we get all of them to pass: (env) ~/Projects/blog$ python -m unittest tests/blog_tests.py ........ ---------------------------------------------------------------------- Ran 8 tests in 0.021s OK There is one issue with this. My unittests pass, but when I launch my Flask server and try to run this application and submit some data through my forms, which for now should just get added to the page, I run into a 500 server error. When this happens, I go to my terminal that is running Flask and I get this error message: (env) ~/Projects/blog$ flask run * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Debug mode: off * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) [2020-05-20 10:00:11,972] ERROR in app: Exception on /post [POST] Traceback (most recent call last): File \"~/Projects/blog/env/lib/python3.6/site-packages/flask/app.py\", line 2447, in wsgi_app response = self.full_dispatch_request() File \"~/Projects/blog/env/lib/python3.6/site-packages/flask/app.py\", line 1952, in full_dispatch_request rv = self.handle_user_exception(e) File \"~/Projects/blog/env/lib/python3.6/site-packages/flask/app.py\", line 1821, in handle_user_exception reraise(exc_type, exc_value, tb) File \"~/Projects/blog/env/lib/python3.6/site-packages/flask/_compat.py\", line 39, in reraise raise value File \"~/Projects/blog/env/lib/python3.6/site-packages/flask/app.py\", line 1950, in full_dispatch_request rv = self.dispatch_request() File \"~/Projects/blog/env/lib/python3.6/site-packages/flask/app.py\", line 1936, in dispatch_request return self.view_functions[rule.endpoint](**req.view_args) File \"~/Projects/blog/app/__init__.py\", line 77, in new_post data.post_title = form.data.post_title AttributeError: 'dict' object has no attribute 'post_title' 127.0.0.1 - - [20/May/2020 10:00:11] \"POST /post HTTP/1.1\" 500 - The last few lines are important, and they are telling me that for some reason my form.data has no attribute 'post_title'. After a bit of scrutiny, I found the problem is located in how I access form data. We used to be able to get that data using dot notation. So to get the value from the post_title field of the form, I used to be able to write form.data.post_title , but that doesn't work anymore. Instead, I have to access it using the dictionary key: form.data['post_title'] , so that means I need to change up my new_post() method: __init__.py from flask import Flask, render_template from .forms import NewEntryForm app = Flask(__name__) app.config['SECRET_KEY'] = 'us@randomStrin1her0' @app.route('/') @app.route('/<name>') def index(name = None): data = { 'title': 'Fancy-Pants Blog', 'menu': [ { 'link': 'about', 'text': 'About' }, { 'link' : 'cv', 'text': 'CV' }, { 'link' : 'blog', 'text' : 'Blog' } ] } return render_template('index.html', data=data, name=name) @app.route('/blog') def blog(): data = { \"title\": \"Fancy-Pants Blog\", \"menu\": [ { \"link\": \"about\", \"text\": \"About\" }, { \"link\": \"blog\", \"text\": \"Blog\" } ], \"posts\": [ { \"title\": \"Post One\", \"author\": \"Jimmy\", \"text\": \"Lorem ipsum dolor sit amet, consectetur adipisicing elit. Dolor doloremque totam adipisci ex dolores vitae enim soluta quo provident! Voluptatem tenetur harum magni pariatur. Aliquid laborum dolores harum dignissimos quibusdam!\" }, { \"title\": \"About Chickens\", \"author\": \"Jimmy\", \"text\": \"Lorem ipsum dolor sit amet, consectetur adipisicing elit. Dolor doloremque totam adipisci ex dolores vitae enim soluta quo provident! Voluptatem tenetur harum magni pariatur. Aliquid laborum dolores harum dignissimos quibusdam!\" }, { \"title\": \"Trampled by Turtles\", \"author\": \"Jimmy\", \"text\": \"Lorem ipsum dolor sit amet, consectetur adipisicing elit. Dolor doloremque totam adipisci ex dolores vitae enim soluta quo provident! Voluptatem tenetur harum magni pariatur. Aliquid laborum dolores harum dignissimos quibusdam!\" } ] } return render_template('blog.html', data=data) @app.route('/post', methods=['GET', 'POST']) def new_post(): data = { 'title': 'Blog', 'post_title': None, 'author': None, 'text': None } form = NewEntryForm() if form.validate_on_submit(): data['post_title'] = form.data['post_title'] data['author'] = form.data['author'] data['text'] = form.data['text'] form.data['post_title'] = '' form.data['author'] = '' form.data['text'] = '' return render_template('post.html', form=form, data=data) Now when I run my tests and when I manually test out the form, everything works fine. In the next section, we'll learn how to take that form data and store it to a database rather than simply adding it to a page.","title":"Enter WTForms and Flask-WTF"},{"location":"ch14/","text":"Databases part of Python's standard libraries. The problem with all of these data structures is that they exist only while your program is running. Once the program ends or the exit() command is called, the data is lost unless you, in some way, write it to your disk. A common way to do this initially is to simply write out the data to a file of some sort (sometimes as a text file). If you remember we used the read() and write() methods in Concepts in Computing. The problem with this is that storing your data as plain text may not be the easiest or most efficient way to do it. Likewise, if you're dealing with complex models, you might use a library like Pickle to store your model as a particular model file. However, if you want to store large data sets, a database of some sort is often the way to do it. This allows you to keep your data is a reliable and stored place on the disk that can be efficiently read from and written to (reading and writing from a text file is really inefficient). As I said, databases come in many flavors. We're going to be looking at SQL databases, which are particularly good for storing structured data. By structured, I mean that the data is going to have reliable attributes. For instance, a data set of PEOPLE might include FIRST_NAME, LAST_NAME, EMAIL, and BIRTHDAY. While a particular person might have more attributes in real life, I'm only collecting their names, email addresses, and birthdays. Since I have a regular structure for the data type PEOPLE, I can use a database to easily and quickly store that data. SQL databases are extremely fast and reliable, so if you're storing a lot of data that is easily structured into objects and attributes, they're a great way to go. Your database server (MySQL, MariaDB, PostgreSQL, even ACCESS, etc) hosts all of your databases. Generally, each project has one or more databases. Rarely would you run multiple projects on the same database. The server listens for traffic at a particular address or as a process on the operating system in a similar way to web servers. Depending on the type of server, the specific protocol for sending and executing messages might vary. On the server there may be one or more databases. Each database itself is a collection of related tables not unlike Excel spreadsheets. These tables consist of rows of entries. The whole table will have a number of typed columns, each representing a particular attribute of the object in each row. When I say, \"typed\" I mean that each column can hold a particular type of data (strings, integers, text blobs, etc). So, why not just use Excel? In part, because database servers are really fast. Second, the tables can have relationships between them. So the ID of a particular table might be linked to the ID of entries in another table. Let me give you some examples. The following is a database diagram with three tables: You'll notice that there is the ORG table. This table has 7 attributes. Attribute 7 (CONTACT) references the CONTACT table, and specifically the value in attribute 7 in any row will be the ID of an entry in the CONTACT entry. This way I can keep by Contact people separate but linked to my organizations. This is useful because the contact might change or a single contact might be the contact for multiple organizations. Additionally, there is a link to TYPE. I decided my database wanted to also manage what type of organization each organization is. I will have a set of types (Environmental, Racial Justice, Education, etc). It seems useful to have some way to manage those types. I have them in a separate table because then I can have a predictable group of types without making big changes across the ORG table. To look more closely at each table, the next pictures are printouts of the tables and the data types of each attribute: Database tables showing ORG, TYPE and CONTACT What you see in the images above is the printouts from a MySQL database when I ask the server to describe the tables. The tables presented show the field names, the type, whether the field can be NULL, and any \"foreign\" keys or keys to other tables. The primary key is the main identifier from this table. Default tells us if there's a default value that gets inserted for that field into the row if no other value is provided. In this case, no. Entries that don't fill fields will leave those fields \"NULL\". This is okay, but I like to make sure that if I add a row, I've accounted for all of the fields as best as I can. We interact with a SQL database server (MySQL, PostgreSQL, ACCESS, MariaDB, etc) with SQL, or Structured Query Language. You absolutely don't need to know any of this for Flask because SQLAlchemy takes care of that for us. It gives us methods to create and insert material into a database without having to mess about with establishing a connection to the database server and executing SQL commands against that server. It is good to know what's going on behind the scenes, however. Understanding the kind of structure that is imposed on the data is important because it will help us understand the kind of formal constraints that exist in digital spaces that are so synonmous with data. For instance, let's think about my identity of Facebook. Facebook stores the data that defines users in a database, probably in a USERS table (or several USERS tables). While there are lots of different attributes to a person, the table will only hold certain attributes that matter to the Facebook application. Facebook could store your height, but they choose not to and the way they structure the data there is no place for that. Likewise, you might have several middle names, but if they do not provide an attribute for that, you'll have to squish them all together in one field or leave some of them off all together. Likewise, you'll notice there are fields with the type VARCHAR(45). This means that the field will hold a list of characters (commonly used for small strings) up to 45 characters in length. We could bump that up to VARCHAR(255), but it would take more space. Even then, the maximum length of the string would be 255. Imagine if I create a name field with the maximum length of 45 but one of my users has a name with 100 characters in it. They would have to abbreviate. This could be okay, but it is a decision that gets made when designing databases. CRUD One major concept related to databases and web frameworks is the CRUD model. This is an application design that focuses on data. Specifically, a CRUD application provides a database that holds data and a set of commands that allow users to Create, Read, Update and Delete data. Create means enter a new entry into the database tables. Read means read data from the database tables. Update means to change the value of one entry in the tables. Delete means to remove one or more entries from the tables. Your applications for this class will be CRUD applications. The majority of your work will be defining how the data is managed. Then you will create a simple frontend using Flask templates to allow users to create, read, update, and delete data from the database you've designed. To do this, you'll provide web forms and you'll have to think about what data pieces you'll be storing, how those will fit into tables, and what the relationship between those tables are. Designing the data system will be the most important piece. Then the next tricky part is figuring out how you want the user to be able to access the data either to read it (with a search) or update or delete values. Models Flask deals with databases through models. Our models use SQLAlchemy to connect to a SQLite database. It is light weight, the database is just a file stored in your app directory (or elsewhere), but it doesn't take advantage of some of the efficiencies that other database servers provide. You can certainly use other databases, and I'd recommend MariaDB or PostgreSQL for production purposes. Each model represents a single table within our database. It will have all of the fields and field types that the table will have. Instead of writing SQL statements, though, we'll be able to use our models and SQLAlchemy to manage the data. Setting Up our Tests Again, before we start writing any code, we want to set up some tests. There are two major concerns that we need to test. We must test that our database will accept data. We must also test that our forms can add data to our database. I will write the tests first, and then we'll go through the setup required to get the database working and linked to our forms. Set up our Test Suite Our first step for our test is to modify our test setUp() method and create some helper methods that we'll use in our unit tests throughout. NOTE: I will be showing just part of the files below as they are getting fairly long. Three dots ( ... ) means that some code has not been copied in, but you should not delete it from your code or add the dots if you are following along. blog_test.py import os # 1 from bs4 import BeautifulSoup import unittest from app import app, db # 2 from app.models import Entry # Global Test database TEST_DB = 'test.db' # 3 class TestBlog(unittest.TestCase): def setUp(self): app.config['TESTING'] = True app.config['WTF_CSRF_ENABLED'] = False app.config['DEBUG'] = False app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///' + \\ os.path.join(app.config['BASEDIR'], TEST_DB) self.client = app.test_client() db.drop_all() db.create_all() db.add_user('author', 'author@example.com', 'Author', 'McAuthorson', 'password', 'password') db.add_post('Title', 'Sluggy', 'The body text.') db.add_post('Title2', 'Sluggy', 'The body text.') def tearDown(self): db.drop_all() ######################## #### Helper Methods #### ######################## def register(self, username, email, password, confirm): return self.app.post( '/register', data = { 'username': username, 'email': email, 'password': password, 'confirm': confirm }, follow_redirects=True ) def login(self, cred, password): return self.app.post( '/login', data = { 'cred': cred, 'password': password }, follow_redirects=True ) def logout(self): return self.app.get('/logout', follow_redirects = True) ... We added a new import statement. Importing the os library allows Python to read the path where the database file should be created. This shows up again when we config the SQLALCHEMY_DATABASE_URI SQLAlchemy uses a simple database file rather than a database server. In production, if you are expecting extensive traffic, you might consider using a SQL server (PostgreSQL, MariaDB, etc.). We're not just importing app, but also db from our project. This means we'll need to create that in our __init__.py script. Look for that later on. We are creating a global constant TEST_DB that is the name of the database file we will create in setup. Python doesn't enforce constants like Java or C++, but by naming a variable in all caps, we're indicating that it should be treated as a constant. As such, you will never change the value of TEST_DB in the code. We added a bunch of configuration to our app before we created our test client. These configurations include setting the value of some constants. Also, we define the path to our database file. Finally, we call methods from our database instance that clear and then rebuild the test database so each time we run the tests, the database is empty. Helper Methods! I know that many of my tests will require that I have logged in users, so I will create these methods so that I don't have to do this for every test. Instead, I will call the methods when I need to in the tests. Testing Creating and Logging in Users Since we want to be able to authenticate users before they can post to our blog, we need to set up a registration and login system. Here's what's involved with registration: We must be able to register a new user. I've decided arbitrarily that the information we're collecting from the user includes: a. Their username. b. Their email address. c. Their first name. d. Their last name. e. Their password. We need to be able to login a user. This must check that the user is giving a valid password, the password they enter must be confirmed, and the username and email address must not already be in use. We need to be able to logout a user. We'll be using the helper methods that we created above in our unittests so we avoid repeating ourselves as much as possible. You'll notice that I've also created a test user and a couple of test posts in the setUp section. You'll also notice that I'm dropping (emptying) the database at the end of the tests during teardown. From there we need to write tests to test all of the above points. You'll again notice, I'm leaving part of the file out for now. Also, I'm putting these below the basic tests and before the form tests in the file blog_tests.py. blog_tests.py ... ################################ #### Registration tests #### ################################ def test_valid_registration(self): resp = self.register('tester', 'testy@testing.com', 'Test', 'Tester', 'GoodPassword', 'GoodPassword') self.assertEqual(resp.status_code, 200) self.assertIn(b'Thanks for registering!', resp.data) def test_different_passwords(self): resp = self.register('tester2', 'testy2@testing.com', 'Test', 'Tester', 'GoodPassword', 'BadPassword') self.assertEqual(resp.status_code, 200) self.assertIn(b'Your passwords do not match.', resp.data) def test_duplicate_registrations(self): resp = self.register('author', 'author@example.com', 'Test', 'Tester', 'GoodPassword', 'GoodPassword') self.assertIn(b'User already exists.', resp.data) def test_login_success(self): resp = self.login('author@example.com', 'password') self.assertIn(b'You were successfully logged in', resp.data) def test_login_invalid_email(self): resp = self.login('user17@example.com', 'password') self.assertIn(b'Invalid email.', resp.data) def test_login_invalid_password(self): resp = self.login('author@example.com', 'Paword') self.assertIn(b'Invalid Password.', resp.data) def test_logout(self): self.login('author@example.com', 'password') resp = self.logout() self.assertIn(b'You are logged out.', resp.data) ... Here's what my tests do: test_valid_registration Attempts to register a new user and expects a message in the response somewhere that says \"Thanks for registering!\" test_different_passwords Attempts to register with mismatched passwords. This should return an error message telling the user what went wrong. test_duplicate_registrations Attempts to register using an email address and username that are already in the system. This returns an error message saying the \"User already exists.\" test_login_success Attempts to login with correct credentials. This should return a message saying, \"You were successfully logged in\". test_login_invalid_email Attempts to login with an email that has not been stored in the system. This should return an error message. test_login_invalid_password Attempts to login with a password that doesn't match the expected password for the user. This should return an error message. test_logout Logs in a user and then attempts to logout. Expects a message saying the user has been logged out. Testing the Blog Now that we have tests to get us a functional registration system, we need tests to make sure our blog is working. Again here's what we need to test: The user cannot post if they are not logged in. The user can post if they are logged in. A non-logged in user can retrieve all of the posts in the database. A non-logged in user can retrieve individual posts in the database by post_id. Later on we'll add functionality to update and delete posts. We'll also add functionality to retrieve posts only by a single author, but for now, we'll get this much done. Here are my tests that I've added below the registration tests but above the form tests: blog_tests.py ... ########################## #### Blog Tests #### ########################## def test_blog_not_logged_in(self): resp = self.client.post('/post', data=dict(title=\"bad\", slug=\"bad\", text=\"bad\")) self.assertIn(b'You must be logged in.', resp.data) def test_blog_logged_in(self): self.login('author@example.com', 'password') data = { 'title': 'Test Post', 'slug': 'Short summary of the post.', 'text': '''Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer bibendum enim id enim tempor, ullamcorper tempor quam tincidunt. Proin eget dapibus arcu. Donec ornare feugiat elit, eu efficitur nisi dictum in. Donec libero nisl, pretium eget placerat nec, tincidunt varius orci. Interdum et malesuada fames ac ante ipsum primis in faucibus. Nunc consequat leo enim, ut maximus neque pellentesque ac. Quisque porta, justo in maximus tincidunt, eros arcu tempus elit, a tristique turpis quam vel lacus. Nulla eleifend felis venenatis nunc ullamcorper cursus. Duis scelerisque consectetur odio, quis aliquet ipsum dictum vel. In dapibus, nisl ut feugiat vehicula, diam justo gravida lorem, id gravida nulla est id est. Donec ut nulla eu urna auctor gravida at eu purus. Etiam nulla dolor, tincidunt a nisl in, porta efficitur felis. Donec pretium lobortis facilisis. ''' } resp = self.client.post('/post', data=data) self.assertIn(b'Test Post', resp.data) def test_get_all_posts(self): self.login('author@example.com', 'Password') data = [ { 'title': 'Test Post2', 'slug': 'Short summary of the post.', 'text': '''Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer bibendum enim id enim tempor, ullamcorper tempor quam tincidunt. Proin eget dapibus arcu. Donec ornare feugiat elit, eu efficitur nisi dictum in. Donec libero nisl, pretium eget placerat nec, tincidunt varius orci. Interdum et malesuada fames ac ante ipsum primis in faucibus. Nunc consequat leo enim, ut maximus neque pellentesque ac. Quisque porta, justo in maximus tincidunt, eros arcu tempus elit, a tristique turpis quam vel lacus. Nulla eleifend felis venenatis nunc ullamcorper cursus. Duis scelerisque consectetur odio, quis aliquet ipsum dictum vel. In dapibus, nisl ut feugiat vehicula, diam justo gravida lorem, id gravida nulla est id est. Donec ut nulla eu urna auctor gravida at eu purus. Etiam nulla dolor, tincidunt a nisl in, porta efficitur felis. Donec pretium lobortis facilisis. ''' }, { 'title': 'Test Post3', 'slug': 'Short summary of the post.', 'text': '''Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer bibendum enim id enim tempor, ullamcorper tempor quam tincidunt. Proin eget dapibus arcu. Donec ornare feugiat elit, eu efficitur nisi dictum in. Donec libero nisl, pretium eget placerat nec, tincidunt varius orci. Interdum et malesuada fames ac ante ipsum primis in faucibus. Nunc consequat leo enim, ut maximus neque pellentesque ac. Quisque porta, justo in maximus tincidunt, eros arcu tempus elit, a tristique turpis quam vel lacus. Nulla eleifend felis venenatis nunc ullamcorper cursus. Duis scelerisque consectetur odio, quis aliquet ipsum dictum vel. In dapibus, nisl ut feugiat vehicula, diam justo gravida lorem, id gravida nulla est id est. Donec ut nulla eu urna auctor gravida at eu purus. Etiam nulla dolor, tincidunt a nisl in, porta efficitur felis. Donec pretium lobortis facilisis. ''' }, { 'title': 'Test Post4', 'slug': 'Short summary of the post.', 'text': '''Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer bibendum enim id enim tempor, ullamcorper tempor quam tincidunt. Proin eget dapibus arcu. Donec ornare feugiat elit, eu efficitur nisi dictum in. Donec libero nisl, pretium eget placerat nec, tincidunt varius orci. Interdum et malesuada fames ac ante ipsum primis in faucibus. Nunc consequat leo enim, ut maximus neque pellentesque ac. Quisque porta, justo in maximus tincidunt, eros arcu tempus elit, a tristique turpis quam vel lacus. Nulla eleifend felis venenatis nunc ullamcorper cursus. Duis scelerisque consectetur odio, quis aliquet ipsum dictum vel. In dapibus, nisl ut feugiat vehicula, diam justo gravida lorem, id gravida nulla est id est. Donec ut nulla eu urna auctor gravida at eu purus. Etiam nulla dolor, tincidunt a nisl in, porta efficitur felis. Donec pretium lobortis facilisis. ''' } ] for d in data: self.client.post('/post', data=d) resp = self.client.get('/blog') self.assertIn(b'Test Post2', resp.data) self.assertIn(b'Test Post3', resp.data) self.assertIn(b'Test Post4', resp.data) def test_get_one_post(self): resp = self.client.get('/blog/1') self.assertIn(b'Title', resp.data) self.assertNotIn(b'Title2', resp.data) ... test_blog_not_logged_in This test attempts to post a new blog post without being logged in. This should return an error message, \"You must be logged in.\" test_blog_logged_in This test attempts to post a new blog entry after logging in. This should succeed, and should reroute the use to the page showing the new post. test_get_all_posts This tests that the blog page returns a list of all the posts. First we add three posts. After we make a request to the blog page and see that all of the posts have been added. test_get_one_post This tests that we can retrieve a single blog post. I'm using one of the posts that was entered during the setUp phase, and I'm also checking that only one post shows up in the response. Forms Finally, we need to make some small changes to our forms tests because we designed our form differently last time. I'm including the entire blog_tests.py script this time so you can see it all in one place. blog_tests.py import os from bs4 import BeautifulSoup import unittest from app import app, db from app.models import Entry # Global Test database TEST_DB = 'test.db' class TestBlog(unittest.TestCase): def setUp(self): app.config['TESTING'] = True app.config['WTF_CSRF_ENABLED'] = False app.config['DEBUG'] = False app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///' + \\ os.path.join(app.config['BASEDIR'], TEST_DB) self.client = app.test_client() db.drop_all() db.create_all() db.add_user('author', 'author@example.com', 'Author', 'McAuthorson', 'password', 'password') db.add_post('Title', 'Sluggy', 'The body text.') db.add_post('Title2', 'Sluggy', 'The body text.') def tearDown(self): db.drop_all() ######################## #### Helper Methods #### ######################## def register(self, username, email, fname, lname, password, confirm): return self.app.post( '/register', data = { 'username': username, 'email': email, 'fname': fname, 'lname': lname, 'password': password, 'confirm': confirm }, follow_redirects=True ) def login(self, email, password): return self.app.post( '/login', data = { 'email': email, 'password': password }, follow_redirects=True ) def logout(self): return self.app.get('/logout', follow_redirects = True) ######################### #### Basic Tests #### ######################### def test_home_page_returns(self): resp = self.client.get('/') self.assertEqual(200, resp.status_code) def test_home_page_returns_correct_html(self): resp = self.client.get('/') html = resp.data.decode('utf-8') self.assertTrue(html.startswith('<!DOCTYPE html>')) self.assertIn('<title>Fancy-Pants Blog</title>', html) self.assertTrue(html.endswith('</html>')) def test_menu_text(self): resp = self.client.get('/') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') menu = [link.get_text() for link in soup.select('.menu-item')] self.assertListEqual(['About', 'CV', 'Blog'], menu) def test_menu_links(self): resp = self.client.get('/') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') menu = [link.get('href') for link in soup.select('.menu-item a')] self.assertListEqual(['about', 'cv', 'blog'], menu) def test_heading_no_name(self): resp = self.client.get('/') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') head = soup.h1.get_text() self.assertEqual('Hello Stranger', head) def test_heading_name(self): resp = self.client.get('/Dylan') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') head = soup.h1.get_text() self.assertEqual('Hello Dylan', head) ################################ #### Registration tests #### ################################ def test_valid_registration(self): resp = self.register('tester', 'testy@testing.com', 'Test', 'Tester', 'GoodPassword', 'GoodPassword') self.assertEqual(resp.status_code, 200) self.assertIn(b'Thanks for registering!', resp.data) def test_different_passwords(self): resp = self.register('tester2', 'testy2@testing.com', 'Test', 'Tester', 'GoodPassword', 'BadPassword') self.assertEqual(resp.status_code, 200) self.assertIn(b'Your passwords do not match.', resp.data) def test_duplicate_registrations(self): resp = self.register('author', 'author@example.com', 'Test', 'Tester', 'GoodPassword', 'GoodPassword') self.assertIn(b'User already exists.', resp.data) def test_login_success(self): resp = self.login('author@example.com', 'password') self.assertIn(b'You were successfully logged in', resp.data) def test_login_invalid_email(self): resp = self.login('user17@example.com', 'password') self.assertIn(b'Invalid email.', resp.data) def test_login_invalid_password(self): resp = self.login('author@example.com', 'Paword') self.assertIn(b'Invalid Password.', resp.data) def test_logout(self): self.login('author@example.com', 'password') resp = self.logout() self.assertIn(b'You are logged out.', resp.data) ########################## #### Blog Tests #### ########################## def test_blog_not_logged_in(self): resp = self.client.post('/post', data=dict(title=\"bad\", slug=\"bad\", text=\"bad\")) self.assertIn(b'You must be logged in.', resp.data) def test_blog_logged_in(self): self.login('author@example.com', 'password') data = { 'title': 'Test Post', 'slug': 'Short summary of the post.', 'text': '''Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer bibendum enim id enim tempor, ullamcorper tempor quam tincidunt. Proin eget dapibus arcu. Donec ornare feugiat elit, eu efficitur nisi dictum in. Donec libero nisl, pretium eget placerat nec, tincidunt varius orci. Interdum et malesuada fames ac ante ipsum primis in faucibus. Nunc consequat leo enim, ut maximus neque pellentesque ac. Quisque porta, justo in maximus tincidunt, eros arcu tempus elit, a tristique turpis quam vel lacus. Nulla eleifend felis venenatis nunc ullamcorper cursus. Duis scelerisque consectetur odio, quis aliquet ipsum dictum vel. In dapibus, nisl ut feugiat vehicula, diam justo gravida lorem, id gravida nulla est id est. Donec ut nulla eu urna auctor gravida at eu purus. Etiam nulla dolor, tincidunt a nisl in, porta efficitur felis. Donec pretium lobortis facilisis. ''' } resp = self.client.post('/post', data=data) self.assertIn(b'Test Post', resp.data) def test_get_all_posts(self): self.login('author@example.com', 'Password') data = [ { 'title': 'Test Post2', 'slug': 'Short summary of the post.', 'text': '''Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer bibendum enim id enim tempor, ullamcorper tempor quam tincidunt. Proin eget dapibus arcu. Donec ornare feugiat elit, eu efficitur nisi dictum in. Donec libero nisl, pretium eget placerat nec, tincidunt varius orci. Interdum et malesuada fames ac ante ipsum primis in faucibus. Nunc consequat leo enim, ut maximus neque pellentesque ac. Quisque porta, justo in maximus tincidunt, eros arcu tempus elit, a tristique turpis quam vel lacus. Nulla eleifend felis venenatis nunc ullamcorper cursus. Duis scelerisque consectetur odio, quis aliquet ipsum dictum vel. In dapibus, nisl ut feugiat vehicula, diam justo gravida lorem, id gravida nulla est id est. Donec ut nulla eu urna auctor gravida at eu purus. Etiam nulla dolor, tincidunt a nisl in, porta efficitur felis. Donec pretium lobortis facilisis. ''' }, { 'title': 'Test Post3', 'slug': 'Short summary of the post.', 'text': '''Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer bibendum enim id enim tempor, ullamcorper tempor quam tincidunt. Proin eget dapibus arcu. Donec ornare feugiat elit, eu efficitur nisi dictum in. Donec libero nisl, pretium eget placerat nec, tincidunt varius orci. Interdum et malesuada fames ac ante ipsum primis in faucibus. Nunc consequat leo enim, ut maximus neque pellentesque ac. Quisque porta, justo in maximus tincidunt, eros arcu tempus elit, a tristique turpis quam vel lacus. Nulla eleifend felis venenatis nunc ullamcorper cursus. Duis scelerisque consectetur odio, quis aliquet ipsum dictum vel. In dapibus, nisl ut feugiat vehicula, diam justo gravida lorem, id gravida nulla est id est. Donec ut nulla eu urna auctor gravida at eu purus. Etiam nulla dolor, tincidunt a nisl in, porta efficitur felis. Donec pretium lobortis facilisis. ''' }, { 'title': 'Test Post4', 'slug': 'Short summary of the post.', 'text': '''Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer bibendum enim id enim tempor, ullamcorper tempor quam tincidunt. Proin eget dapibus arcu. Donec ornare feugiat elit, eu efficitur nisi dictum in. Donec libero nisl, pretium eget placerat nec, tincidunt varius orci. Interdum et malesuada fames ac ante ipsum primis in faucibus. Nunc consequat leo enim, ut maximus neque pellentesque ac. Quisque porta, justo in maximus tincidunt, eros arcu tempus elit, a tristique turpis quam vel lacus. Nulla eleifend felis venenatis nunc ullamcorper cursus. Duis scelerisque consectetur odio, quis aliquet ipsum dictum vel. In dapibus, nisl ut feugiat vehicula, diam justo gravida lorem, id gravida nulla est id est. Donec ut nulla eu urna auctor gravida at eu purus. Etiam nulla dolor, tincidunt a nisl in, porta efficitur felis. Donec pretium lobortis facilisis. ''' } ] for d in data: self.client.post('/post', data=d) resp = self.client.get('/blog') self.assertIn(b'Test Post2', resp.data) self.assertIn(b'Test Post3', resp.data) self.assertIn(b'Test Post4', resp.data) def test_get_one_post(self): resp = self.client.get('/blog/1') self.assertIn(b'Title', resp.data) self.assertNotIn(b'Title2', resp.data) ########################## #### Form Tests #### ########################## def test_form(self): resp = self.client.get('/post') html = resp.data.decode('utf-8') self.assertIn('<form method=\"POST\">', html) self.assertIn('</form>', html) def test_form_fields(self): resp = self.client.get('/post') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') fields = [i.attrs['name'] for i in soup.find_all('input')] self.assertListEqual(fields[1:], ['post_title', 'slug', 'submit']) self.assertEqual(soup.textarea.attrs['name'], 'text') Now let's run those tests and see that they fail with errors. In the next section, I'll build out my code and get these tests to pass. (env) ~/Projects/blog$ python -m unittest tests/blog_tests.py E ====================================================================== ERROR: blog_tests (unittest.loader._FailedTest) ---------------------------------------------------------------------- ImportError: Failed to import test module: blog_tests Traceback (most recent call last): File \"/usr/lib/python3.6/unittest/loader.py\", line 153, in loadTestsFromName module = __import__(module_name) File \"Projects/blog/tests/blog_tests.py\", line 4, in <module> from app import app, db ImportError: cannot import name 'db' ---------------------------------------------------------------------- Ran 1 test in 0.000s FAILED (errors=1)","title":"14. Databases and Login"},{"location":"ch14/#databases","text":"part of Python's standard libraries. The problem with all of these data structures is that they exist only while your program is running. Once the program ends or the exit() command is called, the data is lost unless you, in some way, write it to your disk. A common way to do this initially is to simply write out the data to a file of some sort (sometimes as a text file). If you remember we used the read() and write() methods in Concepts in Computing. The problem with this is that storing your data as plain text may not be the easiest or most efficient way to do it. Likewise, if you're dealing with complex models, you might use a library like Pickle to store your model as a particular model file. However, if you want to store large data sets, a database of some sort is often the way to do it. This allows you to keep your data is a reliable and stored place on the disk that can be efficiently read from and written to (reading and writing from a text file is really inefficient). As I said, databases come in many flavors. We're going to be looking at SQL databases, which are particularly good for storing structured data. By structured, I mean that the data is going to have reliable attributes. For instance, a data set of PEOPLE might include FIRST_NAME, LAST_NAME, EMAIL, and BIRTHDAY. While a particular person might have more attributes in real life, I'm only collecting their names, email addresses, and birthdays. Since I have a regular structure for the data type PEOPLE, I can use a database to easily and quickly store that data. SQL databases are extremely fast and reliable, so if you're storing a lot of data that is easily structured into objects and attributes, they're a great way to go. Your database server (MySQL, MariaDB, PostgreSQL, even ACCESS, etc) hosts all of your databases. Generally, each project has one or more databases. Rarely would you run multiple projects on the same database. The server listens for traffic at a particular address or as a process on the operating system in a similar way to web servers. Depending on the type of server, the specific protocol for sending and executing messages might vary. On the server there may be one or more databases. Each database itself is a collection of related tables not unlike Excel spreadsheets. These tables consist of rows of entries. The whole table will have a number of typed columns, each representing a particular attribute of the object in each row. When I say, \"typed\" I mean that each column can hold a particular type of data (strings, integers, text blobs, etc). So, why not just use Excel? In part, because database servers are really fast. Second, the tables can have relationships between them. So the ID of a particular table might be linked to the ID of entries in another table. Let me give you some examples. The following is a database diagram with three tables: You'll notice that there is the ORG table. This table has 7 attributes. Attribute 7 (CONTACT) references the CONTACT table, and specifically the value in attribute 7 in any row will be the ID of an entry in the CONTACT entry. This way I can keep by Contact people separate but linked to my organizations. This is useful because the contact might change or a single contact might be the contact for multiple organizations. Additionally, there is a link to TYPE. I decided my database wanted to also manage what type of organization each organization is. I will have a set of types (Environmental, Racial Justice, Education, etc). It seems useful to have some way to manage those types. I have them in a separate table because then I can have a predictable group of types without making big changes across the ORG table. To look more closely at each table, the next pictures are printouts of the tables and the data types of each attribute: Database tables showing ORG, TYPE and CONTACT What you see in the images above is the printouts from a MySQL database when I ask the server to describe the tables. The tables presented show the field names, the type, whether the field can be NULL, and any \"foreign\" keys or keys to other tables. The primary key is the main identifier from this table. Default tells us if there's a default value that gets inserted for that field into the row if no other value is provided. In this case, no. Entries that don't fill fields will leave those fields \"NULL\". This is okay, but I like to make sure that if I add a row, I've accounted for all of the fields as best as I can. We interact with a SQL database server (MySQL, PostgreSQL, ACCESS, MariaDB, etc) with SQL, or Structured Query Language. You absolutely don't need to know any of this for Flask because SQLAlchemy takes care of that for us. It gives us methods to create and insert material into a database without having to mess about with establishing a connection to the database server and executing SQL commands against that server. It is good to know what's going on behind the scenes, however. Understanding the kind of structure that is imposed on the data is important because it will help us understand the kind of formal constraints that exist in digital spaces that are so synonmous with data. For instance, let's think about my identity of Facebook. Facebook stores the data that defines users in a database, probably in a USERS table (or several USERS tables). While there are lots of different attributes to a person, the table will only hold certain attributes that matter to the Facebook application. Facebook could store your height, but they choose not to and the way they structure the data there is no place for that. Likewise, you might have several middle names, but if they do not provide an attribute for that, you'll have to squish them all together in one field or leave some of them off all together. Likewise, you'll notice there are fields with the type VARCHAR(45). This means that the field will hold a list of characters (commonly used for small strings) up to 45 characters in length. We could bump that up to VARCHAR(255), but it would take more space. Even then, the maximum length of the string would be 255. Imagine if I create a name field with the maximum length of 45 but one of my users has a name with 100 characters in it. They would have to abbreviate. This could be okay, but it is a decision that gets made when designing databases.","title":"Databases"},{"location":"ch14/#crud","text":"One major concept related to databases and web frameworks is the CRUD model. This is an application design that focuses on data. Specifically, a CRUD application provides a database that holds data and a set of commands that allow users to Create, Read, Update and Delete data. Create means enter a new entry into the database tables. Read means read data from the database tables. Update means to change the value of one entry in the tables. Delete means to remove one or more entries from the tables. Your applications for this class will be CRUD applications. The majority of your work will be defining how the data is managed. Then you will create a simple frontend using Flask templates to allow users to create, read, update, and delete data from the database you've designed. To do this, you'll provide web forms and you'll have to think about what data pieces you'll be storing, how those will fit into tables, and what the relationship between those tables are. Designing the data system will be the most important piece. Then the next tricky part is figuring out how you want the user to be able to access the data either to read it (with a search) or update or delete values.","title":"CRUD"},{"location":"ch14/#models","text":"Flask deals with databases through models. Our models use SQLAlchemy to connect to a SQLite database. It is light weight, the database is just a file stored in your app directory (or elsewhere), but it doesn't take advantage of some of the efficiencies that other database servers provide. You can certainly use other databases, and I'd recommend MariaDB or PostgreSQL for production purposes. Each model represents a single table within our database. It will have all of the fields and field types that the table will have. Instead of writing SQL statements, though, we'll be able to use our models and SQLAlchemy to manage the data.","title":"Models"},{"location":"ch14/#setting-up-our-tests","text":"Again, before we start writing any code, we want to set up some tests. There are two major concerns that we need to test. We must test that our database will accept data. We must also test that our forms can add data to our database. I will write the tests first, and then we'll go through the setup required to get the database working and linked to our forms.","title":"Setting Up our Tests"},{"location":"ch14/#set-up-our-test-suite","text":"Our first step for our test is to modify our test setUp() method and create some helper methods that we'll use in our unit tests throughout. NOTE: I will be showing just part of the files below as they are getting fairly long. Three dots ( ... ) means that some code has not been copied in, but you should not delete it from your code or add the dots if you are following along. blog_test.py import os # 1 from bs4 import BeautifulSoup import unittest from app import app, db # 2 from app.models import Entry # Global Test database TEST_DB = 'test.db' # 3 class TestBlog(unittest.TestCase): def setUp(self): app.config['TESTING'] = True app.config['WTF_CSRF_ENABLED'] = False app.config['DEBUG'] = False app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///' + \\ os.path.join(app.config['BASEDIR'], TEST_DB) self.client = app.test_client() db.drop_all() db.create_all() db.add_user('author', 'author@example.com', 'Author', 'McAuthorson', 'password', 'password') db.add_post('Title', 'Sluggy', 'The body text.') db.add_post('Title2', 'Sluggy', 'The body text.') def tearDown(self): db.drop_all() ######################## #### Helper Methods #### ######################## def register(self, username, email, password, confirm): return self.app.post( '/register', data = { 'username': username, 'email': email, 'password': password, 'confirm': confirm }, follow_redirects=True ) def login(self, cred, password): return self.app.post( '/login', data = { 'cred': cred, 'password': password }, follow_redirects=True ) def logout(self): return self.app.get('/logout', follow_redirects = True) ... We added a new import statement. Importing the os library allows Python to read the path where the database file should be created. This shows up again when we config the SQLALCHEMY_DATABASE_URI SQLAlchemy uses a simple database file rather than a database server. In production, if you are expecting extensive traffic, you might consider using a SQL server (PostgreSQL, MariaDB, etc.). We're not just importing app, but also db from our project. This means we'll need to create that in our __init__.py script. Look for that later on. We are creating a global constant TEST_DB that is the name of the database file we will create in setup. Python doesn't enforce constants like Java or C++, but by naming a variable in all caps, we're indicating that it should be treated as a constant. As such, you will never change the value of TEST_DB in the code. We added a bunch of configuration to our app before we created our test client. These configurations include setting the value of some constants. Also, we define the path to our database file. Finally, we call methods from our database instance that clear and then rebuild the test database so each time we run the tests, the database is empty. Helper Methods! I know that many of my tests will require that I have logged in users, so I will create these methods so that I don't have to do this for every test. Instead, I will call the methods when I need to in the tests.","title":"Set up our Test Suite"},{"location":"ch14/#testing-creating-and-logging-in-users","text":"Since we want to be able to authenticate users before they can post to our blog, we need to set up a registration and login system. Here's what's involved with registration: We must be able to register a new user. I've decided arbitrarily that the information we're collecting from the user includes: a. Their username. b. Their email address. c. Their first name. d. Their last name. e. Their password. We need to be able to login a user. This must check that the user is giving a valid password, the password they enter must be confirmed, and the username and email address must not already be in use. We need to be able to logout a user. We'll be using the helper methods that we created above in our unittests so we avoid repeating ourselves as much as possible. You'll notice that I've also created a test user and a couple of test posts in the setUp section. You'll also notice that I'm dropping (emptying) the database at the end of the tests during teardown. From there we need to write tests to test all of the above points. You'll again notice, I'm leaving part of the file out for now. Also, I'm putting these below the basic tests and before the form tests in the file blog_tests.py. blog_tests.py ... ################################ #### Registration tests #### ################################ def test_valid_registration(self): resp = self.register('tester', 'testy@testing.com', 'Test', 'Tester', 'GoodPassword', 'GoodPassword') self.assertEqual(resp.status_code, 200) self.assertIn(b'Thanks for registering!', resp.data) def test_different_passwords(self): resp = self.register('tester2', 'testy2@testing.com', 'Test', 'Tester', 'GoodPassword', 'BadPassword') self.assertEqual(resp.status_code, 200) self.assertIn(b'Your passwords do not match.', resp.data) def test_duplicate_registrations(self): resp = self.register('author', 'author@example.com', 'Test', 'Tester', 'GoodPassword', 'GoodPassword') self.assertIn(b'User already exists.', resp.data) def test_login_success(self): resp = self.login('author@example.com', 'password') self.assertIn(b'You were successfully logged in', resp.data) def test_login_invalid_email(self): resp = self.login('user17@example.com', 'password') self.assertIn(b'Invalid email.', resp.data) def test_login_invalid_password(self): resp = self.login('author@example.com', 'Paword') self.assertIn(b'Invalid Password.', resp.data) def test_logout(self): self.login('author@example.com', 'password') resp = self.logout() self.assertIn(b'You are logged out.', resp.data) ... Here's what my tests do: test_valid_registration Attempts to register a new user and expects a message in the response somewhere that says \"Thanks for registering!\" test_different_passwords Attempts to register with mismatched passwords. This should return an error message telling the user what went wrong. test_duplicate_registrations Attempts to register using an email address and username that are already in the system. This returns an error message saying the \"User already exists.\" test_login_success Attempts to login with correct credentials. This should return a message saying, \"You were successfully logged in\". test_login_invalid_email Attempts to login with an email that has not been stored in the system. This should return an error message. test_login_invalid_password Attempts to login with a password that doesn't match the expected password for the user. This should return an error message. test_logout Logs in a user and then attempts to logout. Expects a message saying the user has been logged out.","title":"Testing Creating and Logging in Users"},{"location":"ch14/#testing-the-blog","text":"Now that we have tests to get us a functional registration system, we need tests to make sure our blog is working. Again here's what we need to test: The user cannot post if they are not logged in. The user can post if they are logged in. A non-logged in user can retrieve all of the posts in the database. A non-logged in user can retrieve individual posts in the database by post_id. Later on we'll add functionality to update and delete posts. We'll also add functionality to retrieve posts only by a single author, but for now, we'll get this much done. Here are my tests that I've added below the registration tests but above the form tests: blog_tests.py ... ########################## #### Blog Tests #### ########################## def test_blog_not_logged_in(self): resp = self.client.post('/post', data=dict(title=\"bad\", slug=\"bad\", text=\"bad\")) self.assertIn(b'You must be logged in.', resp.data) def test_blog_logged_in(self): self.login('author@example.com', 'password') data = { 'title': 'Test Post', 'slug': 'Short summary of the post.', 'text': '''Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer bibendum enim id enim tempor, ullamcorper tempor quam tincidunt. Proin eget dapibus arcu. Donec ornare feugiat elit, eu efficitur nisi dictum in. Donec libero nisl, pretium eget placerat nec, tincidunt varius orci. Interdum et malesuada fames ac ante ipsum primis in faucibus. Nunc consequat leo enim, ut maximus neque pellentesque ac. Quisque porta, justo in maximus tincidunt, eros arcu tempus elit, a tristique turpis quam vel lacus. Nulla eleifend felis venenatis nunc ullamcorper cursus. Duis scelerisque consectetur odio, quis aliquet ipsum dictum vel. In dapibus, nisl ut feugiat vehicula, diam justo gravida lorem, id gravida nulla est id est. Donec ut nulla eu urna auctor gravida at eu purus. Etiam nulla dolor, tincidunt a nisl in, porta efficitur felis. Donec pretium lobortis facilisis. ''' } resp = self.client.post('/post', data=data) self.assertIn(b'Test Post', resp.data) def test_get_all_posts(self): self.login('author@example.com', 'Password') data = [ { 'title': 'Test Post2', 'slug': 'Short summary of the post.', 'text': '''Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer bibendum enim id enim tempor, ullamcorper tempor quam tincidunt. Proin eget dapibus arcu. Donec ornare feugiat elit, eu efficitur nisi dictum in. Donec libero nisl, pretium eget placerat nec, tincidunt varius orci. Interdum et malesuada fames ac ante ipsum primis in faucibus. Nunc consequat leo enim, ut maximus neque pellentesque ac. Quisque porta, justo in maximus tincidunt, eros arcu tempus elit, a tristique turpis quam vel lacus. Nulla eleifend felis venenatis nunc ullamcorper cursus. Duis scelerisque consectetur odio, quis aliquet ipsum dictum vel. In dapibus, nisl ut feugiat vehicula, diam justo gravida lorem, id gravida nulla est id est. Donec ut nulla eu urna auctor gravida at eu purus. Etiam nulla dolor, tincidunt a nisl in, porta efficitur felis. Donec pretium lobortis facilisis. ''' }, { 'title': 'Test Post3', 'slug': 'Short summary of the post.', 'text': '''Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer bibendum enim id enim tempor, ullamcorper tempor quam tincidunt. Proin eget dapibus arcu. Donec ornare feugiat elit, eu efficitur nisi dictum in. Donec libero nisl, pretium eget placerat nec, tincidunt varius orci. Interdum et malesuada fames ac ante ipsum primis in faucibus. Nunc consequat leo enim, ut maximus neque pellentesque ac. Quisque porta, justo in maximus tincidunt, eros arcu tempus elit, a tristique turpis quam vel lacus. Nulla eleifend felis venenatis nunc ullamcorper cursus. Duis scelerisque consectetur odio, quis aliquet ipsum dictum vel. In dapibus, nisl ut feugiat vehicula, diam justo gravida lorem, id gravida nulla est id est. Donec ut nulla eu urna auctor gravida at eu purus. Etiam nulla dolor, tincidunt a nisl in, porta efficitur felis. Donec pretium lobortis facilisis. ''' }, { 'title': 'Test Post4', 'slug': 'Short summary of the post.', 'text': '''Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer bibendum enim id enim tempor, ullamcorper tempor quam tincidunt. Proin eget dapibus arcu. Donec ornare feugiat elit, eu efficitur nisi dictum in. Donec libero nisl, pretium eget placerat nec, tincidunt varius orci. Interdum et malesuada fames ac ante ipsum primis in faucibus. Nunc consequat leo enim, ut maximus neque pellentesque ac. Quisque porta, justo in maximus tincidunt, eros arcu tempus elit, a tristique turpis quam vel lacus. Nulla eleifend felis venenatis nunc ullamcorper cursus. Duis scelerisque consectetur odio, quis aliquet ipsum dictum vel. In dapibus, nisl ut feugiat vehicula, diam justo gravida lorem, id gravida nulla est id est. Donec ut nulla eu urna auctor gravida at eu purus. Etiam nulla dolor, tincidunt a nisl in, porta efficitur felis. Donec pretium lobortis facilisis. ''' } ] for d in data: self.client.post('/post', data=d) resp = self.client.get('/blog') self.assertIn(b'Test Post2', resp.data) self.assertIn(b'Test Post3', resp.data) self.assertIn(b'Test Post4', resp.data) def test_get_one_post(self): resp = self.client.get('/blog/1') self.assertIn(b'Title', resp.data) self.assertNotIn(b'Title2', resp.data) ... test_blog_not_logged_in This test attempts to post a new blog post without being logged in. This should return an error message, \"You must be logged in.\" test_blog_logged_in This test attempts to post a new blog entry after logging in. This should succeed, and should reroute the use to the page showing the new post. test_get_all_posts This tests that the blog page returns a list of all the posts. First we add three posts. After we make a request to the blog page and see that all of the posts have been added. test_get_one_post This tests that we can retrieve a single blog post. I'm using one of the posts that was entered during the setUp phase, and I'm also checking that only one post shows up in the response.","title":"Testing the Blog"},{"location":"ch14/#forms","text":"Finally, we need to make some small changes to our forms tests because we designed our form differently last time. I'm including the entire blog_tests.py script this time so you can see it all in one place. blog_tests.py import os from bs4 import BeautifulSoup import unittest from app import app, db from app.models import Entry # Global Test database TEST_DB = 'test.db' class TestBlog(unittest.TestCase): def setUp(self): app.config['TESTING'] = True app.config['WTF_CSRF_ENABLED'] = False app.config['DEBUG'] = False app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///' + \\ os.path.join(app.config['BASEDIR'], TEST_DB) self.client = app.test_client() db.drop_all() db.create_all() db.add_user('author', 'author@example.com', 'Author', 'McAuthorson', 'password', 'password') db.add_post('Title', 'Sluggy', 'The body text.') db.add_post('Title2', 'Sluggy', 'The body text.') def tearDown(self): db.drop_all() ######################## #### Helper Methods #### ######################## def register(self, username, email, fname, lname, password, confirm): return self.app.post( '/register', data = { 'username': username, 'email': email, 'fname': fname, 'lname': lname, 'password': password, 'confirm': confirm }, follow_redirects=True ) def login(self, email, password): return self.app.post( '/login', data = { 'email': email, 'password': password }, follow_redirects=True ) def logout(self): return self.app.get('/logout', follow_redirects = True) ######################### #### Basic Tests #### ######################### def test_home_page_returns(self): resp = self.client.get('/') self.assertEqual(200, resp.status_code) def test_home_page_returns_correct_html(self): resp = self.client.get('/') html = resp.data.decode('utf-8') self.assertTrue(html.startswith('<!DOCTYPE html>')) self.assertIn('<title>Fancy-Pants Blog</title>', html) self.assertTrue(html.endswith('</html>')) def test_menu_text(self): resp = self.client.get('/') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') menu = [link.get_text() for link in soup.select('.menu-item')] self.assertListEqual(['About', 'CV', 'Blog'], menu) def test_menu_links(self): resp = self.client.get('/') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') menu = [link.get('href') for link in soup.select('.menu-item a')] self.assertListEqual(['about', 'cv', 'blog'], menu) def test_heading_no_name(self): resp = self.client.get('/') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') head = soup.h1.get_text() self.assertEqual('Hello Stranger', head) def test_heading_name(self): resp = self.client.get('/Dylan') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') head = soup.h1.get_text() self.assertEqual('Hello Dylan', head) ################################ #### Registration tests #### ################################ def test_valid_registration(self): resp = self.register('tester', 'testy@testing.com', 'Test', 'Tester', 'GoodPassword', 'GoodPassword') self.assertEqual(resp.status_code, 200) self.assertIn(b'Thanks for registering!', resp.data) def test_different_passwords(self): resp = self.register('tester2', 'testy2@testing.com', 'Test', 'Tester', 'GoodPassword', 'BadPassword') self.assertEqual(resp.status_code, 200) self.assertIn(b'Your passwords do not match.', resp.data) def test_duplicate_registrations(self): resp = self.register('author', 'author@example.com', 'Test', 'Tester', 'GoodPassword', 'GoodPassword') self.assertIn(b'User already exists.', resp.data) def test_login_success(self): resp = self.login('author@example.com', 'password') self.assertIn(b'You were successfully logged in', resp.data) def test_login_invalid_email(self): resp = self.login('user17@example.com', 'password') self.assertIn(b'Invalid email.', resp.data) def test_login_invalid_password(self): resp = self.login('author@example.com', 'Paword') self.assertIn(b'Invalid Password.', resp.data) def test_logout(self): self.login('author@example.com', 'password') resp = self.logout() self.assertIn(b'You are logged out.', resp.data) ########################## #### Blog Tests #### ########################## def test_blog_not_logged_in(self): resp = self.client.post('/post', data=dict(title=\"bad\", slug=\"bad\", text=\"bad\")) self.assertIn(b'You must be logged in.', resp.data) def test_blog_logged_in(self): self.login('author@example.com', 'password') data = { 'title': 'Test Post', 'slug': 'Short summary of the post.', 'text': '''Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer bibendum enim id enim tempor, ullamcorper tempor quam tincidunt. Proin eget dapibus arcu. Donec ornare feugiat elit, eu efficitur nisi dictum in. Donec libero nisl, pretium eget placerat nec, tincidunt varius orci. Interdum et malesuada fames ac ante ipsum primis in faucibus. Nunc consequat leo enim, ut maximus neque pellentesque ac. Quisque porta, justo in maximus tincidunt, eros arcu tempus elit, a tristique turpis quam vel lacus. Nulla eleifend felis venenatis nunc ullamcorper cursus. Duis scelerisque consectetur odio, quis aliquet ipsum dictum vel. In dapibus, nisl ut feugiat vehicula, diam justo gravida lorem, id gravida nulla est id est. Donec ut nulla eu urna auctor gravida at eu purus. Etiam nulla dolor, tincidunt a nisl in, porta efficitur felis. Donec pretium lobortis facilisis. ''' } resp = self.client.post('/post', data=data) self.assertIn(b'Test Post', resp.data) def test_get_all_posts(self): self.login('author@example.com', 'Password') data = [ { 'title': 'Test Post2', 'slug': 'Short summary of the post.', 'text': '''Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer bibendum enim id enim tempor, ullamcorper tempor quam tincidunt. Proin eget dapibus arcu. Donec ornare feugiat elit, eu efficitur nisi dictum in. Donec libero nisl, pretium eget placerat nec, tincidunt varius orci. Interdum et malesuada fames ac ante ipsum primis in faucibus. Nunc consequat leo enim, ut maximus neque pellentesque ac. Quisque porta, justo in maximus tincidunt, eros arcu tempus elit, a tristique turpis quam vel lacus. Nulla eleifend felis venenatis nunc ullamcorper cursus. Duis scelerisque consectetur odio, quis aliquet ipsum dictum vel. In dapibus, nisl ut feugiat vehicula, diam justo gravida lorem, id gravida nulla est id est. Donec ut nulla eu urna auctor gravida at eu purus. Etiam nulla dolor, tincidunt a nisl in, porta efficitur felis. Donec pretium lobortis facilisis. ''' }, { 'title': 'Test Post3', 'slug': 'Short summary of the post.', 'text': '''Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer bibendum enim id enim tempor, ullamcorper tempor quam tincidunt. Proin eget dapibus arcu. Donec ornare feugiat elit, eu efficitur nisi dictum in. Donec libero nisl, pretium eget placerat nec, tincidunt varius orci. Interdum et malesuada fames ac ante ipsum primis in faucibus. Nunc consequat leo enim, ut maximus neque pellentesque ac. Quisque porta, justo in maximus tincidunt, eros arcu tempus elit, a tristique turpis quam vel lacus. Nulla eleifend felis venenatis nunc ullamcorper cursus. Duis scelerisque consectetur odio, quis aliquet ipsum dictum vel. In dapibus, nisl ut feugiat vehicula, diam justo gravida lorem, id gravida nulla est id est. Donec ut nulla eu urna auctor gravida at eu purus. Etiam nulla dolor, tincidunt a nisl in, porta efficitur felis. Donec pretium lobortis facilisis. ''' }, { 'title': 'Test Post4', 'slug': 'Short summary of the post.', 'text': '''Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer bibendum enim id enim tempor, ullamcorper tempor quam tincidunt. Proin eget dapibus arcu. Donec ornare feugiat elit, eu efficitur nisi dictum in. Donec libero nisl, pretium eget placerat nec, tincidunt varius orci. Interdum et malesuada fames ac ante ipsum primis in faucibus. Nunc consequat leo enim, ut maximus neque pellentesque ac. Quisque porta, justo in maximus tincidunt, eros arcu tempus elit, a tristique turpis quam vel lacus. Nulla eleifend felis venenatis nunc ullamcorper cursus. Duis scelerisque consectetur odio, quis aliquet ipsum dictum vel. In dapibus, nisl ut feugiat vehicula, diam justo gravida lorem, id gravida nulla est id est. Donec ut nulla eu urna auctor gravida at eu purus. Etiam nulla dolor, tincidunt a nisl in, porta efficitur felis. Donec pretium lobortis facilisis. ''' } ] for d in data: self.client.post('/post', data=d) resp = self.client.get('/blog') self.assertIn(b'Test Post2', resp.data) self.assertIn(b'Test Post3', resp.data) self.assertIn(b'Test Post4', resp.data) def test_get_one_post(self): resp = self.client.get('/blog/1') self.assertIn(b'Title', resp.data) self.assertNotIn(b'Title2', resp.data) ########################## #### Form Tests #### ########################## def test_form(self): resp = self.client.get('/post') html = resp.data.decode('utf-8') self.assertIn('<form method=\"POST\">', html) self.assertIn('</form>', html) def test_form_fields(self): resp = self.client.get('/post') html = resp.data.decode('utf-8') soup = BeautifulSoup(html, 'html.parser') fields = [i.attrs['name'] for i in soup.find_all('input')] self.assertListEqual(fields[1:], ['post_title', 'slug', 'submit']) self.assertEqual(soup.textarea.attrs['name'], 'text') Now let's run those tests and see that they fail with errors. In the next section, I'll build out my code and get these tests to pass. (env) ~/Projects/blog$ python -m unittest tests/blog_tests.py E ====================================================================== ERROR: blog_tests (unittest.loader._FailedTest) ---------------------------------------------------------------------- ImportError: Failed to import test module: blog_tests Traceback (most recent call last): File \"/usr/lib/python3.6/unittest/loader.py\", line 153, in loadTestsFromName module = __import__(module_name) File \"Projects/blog/tests/blog_tests.py\", line 4, in <module> from app import app, db ImportError: cannot import name 'db' ---------------------------------------------------------------------- Ran 1 test in 0.000s FAILED (errors=1)","title":"Forms"},{"location":"ch2/","text":"Types of Tests In the first chapter we looked at an example of how to use a few different tools to test our programs. We saw how we might write a set of tests first before we write any code, and then write our code so that it passes the unit tests. We do this for a few reasons. Tests force us to think of testable actions our code might perform. This means we need to figure out what specific action or output our code should have before we write it. That's a good practice. Tests force us to consider what conditions should be passing and what conditions should be failing for our code. Tests will tell us immediately when we have written enough code. Tests can help us constrain how many features our code base has. We can only build what we've written tests for. Tests yield less buggy code and cut down on debugging time. We know our code works when it passes the tests. Now does this all mean that TDD will give us perfect code? No, it's intirely possible to write code that is full of bugs that still passes our tests and functions. There are four main categories of tests: unit tests, functional tests, and end-to-end tests. An important concept to understand before we dive into these approaches is white box and black box testing. White box testing is concerned with the inner workings of your application. This means that it tests how your functions are doing the work that they are supposed to do. White box testing cares about the code itself. Black box testing, on the other hand, is concerned with whether your application works or not. This is an important distinction, and you might think of it in these terms. Developers are concerned with white box testing because it ensures that their code has minimal bugs and achieves the correct results the way it's supposed to. Business managers are concerned with black box testing because it ensures that the code is meeting the product requirements. Unit Testing Unit testing is white box testing and involves testing individual units or individual processes in your code free from their dependencies. A good way to think about this is that unit testing should test individual funtions--even if that function is never called independently by the user. In the last chapter, I walked through the process of writing tests for a particular function, but let's look at another example. Let's say we are working on a project to build word cloud visualizations. These word clouds display the words in a text in a cloud pattern sized by frequency of each word. If we decided not to use the builtin count function in Python, we could go about building our own. This means I need a function that will take a given text, iterate through the words and count the frequency of each word. I also don't want to use the count function (for this example at least). I also want the function to be able to adjust for case sensitivity or not. Here are pre and post conditions that should be present if this function works correctly: The function should take a string as an input. It may or may not take a case as a second input, but that second input must be a boolean. The function should return some code if the input is wrong. The function should return a dictionary with words as keys and their count as values for each word in the text passage. This means I'll have seven tests that will, when passing, show me that under the right circumstances, my function is working, and if the wrong input is given to my function, it returns the right error code. Let's write some tests together again. I'll go wordcloud_tests.py import unittest import wordcloud as t class TestWordCloud(unittest.TestCase): def setUp(self): self.text = \"Peter peter of Pickeled Pepper pepper Pepper\" self.sensitive = { 'Peter': 1, 'peter': 1, 'of': 1, 'Pickeled': 1, 'Pepper': 2, 'pepper': 2 } self.insensitive = { 'peter': 2, 'of': 1, 'pickeled': 1, 'pepper': 4 } def test_returns_error_code_on_bad_text(self): self.assertEqual(t.word_count(1), -1) def test_returns_error_code_on_bad_case(self): self.assertEqual(t.word_count('Pass', 11), -1) def test_case_sensitive(self): self.assertEqual(t.word_count(self.text, True), self.sensitive) def test_case_insensitve(self): self.assertEqual(t.word_count(self.text), self.insensitive) There are two options when writing tests and writing production code. You can either write a test, then write code to pass the test, then write another test and get that one to pass, or you can write a set of tests for one particular function and then write code to get them all to pass. In this case, I wrote all of my tests first, and it gives me a sort of todo list. I know I have to write code to get all of these tests to pass, and I should only write that much code. First I'll write the code that gets the first two tests passing. wordcloud.py def word_count(text, case): return -1 The first two tests will pass, but the second two tests will fail once I've written this code. Notice that I don't have any logic in this function, but simply a return statement that will pass the test. I like this approach because it is very little code to write, and still it satisfies the test cases. Next I want to write the code to get the case sensitive version to work. wordcloud.py def word_count(text, case): if isinstance(text, str) and isinstance(case, bool): counts = {} for word in text.split(): if word in counts.keys(): counts[word] += 1 else: counts[word] = 1 return counts return -1 Once again, you can try this out, but all of the tests except for the last one should be passing now. We're making progress, but now I need to think about how I want to implement the case where we don't want to be case sensitive. An easy way to do this is simply set all the words to lower case and then use the same logic as above. def word_count(text, case): if isinstance(text, str) and isinstance(case, bool): counts = {} if not case: text = text.lower() for word in text.split(): if word in counts.keys(): counts[word] += 1 else: counts[word] = 1 return counts return -1 Now all of my tests are passing, but there's one more feature I want to add. Since word clouds often are used to show the importance of meaningful words, I want to not count words that contain digits or are just string representations of numbers. So if my text included \"dinn3r\" or \"2\", those strings should be ignored. I might be tempted to implement this directly, but I need to write tests first, and I'll just add them to the test code I already have (notice I changed the text to be checked): wordcloud_tests.py import unittest import wordcloud as t class TestWordCloud(unittest.TestCase): def setUp(self): self.text = \"Peter peter of Pickeled \\ Pepper pepper Pepper 123 p3pper\" self.sensitive = { 'Peter': 1, 'peter': 1, 'of': 1, 'Pickeled': 1, 'Pepper': 2, 'pepper': 2 } self.insensitive = { 'peter': 2, 'of': 1, 'pickeled': 1, 'pepper': 4 } def test_returns_error_code_on_bad_text(self): self.assertEqual(t.word_count(1), -1) def test_returns_error_code_on_bad_case(self): self.assertEqual(t.word_count('Pass', 11), -1) def test_case_sensitive(self): self.assertEqual(t.word_count(self.text, True), self.sensitive) def test_case_insensitve(self): self.assertEqual(t.word_count(self.text), self.insensitive) def test_ignores_digits(self): self.assertEqual(t.word_count(self.text), self.insensitive) Next, write code to get that test to pass. wordcloud.py def word_count(text, case): if isinstance(text, str) and isinstance(case, bool): counts = {} if not case: text = text.lower() for word in text.split(): # make sure no characters in the word are digits if not any(map(word.isdigit, word)): if word in counts.keys(): counts[word] += 1 else: counts[word] = 1 return counts return -1 All of my tests are passing now, so basically I know that my code is working as expected. I haven't done anything to ensure that the user uses the code correctly, but at this point that's okay. There's just one more small change I would like to make and add some documentation. I want to make case a kwarg instead of an arg. I want to do this so I can set a default setting. I want the function to not be case sensitive unless it is asked to be sensitive. Kwargs are cool because you can set a default value for an argument, and that makes it so that we don't need to pass True or False to the function in some of the cases. Only when we want to be case sensitive. I made a small refactor as below with documentation added. wordcloud.py def word_count(text, case=False): \"\"\" This function calculates word frequency in a text. This function should not count digit strings. Args: text (str): the text to be searched. Kwargs: case (bool): Should the search be case sensive Returns: dict. counts keyed by word, or return code:: -1 -- Error \"\"\" if isinstance(text, str) and isinstance(case, bool): counts = {} for word in text.split(): if not any(map(word.isdigit, word)): if not case: word = word.lower() if word in counts.keys(): counts[word] += 1 else: counts[word] = 1 return counts return -1 Functional Testing If unit tests test to see if the code is working correctly, functional tests test to see if a particular functionality of a program is working correctly. This means we are not so concerned with the inner workings of our functions, but instead we are concerned with the functions that an application provides a user. We will cover functional tests as we start building our Flask app, but imagine for now our word cloud application. The user enters a text file and the application creates an image object based on the text. For a functional test, I'd create a mockup of an expected image object based on a particular text, and then pass that text to the function and compare the output with the expected like so: functional_tests.py import unittest import wordcloud as t class TestWordCloudFunctional(unittest.TestCase): def setUp(self): self.text = \"My text ...\" self.cloud = '' with open('img.png', 'rb') as f: self.cloud = f.read() def test_can_create_word_cloud(self): self.assertEqual(t.make_cloud(self.text), self.cloud) I'm imagining that we'll have to create a function called make_cloud, which probably will call the word_cound and so on. End to End (E2E) Testing These tests make use of the user interface that you've developed and are like functional tests, but instead of testing one function of your code, they would test a sequence of functions that a user might use. For instance, if I was making a calculator, my E2E test might begin by launching the calculator, perform a series of calculations and then close the calculator. Alternatively, if I was creating a sign-up function for a website, an E2E test would test that through the user interface a new user can be created, saved to whatever storage solution we have for that data, test the user can login, and then log back out again. We won't be developing any E2E tests in this class because we'll be focusing on a very small application that can be tested with functional and unit tests.","title":"2. Types of Tests"},{"location":"ch2/#types-of-tests","text":"In the first chapter we looked at an example of how to use a few different tools to test our programs. We saw how we might write a set of tests first before we write any code, and then write our code so that it passes the unit tests. We do this for a few reasons. Tests force us to think of testable actions our code might perform. This means we need to figure out what specific action or output our code should have before we write it. That's a good practice. Tests force us to consider what conditions should be passing and what conditions should be failing for our code. Tests will tell us immediately when we have written enough code. Tests can help us constrain how many features our code base has. We can only build what we've written tests for. Tests yield less buggy code and cut down on debugging time. We know our code works when it passes the tests. Now does this all mean that TDD will give us perfect code? No, it's intirely possible to write code that is full of bugs that still passes our tests and functions. There are four main categories of tests: unit tests, functional tests, and end-to-end tests. An important concept to understand before we dive into these approaches is white box and black box testing. White box testing is concerned with the inner workings of your application. This means that it tests how your functions are doing the work that they are supposed to do. White box testing cares about the code itself. Black box testing, on the other hand, is concerned with whether your application works or not. This is an important distinction, and you might think of it in these terms. Developers are concerned with white box testing because it ensures that their code has minimal bugs and achieves the correct results the way it's supposed to. Business managers are concerned with black box testing because it ensures that the code is meeting the product requirements.","title":"Types of Tests"},{"location":"ch2/#unit-testing","text":"Unit testing is white box testing and involves testing individual units or individual processes in your code free from their dependencies. A good way to think about this is that unit testing should test individual funtions--even if that function is never called independently by the user. In the last chapter, I walked through the process of writing tests for a particular function, but let's look at another example. Let's say we are working on a project to build word cloud visualizations. These word clouds display the words in a text in a cloud pattern sized by frequency of each word. If we decided not to use the builtin count function in Python, we could go about building our own. This means I need a function that will take a given text, iterate through the words and count the frequency of each word. I also don't want to use the count function (for this example at least). I also want the function to be able to adjust for case sensitivity or not. Here are pre and post conditions that should be present if this function works correctly: The function should take a string as an input. It may or may not take a case as a second input, but that second input must be a boolean. The function should return some code if the input is wrong. The function should return a dictionary with words as keys and their count as values for each word in the text passage. This means I'll have seven tests that will, when passing, show me that under the right circumstances, my function is working, and if the wrong input is given to my function, it returns the right error code. Let's write some tests together again. I'll go wordcloud_tests.py import unittest import wordcloud as t class TestWordCloud(unittest.TestCase): def setUp(self): self.text = \"Peter peter of Pickeled Pepper pepper Pepper\" self.sensitive = { 'Peter': 1, 'peter': 1, 'of': 1, 'Pickeled': 1, 'Pepper': 2, 'pepper': 2 } self.insensitive = { 'peter': 2, 'of': 1, 'pickeled': 1, 'pepper': 4 } def test_returns_error_code_on_bad_text(self): self.assertEqual(t.word_count(1), -1) def test_returns_error_code_on_bad_case(self): self.assertEqual(t.word_count('Pass', 11), -1) def test_case_sensitive(self): self.assertEqual(t.word_count(self.text, True), self.sensitive) def test_case_insensitve(self): self.assertEqual(t.word_count(self.text), self.insensitive) There are two options when writing tests and writing production code. You can either write a test, then write code to pass the test, then write another test and get that one to pass, or you can write a set of tests for one particular function and then write code to get them all to pass. In this case, I wrote all of my tests first, and it gives me a sort of todo list. I know I have to write code to get all of these tests to pass, and I should only write that much code. First I'll write the code that gets the first two tests passing. wordcloud.py def word_count(text, case): return -1 The first two tests will pass, but the second two tests will fail once I've written this code. Notice that I don't have any logic in this function, but simply a return statement that will pass the test. I like this approach because it is very little code to write, and still it satisfies the test cases. Next I want to write the code to get the case sensitive version to work. wordcloud.py def word_count(text, case): if isinstance(text, str) and isinstance(case, bool): counts = {} for word in text.split(): if word in counts.keys(): counts[word] += 1 else: counts[word] = 1 return counts return -1 Once again, you can try this out, but all of the tests except for the last one should be passing now. We're making progress, but now I need to think about how I want to implement the case where we don't want to be case sensitive. An easy way to do this is simply set all the words to lower case and then use the same logic as above. def word_count(text, case): if isinstance(text, str) and isinstance(case, bool): counts = {} if not case: text = text.lower() for word in text.split(): if word in counts.keys(): counts[word] += 1 else: counts[word] = 1 return counts return -1 Now all of my tests are passing, but there's one more feature I want to add. Since word clouds often are used to show the importance of meaningful words, I want to not count words that contain digits or are just string representations of numbers. So if my text included \"dinn3r\" or \"2\", those strings should be ignored. I might be tempted to implement this directly, but I need to write tests first, and I'll just add them to the test code I already have (notice I changed the text to be checked): wordcloud_tests.py import unittest import wordcloud as t class TestWordCloud(unittest.TestCase): def setUp(self): self.text = \"Peter peter of Pickeled \\ Pepper pepper Pepper 123 p3pper\" self.sensitive = { 'Peter': 1, 'peter': 1, 'of': 1, 'Pickeled': 1, 'Pepper': 2, 'pepper': 2 } self.insensitive = { 'peter': 2, 'of': 1, 'pickeled': 1, 'pepper': 4 } def test_returns_error_code_on_bad_text(self): self.assertEqual(t.word_count(1), -1) def test_returns_error_code_on_bad_case(self): self.assertEqual(t.word_count('Pass', 11), -1) def test_case_sensitive(self): self.assertEqual(t.word_count(self.text, True), self.sensitive) def test_case_insensitve(self): self.assertEqual(t.word_count(self.text), self.insensitive) def test_ignores_digits(self): self.assertEqual(t.word_count(self.text), self.insensitive) Next, write code to get that test to pass. wordcloud.py def word_count(text, case): if isinstance(text, str) and isinstance(case, bool): counts = {} if not case: text = text.lower() for word in text.split(): # make sure no characters in the word are digits if not any(map(word.isdigit, word)): if word in counts.keys(): counts[word] += 1 else: counts[word] = 1 return counts return -1 All of my tests are passing now, so basically I know that my code is working as expected. I haven't done anything to ensure that the user uses the code correctly, but at this point that's okay. There's just one more small change I would like to make and add some documentation. I want to make case a kwarg instead of an arg. I want to do this so I can set a default setting. I want the function to not be case sensitive unless it is asked to be sensitive. Kwargs are cool because you can set a default value for an argument, and that makes it so that we don't need to pass True or False to the function in some of the cases. Only when we want to be case sensitive. I made a small refactor as below with documentation added. wordcloud.py def word_count(text, case=False): \"\"\" This function calculates word frequency in a text. This function should not count digit strings. Args: text (str): the text to be searched. Kwargs: case (bool): Should the search be case sensive Returns: dict. counts keyed by word, or return code:: -1 -- Error \"\"\" if isinstance(text, str) and isinstance(case, bool): counts = {} for word in text.split(): if not any(map(word.isdigit, word)): if not case: word = word.lower() if word in counts.keys(): counts[word] += 1 else: counts[word] = 1 return counts return -1","title":"Unit Testing"},{"location":"ch2/#functional-testing","text":"If unit tests test to see if the code is working correctly, functional tests test to see if a particular functionality of a program is working correctly. This means we are not so concerned with the inner workings of our functions, but instead we are concerned with the functions that an application provides a user. We will cover functional tests as we start building our Flask app, but imagine for now our word cloud application. The user enters a text file and the application creates an image object based on the text. For a functional test, I'd create a mockup of an expected image object based on a particular text, and then pass that text to the function and compare the output with the expected like so: functional_tests.py import unittest import wordcloud as t class TestWordCloudFunctional(unittest.TestCase): def setUp(self): self.text = \"My text ...\" self.cloud = '' with open('img.png', 'rb') as f: self.cloud = f.read() def test_can_create_word_cloud(self): self.assertEqual(t.make_cloud(self.text), self.cloud) I'm imagining that we'll have to create a function called make_cloud, which probably will call the word_cound and so on.","title":"Functional Testing"},{"location":"ch2/#end-to-end-e2e-testing","text":"These tests make use of the user interface that you've developed and are like functional tests, but instead of testing one function of your code, they would test a sequence of functions that a user might use. For instance, if I was making a calculator, my E2E test might begin by launching the calculator, perform a series of calculations and then close the calculator. Alternatively, if I was creating a sign-up function for a website, an E2E test would test that through the user interface a new user can be created, saved to whatever storage solution we have for that data, test the user can login, and then log back out again. We won't be developing any E2E tests in this class because we'll be focusing on a very small application that can be tested with functional and unit tests.","title":"End to End (E2E) Testing"},{"location":"ch3/","text":"Introduction to Objects One of the major paradigms in programming is object oriented programming (OOP). This approach to programming attempts to bundle data and functionality into generalized objects. It is worth noting that this approach is more popular in server-side programming and in applications that run on a local machine rather than client side websites. This is because websites cannot rely on every client to have the same data stored, and because the web is sometimes fundamentally described as stateless . We're discussing a little bit of OOP here because when you use flask later on, you will be instantiating a Flask object, and understanding what that means will help you better understand how flask works. An object is a set of data and methods taht are collected together. A good way to think of it, but perhaps not a good way to think of it, is to use a car as an example. A car has a bunch of properties (wheels, seats, an engine, air conditioning, etc.). It also has a bunch of methods, perhaps related to those properties, like driving, honking, braking, etc. The key is that the object defines these properties and methods as existing as a sort of blueprint or template. Then when we use the object in our code, we create an instance with specific values. Here's what our object might look like in Python: Car.py class Car: def __init__(self, color, max_speed, horn): # These are variables that store the color # maximum speed, and sound the horn makes. self.color = color self.current_speed = 0 self.max_speed = max_speed self.horn = horn def get_horn(self): return self.horn def get_color(self): return self.color def get_speed(self): return self.current_speed def accelerate(self) # Increases speed by 1 until max speed is reached while self.current_speed <= self.max_speed: self.current_speed += 1 The first line in the snippet above defines the class using the class keyword and then the class name. The name Car is arbitrary in the same way variable names are arbitrary. They cannot be reserved words in Python, but they can be any other words. It is conventional to capitalize the first letter of every word in class names. After the class name, we might have a set of parentheses in which we place the name of another object that this one inherits from. Don't worry too much about this, but be aware that it might exist and you'll see it in Flask. You'll notice next that everything below the first line is indented, which means it is part of the block that defines this particular class. The first part of the class definition you'll recognize as a function by the keyword def . __init__ is a special function, and it is called the constructor . The constructor is a special method or function that is automatically called when an object defined by this class is constructed . I'll explain this in a moment, but for now, remember that it's a special function that's automatically called. In Python, the constructor will always be called __init__ . You'll notice above that the Car object has four properties (or four variables that will hold data): color, current_speed, max_speed, and horn. Likewise, the Car object has four methods (or actions that can be performed): three get methods that return the value stored in each of the properties, and an accelerate method that increments the current_speed property until it reaches max_speed. You've probably encountered methods before. If you recall, there are a bunch of methods we can do to a string: my_string.upper() is one example. What's happening is this this: my_string is an instance of the String object, which has a method called upper() that converts all of the characters to upper case. Likewise, the Car class has a method called accelerate. When we call my_car.accelarate() , you guessed it, the property my_car.current_speed is incremented until it reaches my_car.max_speed . One other thing you might've noticed is this weird parameter self , which is included in each of the functions. Hold tight and I'll explain that below after we get to creating specific instances of the class. As I said above, the properties of the class are variables, which means in the class definition, they contain no value. Instead, they are empty boxes that could have values put in them. In the computer, what's happening is these names point to the address in memory (RAM) where that data could be stored. When we use this class to create a specific car (instead of the general Car prototype), we create a spot in memory that contains instructions to do the car methods, and addresses to store the specific properties of this car. Let me give you an example to make this clear. I'll show you what this looks like in the Python interpreter first. >>> from Car import Car >>> my_car = Car('blue', 1000, 'beep beep') >>> my_second_car = Car('red', 10, 'honk honk') >>> print(my_car.get_horn()) beep beep >>> print(my_second_car.get_horn()) honk honk >>> There are a few things to notice. First, I have imported the Car class from a file called Car.py. When I do this, the file is read into memory and Car becomes a known class in the same way as when you define a function. However, that class is a blueprint and contains no data initially. It's not specific cars, it's the generic model of a car. In the next line my_car = Car('blue', 1000, 'beep beep') a specific car is made. This is also called instantiation . An instance of the Car class is constructed. Here's the process. We begin with the right side of the assignment ( = ) operator and we see Car('blue', 1000, 'beep beep') . This tells the interpreter first to find a class definition called Car . Since we imported that before, the interpreter will know about that. Immediately a copy of the blueprint is established and the __init__ function is called (the constructor is called). You'll notice that the constructor takes 3 parameters (plus self), and you'll notice we passed three values (blue, 1000, and beep beep) when we called the class. The constructor takes these three values just as any function would take values for its parameters. The constructor executes. A variable called self.color is assigned the value 'blue' , self.current_speed is assigned the value 0, and so on. I'll explain self after this list of steps. After the constructor runs, the copy of the blueprint created in step two now has values stored in its variables. It also has methods. The constructed object that was built on steps 1-4 is stored to memory with the variable named my_car attached. Note: the Car class definition is not changed. It still is a blueprint. my_car is an instance of Car, or a set of values and methods defined by the Car class and set up by the constructor in step 3. The next line repeats these steps for a second instance of Car and stores that second instance to a variable my_second_car . Again, the Car class definition doesn't change, and we have two instances based off of the same class with different values stored their properties. The remaining lines of the example simply show the output of the get_horn() method for each instance. The function works the same way for both instances returning the value stored in the self.horn property, but you'll note that the values are unique to the instance. Self Before we go further, I need to talk a bit about self . This often is a tricky concept. First, we need a little review on scope. If you recall, scope defines where a variable is accessible from. For instance, in the following example: >>> num = 0 >>> def myfun(): ... num = 5 ... return num >>> print(num) 0 >>> print(myfun()) 5 >>> num = myfun() >>> print(num) 5 the first num is a global variable and is accessible in the global scope. The second num inside of myfun() is a local variable and is pointing to a different address in memory than the first num . The following lines prove that those two variables are different. Also, you'll recall that variables are only accessible in the scope in which they are defined. The same is true with classes. Class properties are variables that are accessible anywhere in the class. Each method might also have local variables that are accessible only within that method. When the class is instantiated, the class properties are populated with values. So where does self come in? self references this current instance of the class. So, in the car example above, the value stored in my_car 's self.color would be 'blue'. There are a few things: each method within a class must at least take self as a parameter. This is how the method gains access to the instance's properties and methods. Second, and this is really important, local variables disappear when they go out of scope. Class variables identified by self remain until the instance of the class is deleted. This means in the above example that when any instance of the car is instantiated, the value for self.current_speed is 0. When we call accelerate() for that instance the value for that instance of self.current_speed is incremented until it reaches the self.max_speed , and it stays at that value until it is changed again or the instance is deleted. It does not revert back to zero after accelerate() stops running. Visibility In some programming languages, the notion of scope is taken a bit more seriously, and we can use objects to protect or hide the values stored in various parameters. I'll give you an example that's a bit of a digression, but let's look at the car example in C++: car.cpp class Car { public: Car(string color, int max_speed, string horn) { this.color = color; this.current_speed = 0; this.max_speed = max_speed; this.horn = horn; } string get_horn() { return this.horn; } string get_color() { return this.color; } int get_speed(self) { return self.current_speed; } void accelerate() { while (this.current_speed <= this.max_speed) { this.current_speed++; } } private: string horn; string color; int current_speed; int max_speed; }; int main() { Car my_car = new Car(\"blue\", 40, 'beep beep'); cout << \"The color is: \" << my_car.get_color() << endl; // This next line will not work because color is private. cout << \"The color is: \" << my_car.color << endl; } In the class above, all of my object properties are called \"private\" properties, which means they cannot be accessed directly from outside of the class. Instead, I use getter methods to return the values. This is useful because you can control how the properties are changed or retrieved. Likewise, methods could be set as private or protected. I'm not going to go into that here, but if you're interested in all of the features of object oriented programming, it is worth reading up on. While languages like Java and C++ allow you to make properties and methods private, Python doesn't do that. All properties are accessible anywhere. In practice, if you want a method to be treated as private, you must start its name with an underscore. So to denote accelerate() as private, the definition line in Python would look like this: python def _accelerate(self): . This doesn't mean it cannot be accessed from outside the class, but it does tell developers that it shouldn't be accessed directly. Instead, maybe you have another method from within the class that can access it. We won't be dealing with any of this in this book, but it is useful to know that one of the major reason we use objects, besides to collect data and methods into single units. Conclusion Object oriented programming, or designing your system around a number of classes, is a popular paradigm. I would encourage you to research it further. In the next chapter, I'm going to walk through an example of building a class using Test Driven Development that builds on the prime_factors function from the first chapter. However, for our purposes, we'll be using classes, but we won't be going to far down the OOP path. You will have a better sense now of what's happening when we say app = Flask(__name__) .","title":"3. Intro to Objects"},{"location":"ch3/#introduction-to-objects","text":"One of the major paradigms in programming is object oriented programming (OOP). This approach to programming attempts to bundle data and functionality into generalized objects. It is worth noting that this approach is more popular in server-side programming and in applications that run on a local machine rather than client side websites. This is because websites cannot rely on every client to have the same data stored, and because the web is sometimes fundamentally described as stateless . We're discussing a little bit of OOP here because when you use flask later on, you will be instantiating a Flask object, and understanding what that means will help you better understand how flask works. An object is a set of data and methods taht are collected together. A good way to think of it, but perhaps not a good way to think of it, is to use a car as an example. A car has a bunch of properties (wheels, seats, an engine, air conditioning, etc.). It also has a bunch of methods, perhaps related to those properties, like driving, honking, braking, etc. The key is that the object defines these properties and methods as existing as a sort of blueprint or template. Then when we use the object in our code, we create an instance with specific values. Here's what our object might look like in Python: Car.py class Car: def __init__(self, color, max_speed, horn): # These are variables that store the color # maximum speed, and sound the horn makes. self.color = color self.current_speed = 0 self.max_speed = max_speed self.horn = horn def get_horn(self): return self.horn def get_color(self): return self.color def get_speed(self): return self.current_speed def accelerate(self) # Increases speed by 1 until max speed is reached while self.current_speed <= self.max_speed: self.current_speed += 1 The first line in the snippet above defines the class using the class keyword and then the class name. The name Car is arbitrary in the same way variable names are arbitrary. They cannot be reserved words in Python, but they can be any other words. It is conventional to capitalize the first letter of every word in class names. After the class name, we might have a set of parentheses in which we place the name of another object that this one inherits from. Don't worry too much about this, but be aware that it might exist and you'll see it in Flask. You'll notice next that everything below the first line is indented, which means it is part of the block that defines this particular class. The first part of the class definition you'll recognize as a function by the keyword def . __init__ is a special function, and it is called the constructor . The constructor is a special method or function that is automatically called when an object defined by this class is constructed . I'll explain this in a moment, but for now, remember that it's a special function that's automatically called. In Python, the constructor will always be called __init__ . You'll notice above that the Car object has four properties (or four variables that will hold data): color, current_speed, max_speed, and horn. Likewise, the Car object has four methods (or actions that can be performed): three get methods that return the value stored in each of the properties, and an accelerate method that increments the current_speed property until it reaches max_speed. You've probably encountered methods before. If you recall, there are a bunch of methods we can do to a string: my_string.upper() is one example. What's happening is this this: my_string is an instance of the String object, which has a method called upper() that converts all of the characters to upper case. Likewise, the Car class has a method called accelerate. When we call my_car.accelarate() , you guessed it, the property my_car.current_speed is incremented until it reaches my_car.max_speed . One other thing you might've noticed is this weird parameter self , which is included in each of the functions. Hold tight and I'll explain that below after we get to creating specific instances of the class. As I said above, the properties of the class are variables, which means in the class definition, they contain no value. Instead, they are empty boxes that could have values put in them. In the computer, what's happening is these names point to the address in memory (RAM) where that data could be stored. When we use this class to create a specific car (instead of the general Car prototype), we create a spot in memory that contains instructions to do the car methods, and addresses to store the specific properties of this car. Let me give you an example to make this clear. I'll show you what this looks like in the Python interpreter first. >>> from Car import Car >>> my_car = Car('blue', 1000, 'beep beep') >>> my_second_car = Car('red', 10, 'honk honk') >>> print(my_car.get_horn()) beep beep >>> print(my_second_car.get_horn()) honk honk >>> There are a few things to notice. First, I have imported the Car class from a file called Car.py. When I do this, the file is read into memory and Car becomes a known class in the same way as when you define a function. However, that class is a blueprint and contains no data initially. It's not specific cars, it's the generic model of a car. In the next line my_car = Car('blue', 1000, 'beep beep') a specific car is made. This is also called instantiation . An instance of the Car class is constructed. Here's the process. We begin with the right side of the assignment ( = ) operator and we see Car('blue', 1000, 'beep beep') . This tells the interpreter first to find a class definition called Car . Since we imported that before, the interpreter will know about that. Immediately a copy of the blueprint is established and the __init__ function is called (the constructor is called). You'll notice that the constructor takes 3 parameters (plus self), and you'll notice we passed three values (blue, 1000, and beep beep) when we called the class. The constructor takes these three values just as any function would take values for its parameters. The constructor executes. A variable called self.color is assigned the value 'blue' , self.current_speed is assigned the value 0, and so on. I'll explain self after this list of steps. After the constructor runs, the copy of the blueprint created in step two now has values stored in its variables. It also has methods. The constructed object that was built on steps 1-4 is stored to memory with the variable named my_car attached. Note: the Car class definition is not changed. It still is a blueprint. my_car is an instance of Car, or a set of values and methods defined by the Car class and set up by the constructor in step 3. The next line repeats these steps for a second instance of Car and stores that second instance to a variable my_second_car . Again, the Car class definition doesn't change, and we have two instances based off of the same class with different values stored their properties. The remaining lines of the example simply show the output of the get_horn() method for each instance. The function works the same way for both instances returning the value stored in the self.horn property, but you'll note that the values are unique to the instance.","title":"Introduction to Objects"},{"location":"ch3/#self","text":"Before we go further, I need to talk a bit about self . This often is a tricky concept. First, we need a little review on scope. If you recall, scope defines where a variable is accessible from. For instance, in the following example: >>> num = 0 >>> def myfun(): ... num = 5 ... return num >>> print(num) 0 >>> print(myfun()) 5 >>> num = myfun() >>> print(num) 5 the first num is a global variable and is accessible in the global scope. The second num inside of myfun() is a local variable and is pointing to a different address in memory than the first num . The following lines prove that those two variables are different. Also, you'll recall that variables are only accessible in the scope in which they are defined. The same is true with classes. Class properties are variables that are accessible anywhere in the class. Each method might also have local variables that are accessible only within that method. When the class is instantiated, the class properties are populated with values. So where does self come in? self references this current instance of the class. So, in the car example above, the value stored in my_car 's self.color would be 'blue'. There are a few things: each method within a class must at least take self as a parameter. This is how the method gains access to the instance's properties and methods. Second, and this is really important, local variables disappear when they go out of scope. Class variables identified by self remain until the instance of the class is deleted. This means in the above example that when any instance of the car is instantiated, the value for self.current_speed is 0. When we call accelerate() for that instance the value for that instance of self.current_speed is incremented until it reaches the self.max_speed , and it stays at that value until it is changed again or the instance is deleted. It does not revert back to zero after accelerate() stops running.","title":"Self"},{"location":"ch3/#visibility","text":"In some programming languages, the notion of scope is taken a bit more seriously, and we can use objects to protect or hide the values stored in various parameters. I'll give you an example that's a bit of a digression, but let's look at the car example in C++: car.cpp class Car { public: Car(string color, int max_speed, string horn) { this.color = color; this.current_speed = 0; this.max_speed = max_speed; this.horn = horn; } string get_horn() { return this.horn; } string get_color() { return this.color; } int get_speed(self) { return self.current_speed; } void accelerate() { while (this.current_speed <= this.max_speed) { this.current_speed++; } } private: string horn; string color; int current_speed; int max_speed; }; int main() { Car my_car = new Car(\"blue\", 40, 'beep beep'); cout << \"The color is: \" << my_car.get_color() << endl; // This next line will not work because color is private. cout << \"The color is: \" << my_car.color << endl; } In the class above, all of my object properties are called \"private\" properties, which means they cannot be accessed directly from outside of the class. Instead, I use getter methods to return the values. This is useful because you can control how the properties are changed or retrieved. Likewise, methods could be set as private or protected. I'm not going to go into that here, but if you're interested in all of the features of object oriented programming, it is worth reading up on. While languages like Java and C++ allow you to make properties and methods private, Python doesn't do that. All properties are accessible anywhere. In practice, if you want a method to be treated as private, you must start its name with an underscore. So to denote accelerate() as private, the definition line in Python would look like this: python def _accelerate(self): . This doesn't mean it cannot be accessed from outside the class, but it does tell developers that it shouldn't be accessed directly. Instead, maybe you have another method from within the class that can access it. We won't be dealing with any of this in this book, but it is useful to know that one of the major reason we use objects, besides to collect data and methods into single units.","title":"Visibility"},{"location":"ch3/#conclusion","text":"Object oriented programming, or designing your system around a number of classes, is a popular paradigm. I would encourage you to research it further. In the next chapter, I'm going to walk through an example of building a class using Test Driven Development that builds on the prime_factors function from the first chapter. However, for our purposes, we'll be using classes, but we won't be going to far down the OOP path. You will have a better sense now of what's happening when we say app = Flask(__name__) .","title":"Conclusion"},{"location":"ch4/","text":"TDD with Objects In this chapter, I'm going to walk through creating a class using TDD. We'll be building off of material in Chapter 1 and 2, so make sure you've read that carefully. At the end of Chapter 1, we had a set of tests that looked like this: prime_factors_tests.py import unittest import prime_factors as target class TestPrimeFactors(unittest.TestCase): def test_bad_input(self): self.assertIsNone(target.prime_factors(\"apple\")) def test_returns_list(self): l = target.prime_factors(315) self.assertIsInstance(l, list) def test_returns_correct_list(self): l = target.prime_factors(315) self.assertEqual([3, 5, 7], l) and we had created a function that we developed to pass those tests. prime_factors.py import math def prime_factors(n): if isinstance(n, int): out = [] if n % 2 == 0: out.append(2) while n % 2 == 0: n = n / 2 for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: out.append(i) while n % i == 0: n = n / i if n > 2: out.append(n) return out return None I'm going to build a class that uses prime_factors as a method. I'm also going to create a second method that finds the factorial value of a given number (factorial is 1 * 2 * 3 ... * n-1 * n). Next, calculating prime_factors and factorials for very large values is processor intensive, so let's make our calculator have a couple dictionaries that contain the key/value pairs of calculated numbers. So we start with our tests. I want to change my file name first to better reflect what we're doing. Then the first thing we need to do is change how we import our calculator. We also need to set up a test for our constructor (the __init__ method). Let's start with those two steps. While we're at it, we're going to modify our existing tests to call object methods instead of freestanding functions. import unittest # Import the class definition from Calculator import Calculator class TestCalculator(unittest.TestCase): def setUp(self): self.calc = Calculator() def test_calculator_constructor(self): expected = ({}, {}) actual = (self.calc.prime_factor, \\ self.calc.factorial) def test_bad_input(self): self.assertIsNone(self.calc.prime_factors(\"apple\")) def test_returns_list(self): l = self.calc.prime_factors(315) self.assertIsInstance(l, list) def test_returns_correct_list(self): l = self.calc.prime_factors(315) self.assertEqual([3, 5, 7], l) When we run our tests, since we haven't touched our code, we should run into error messages. I'm expecting an import error and a bunch of name errors. Let's see if we get that: (env) $ python -m unittest calculator_tests.py E ====================================================================== ERROR: calculator_tests (unittest.loader._FailedTest) ---------------------------------------------------------------------- ImportError: Failed to import test module: calculator_tests Traceback (most recent call last): File \"/usr/lib/python3.6/unittest/loader.py\", line 153, in loadTestsFromName module = __import__(module_name) File \"exercises/calculator_tests.py\", line 3, in <module> from Calculator import Calculator ModuleNotFoundError: No module named 'Calculator' ---------------------------------------------------------------------- Ran 1 test in 0.000s FAILED (errors=1) That's exactly the error I was expecting, so to fix this we can go about renaming our file for our code. I changed the name prime_factors.py to Calculator.py. Now my expectation is that there will be a name error because there's no such thing as a Calculator class. Run the tests again and here's the result: $ python -m unittest calculator_tests.py E ====================================================================== ERROR: calculator_tests (unittest.loader._FailedTest) ---------------------------------------------------------------------- ImportError: Failed to import test module: calculator_tests Traceback (most recent call last): File \"/usr/lib/python3.6/unittest/loader.py\", line 153, in loadTestsFromName module = __import__(module_name) File \"exercises/calculator_tests.py\", line 3, in <module> from Calculator import Calculator ImportError: cannot import name 'Calculator' ---------------------------------------------------------------------- Ran 1 test in 0.000s FAILED (errors=1) Once again, expected error achieved. Let's fix that by modifying my code a bit so that the prime_factors function becomes a method of Calculator. Calculator.py import math class Calculator: def __init__(self): self.prime_factor = {} self.factorial = {} def prime_factors(self, n): if isinstance(n, int): out = [] if n % 2 == 0: out.append(2) while n % 2 == 0: n = n / 2 for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: out.append(i) while n % i == 0: n = n / i if n > 2: out.append(n) return out return None I'm expecting a number of errors and failed tests now, but I believe that two of the tests will pass. test_bad_input and test_returns_list should still pass, but I'll get errors for the class properties and the list comparison should fail. (env) $ python -m unittest calculator_tests.py .EF. ====================================================================== ERROR: test_calculator_constructor (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 13, in test_calculator_constructor self.calc.factorial) AttributeError: type object 'Calculator' has no attribute 'factorial' ====================================================================== FAIL: test_returns_correct_list (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 24, in test_returns_correct_list self.assertEqual([3, 5, 7], l) AssertionError: Lists differ: [3, 5, 7] != [] First list contains 3 additional elements. First extra element 0: 3 - [3, 5, 7] + [] ---------------------------------------------------------------------- Ran 4 tests in 0.001s FAILED (failures=1, errors=1) Again, this is good. Let's now add a constructor and adjust our function and see if we can get these tests to pass. import math class Calculator: def __init__(self): self.prime_factor = {} self.factorial = {} def prime_factors(self, n): if isinstance(n, int): out = [] if n % 2 == 0: out.append(2) while n % 2 == 0: n = n / 2 for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: out.append(i) while n % i == 0: n = n / i if n > 2: out.append(n) return out return None You'll notice that I added a constructor to my class and added self as a parameter for prime_factors() . The constructor initializes the two class properties to empty dictionaries. At this point, all of my tests should pass. (env) $ python -m unittest calculator_tests.py .... ---------------------------------------------------------------------- Ran 4 tests in 0.000s OK Great! Now we might be tempted to add the extra functionality directly to our class and move forward, but we must obey the testing goat. We have to start by writing our tests. First, we need to do similar tests for our new method called factorials. It should test that the method returns None if it is passed a value that is not an integer. It should also test that the correct value is returned for a given integer. Second, we need a tests that make sure each of the dictionaries are being constructed in the right way as the classes methods are called. Let's see if we can get those tests written. import unittest # Import the class definition from Calculator import Calculator class TestCalculator(unittest.TestCase): def setUp(self): self.calc = Calculator() def test_calculator_constructor(self): expected = ({}, {}) actual = (self.calc.prime_factor, \\ self.calc.factorial) def test_bad_input(self): self.assertIsNone(self.calc.prime_factors(\"apple\")) def test_returns_list(self): l = self.calc.prime_factors(315) self.assertIsInstance(l, list) def test_returns_correct_list(self): l = self.calc.prime_factors(315) self.assertEqual([3, 5, 7], l) def test_factorials_bad_input(self): self.assertIsNone(self.calc.factorials(\"apple\")) def test_factorials_good_input(self): l = self.calc.factorials(5) self.assertEqual(120, l) def test_memory_prime_factors(self): calc = Calculator() calc.prime_factors(315) calc.prime_factors(9) expected = {315: [3, 5, 7], 9: [3]} self.assertDictEqual(calc.prime_factor, expected) def test_memory_factorial(self): calc = Calculator() calc.factorials(4) calc.factorials(5) expected = {4: 24, 5: 120} self.assertDictEqual(calc.factorial, expected) We added four new tests. A couple things to notice: first, the memory tests create new instances of the Calculator class. I did this because I wanted to isolate that instance and see if the memory for that one instance was working without any of the other tests altering the state of the instance. calc != self.calc in these cases. Second, I'm using assertDictEqual which is a new feature of unittest as of python 3.1, and it allows us to compare equality of dictionaries. Of course, all these should have errors (not fail) because factorials doesn't exist yet. (env) $ python -m unittest calculator_tests.py ..EEEF.. ====================================================================== ERROR: test_factorials_bad_input (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 27, in test_factorials_bad_input self.assertIsNone(self.calc.factorials(\"apple\")) AttributeError: 'Calculator' object has no attribute 'factorials' ====================================================================== ERROR: test_factorials_good_input (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 30, in test_factorials_good_input l = self.calc.factorials(5) AttributeError: 'Calculator' object has no attribute 'factorials' ====================================================================== ERROR: test_memory_factorial (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 42, in test_memory_factorial calc.factorials(4) AttributeError: 'Calculator' object has no attribute 'factorials' ====================================================================== FAIL: test_memory_prime_factors (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 38, in test_memory_prime_factors self.assertDictEqual(calc.prime_factor, expected) AssertionError: {} != {315: [3, 5, 7], 9: [3]} - {} + {9: [3], 315: [3, 5, 7]} ---------------------------------------------------------------------- Ran 8 tests in 0.001s FAILED (failures=1, errors=3) Good, so let's add a function called factorials and see that we get at least three failures. Which means we need to modify our code: Calculator.py import math class Calculator: def __init__(self): self.prime_factor = {} self.factorial = {} def prime_factors(self, n): if isinstance(n, int): out = [] if n % 2 == 0: out.append(2) while n % 2 == 0: n = n / 2 for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: out.append(i) while n % i == 0: n = n / i if n > 2: out.append(n) return out return None def factorials(self, n): pass Run our tests: (env) $ python -m unittest calculator_tests.py ...FFF.. ====================================================================== FAIL: test_factorials_good_input (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 31, in test_factorials_good_input self.assertEqual(120, l) AssertionError: 120 != None ====================================================================== FAIL: test_memory_factorial (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 45, in test_memory_factorial self.assertDictEqual(calc.factorial, expected) AssertionError: {} != {4: 24, 5: 120} - {} + {4: 24, 5: 120} ====================================================================== FAIL: test_memory_prime_factors (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 38, in test_memory_prime_factors self.assertDictEqual(calc.prime_factor, expected) AssertionError: {} != {315: [3, 5, 7], 9: [3]} - {} + {9: [3], 315: [3, 5, 7]} ---------------------------------------------------------------------- Ran 8 tests in 0.001s FAILED (failures=3) Outstanding! So to get the tests to pass, I need to do a few things. I need to first build the factorials method. Then I need to modify the two methods in the class to add values to the class properties that are keeping track. We might also add a way to make these methods return the stored value rather than run the calculation so as to save processor power. Think of it like a cache. I'll do all of this at once for now, but you would probably want to take each of these as a single step if you were doing very strict TDD. Here's what I came up with: import math class Calculator: def __init__(self): self.prime_factor = {} self.factorial = {} def prime_factors(self, n): if isinstance(n, int): out = [] if n in self.prime_factor.keys(): return self.prime_factor[n] original = n if n % 2 == 0: out.append(2) while n % 2 == 0: n = n / 2 for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: out.append(i) while n % i == 0: n = n / i if n > 2: out.append(n) self.prime_factor[original] = out return out return None def factorials(self, n): if not isinstance(n, int): return None out = 1 original = n while n > 1: if n in self.factorial.keys(): out *= self.factorial[n] # clever n = 1 else: out *= n n -= 1 self.factorial[original] = out return out You'll notice that I adjusted both methods to check to see if we'd already calculated the factorials or the prime_factors of n, and if so, we return the cached value. Otherwise, we run the calculation. Also, I set up the functionality to store the value in the cache. There's a clever bit on the line with the comment #clever. This will short circuit our while loop if we've already calculated a value for n that is less than the original parameter. This helps because if we are calculating 5 factorial, we have to do 5 * 4 * 3 * 2 * 1, but if we've already calculated 3! and have it stored, then once what happens is we calculate 5 * 4 and when we hit n == 3, then the method looks up our stored result for 3!, which is 6, so the calculation becomes 5 * 4 * 6 and the result is returned without recalcuating 3 * 2 * 1. This matters if our number is 1000 and we've already calculated 960!. It would save us 960 iterations in our loop. Here's the results of our unit tests: (env) $ python -m unittest calculator_tests.py ........ ---------------------------------------------------------------------- Ran 8 tests in 0.000s OK I'd say that's not too bad for a days work. Of course, I could have gone through all of the steps and written one test at a time, but hopefully you're getting the hang of it. In a larger application I might be a bit more careful. Conclusion So by now you should have a sense of what a class is and how we might build a class using a TDD approach. If you want extra practice, you might do this kind of refactoring with the function from Chapter 2. If you're excited about objects, Python 4 Everybody has a great series of lessons on Objects in Python.","title":"4. TDD with Objects"},{"location":"ch4/#tdd-with-objects","text":"In this chapter, I'm going to walk through creating a class using TDD. We'll be building off of material in Chapter 1 and 2, so make sure you've read that carefully. At the end of Chapter 1, we had a set of tests that looked like this: prime_factors_tests.py import unittest import prime_factors as target class TestPrimeFactors(unittest.TestCase): def test_bad_input(self): self.assertIsNone(target.prime_factors(\"apple\")) def test_returns_list(self): l = target.prime_factors(315) self.assertIsInstance(l, list) def test_returns_correct_list(self): l = target.prime_factors(315) self.assertEqual([3, 5, 7], l) and we had created a function that we developed to pass those tests. prime_factors.py import math def prime_factors(n): if isinstance(n, int): out = [] if n % 2 == 0: out.append(2) while n % 2 == 0: n = n / 2 for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: out.append(i) while n % i == 0: n = n / i if n > 2: out.append(n) return out return None I'm going to build a class that uses prime_factors as a method. I'm also going to create a second method that finds the factorial value of a given number (factorial is 1 * 2 * 3 ... * n-1 * n). Next, calculating prime_factors and factorials for very large values is processor intensive, so let's make our calculator have a couple dictionaries that contain the key/value pairs of calculated numbers. So we start with our tests. I want to change my file name first to better reflect what we're doing. Then the first thing we need to do is change how we import our calculator. We also need to set up a test for our constructor (the __init__ method). Let's start with those two steps. While we're at it, we're going to modify our existing tests to call object methods instead of freestanding functions. import unittest # Import the class definition from Calculator import Calculator class TestCalculator(unittest.TestCase): def setUp(self): self.calc = Calculator() def test_calculator_constructor(self): expected = ({}, {}) actual = (self.calc.prime_factor, \\ self.calc.factorial) def test_bad_input(self): self.assertIsNone(self.calc.prime_factors(\"apple\")) def test_returns_list(self): l = self.calc.prime_factors(315) self.assertIsInstance(l, list) def test_returns_correct_list(self): l = self.calc.prime_factors(315) self.assertEqual([3, 5, 7], l) When we run our tests, since we haven't touched our code, we should run into error messages. I'm expecting an import error and a bunch of name errors. Let's see if we get that: (env) $ python -m unittest calculator_tests.py E ====================================================================== ERROR: calculator_tests (unittest.loader._FailedTest) ---------------------------------------------------------------------- ImportError: Failed to import test module: calculator_tests Traceback (most recent call last): File \"/usr/lib/python3.6/unittest/loader.py\", line 153, in loadTestsFromName module = __import__(module_name) File \"exercises/calculator_tests.py\", line 3, in <module> from Calculator import Calculator ModuleNotFoundError: No module named 'Calculator' ---------------------------------------------------------------------- Ran 1 test in 0.000s FAILED (errors=1) That's exactly the error I was expecting, so to fix this we can go about renaming our file for our code. I changed the name prime_factors.py to Calculator.py. Now my expectation is that there will be a name error because there's no such thing as a Calculator class. Run the tests again and here's the result: $ python -m unittest calculator_tests.py E ====================================================================== ERROR: calculator_tests (unittest.loader._FailedTest) ---------------------------------------------------------------------- ImportError: Failed to import test module: calculator_tests Traceback (most recent call last): File \"/usr/lib/python3.6/unittest/loader.py\", line 153, in loadTestsFromName module = __import__(module_name) File \"exercises/calculator_tests.py\", line 3, in <module> from Calculator import Calculator ImportError: cannot import name 'Calculator' ---------------------------------------------------------------------- Ran 1 test in 0.000s FAILED (errors=1) Once again, expected error achieved. Let's fix that by modifying my code a bit so that the prime_factors function becomes a method of Calculator. Calculator.py import math class Calculator: def __init__(self): self.prime_factor = {} self.factorial = {} def prime_factors(self, n): if isinstance(n, int): out = [] if n % 2 == 0: out.append(2) while n % 2 == 0: n = n / 2 for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: out.append(i) while n % i == 0: n = n / i if n > 2: out.append(n) return out return None I'm expecting a number of errors and failed tests now, but I believe that two of the tests will pass. test_bad_input and test_returns_list should still pass, but I'll get errors for the class properties and the list comparison should fail. (env) $ python -m unittest calculator_tests.py .EF. ====================================================================== ERROR: test_calculator_constructor (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 13, in test_calculator_constructor self.calc.factorial) AttributeError: type object 'Calculator' has no attribute 'factorial' ====================================================================== FAIL: test_returns_correct_list (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 24, in test_returns_correct_list self.assertEqual([3, 5, 7], l) AssertionError: Lists differ: [3, 5, 7] != [] First list contains 3 additional elements. First extra element 0: 3 - [3, 5, 7] + [] ---------------------------------------------------------------------- Ran 4 tests in 0.001s FAILED (failures=1, errors=1) Again, this is good. Let's now add a constructor and adjust our function and see if we can get these tests to pass. import math class Calculator: def __init__(self): self.prime_factor = {} self.factorial = {} def prime_factors(self, n): if isinstance(n, int): out = [] if n % 2 == 0: out.append(2) while n % 2 == 0: n = n / 2 for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: out.append(i) while n % i == 0: n = n / i if n > 2: out.append(n) return out return None You'll notice that I added a constructor to my class and added self as a parameter for prime_factors() . The constructor initializes the two class properties to empty dictionaries. At this point, all of my tests should pass. (env) $ python -m unittest calculator_tests.py .... ---------------------------------------------------------------------- Ran 4 tests in 0.000s OK Great! Now we might be tempted to add the extra functionality directly to our class and move forward, but we must obey the testing goat. We have to start by writing our tests. First, we need to do similar tests for our new method called factorials. It should test that the method returns None if it is passed a value that is not an integer. It should also test that the correct value is returned for a given integer. Second, we need a tests that make sure each of the dictionaries are being constructed in the right way as the classes methods are called. Let's see if we can get those tests written. import unittest # Import the class definition from Calculator import Calculator class TestCalculator(unittest.TestCase): def setUp(self): self.calc = Calculator() def test_calculator_constructor(self): expected = ({}, {}) actual = (self.calc.prime_factor, \\ self.calc.factorial) def test_bad_input(self): self.assertIsNone(self.calc.prime_factors(\"apple\")) def test_returns_list(self): l = self.calc.prime_factors(315) self.assertIsInstance(l, list) def test_returns_correct_list(self): l = self.calc.prime_factors(315) self.assertEqual([3, 5, 7], l) def test_factorials_bad_input(self): self.assertIsNone(self.calc.factorials(\"apple\")) def test_factorials_good_input(self): l = self.calc.factorials(5) self.assertEqual(120, l) def test_memory_prime_factors(self): calc = Calculator() calc.prime_factors(315) calc.prime_factors(9) expected = {315: [3, 5, 7], 9: [3]} self.assertDictEqual(calc.prime_factor, expected) def test_memory_factorial(self): calc = Calculator() calc.factorials(4) calc.factorials(5) expected = {4: 24, 5: 120} self.assertDictEqual(calc.factorial, expected) We added four new tests. A couple things to notice: first, the memory tests create new instances of the Calculator class. I did this because I wanted to isolate that instance and see if the memory for that one instance was working without any of the other tests altering the state of the instance. calc != self.calc in these cases. Second, I'm using assertDictEqual which is a new feature of unittest as of python 3.1, and it allows us to compare equality of dictionaries. Of course, all these should have errors (not fail) because factorials doesn't exist yet. (env) $ python -m unittest calculator_tests.py ..EEEF.. ====================================================================== ERROR: test_factorials_bad_input (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 27, in test_factorials_bad_input self.assertIsNone(self.calc.factorials(\"apple\")) AttributeError: 'Calculator' object has no attribute 'factorials' ====================================================================== ERROR: test_factorials_good_input (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 30, in test_factorials_good_input l = self.calc.factorials(5) AttributeError: 'Calculator' object has no attribute 'factorials' ====================================================================== ERROR: test_memory_factorial (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 42, in test_memory_factorial calc.factorials(4) AttributeError: 'Calculator' object has no attribute 'factorials' ====================================================================== FAIL: test_memory_prime_factors (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 38, in test_memory_prime_factors self.assertDictEqual(calc.prime_factor, expected) AssertionError: {} != {315: [3, 5, 7], 9: [3]} - {} + {9: [3], 315: [3, 5, 7]} ---------------------------------------------------------------------- Ran 8 tests in 0.001s FAILED (failures=1, errors=3) Good, so let's add a function called factorials and see that we get at least three failures. Which means we need to modify our code: Calculator.py import math class Calculator: def __init__(self): self.prime_factor = {} self.factorial = {} def prime_factors(self, n): if isinstance(n, int): out = [] if n % 2 == 0: out.append(2) while n % 2 == 0: n = n / 2 for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: out.append(i) while n % i == 0: n = n / i if n > 2: out.append(n) return out return None def factorials(self, n): pass Run our tests: (env) $ python -m unittest calculator_tests.py ...FFF.. ====================================================================== FAIL: test_factorials_good_input (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 31, in test_factorials_good_input self.assertEqual(120, l) AssertionError: 120 != None ====================================================================== FAIL: test_memory_factorial (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 45, in test_memory_factorial self.assertDictEqual(calc.factorial, expected) AssertionError: {} != {4: 24, 5: 120} - {} + {4: 24, 5: 120} ====================================================================== FAIL: test_memory_prime_factors (calculator_tests.TestCalculator) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/calculator_tests.py\", line 38, in test_memory_prime_factors self.assertDictEqual(calc.prime_factor, expected) AssertionError: {} != {315: [3, 5, 7], 9: [3]} - {} + {9: [3], 315: [3, 5, 7]} ---------------------------------------------------------------------- Ran 8 tests in 0.001s FAILED (failures=3) Outstanding! So to get the tests to pass, I need to do a few things. I need to first build the factorials method. Then I need to modify the two methods in the class to add values to the class properties that are keeping track. We might also add a way to make these methods return the stored value rather than run the calculation so as to save processor power. Think of it like a cache. I'll do all of this at once for now, but you would probably want to take each of these as a single step if you were doing very strict TDD. Here's what I came up with: import math class Calculator: def __init__(self): self.prime_factor = {} self.factorial = {} def prime_factors(self, n): if isinstance(n, int): out = [] if n in self.prime_factor.keys(): return self.prime_factor[n] original = n if n % 2 == 0: out.append(2) while n % 2 == 0: n = n / 2 for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: out.append(i) while n % i == 0: n = n / i if n > 2: out.append(n) self.prime_factor[original] = out return out return None def factorials(self, n): if not isinstance(n, int): return None out = 1 original = n while n > 1: if n in self.factorial.keys(): out *= self.factorial[n] # clever n = 1 else: out *= n n -= 1 self.factorial[original] = out return out You'll notice that I adjusted both methods to check to see if we'd already calculated the factorials or the prime_factors of n, and if so, we return the cached value. Otherwise, we run the calculation. Also, I set up the functionality to store the value in the cache. There's a clever bit on the line with the comment #clever. This will short circuit our while loop if we've already calculated a value for n that is less than the original parameter. This helps because if we are calculating 5 factorial, we have to do 5 * 4 * 3 * 2 * 1, but if we've already calculated 3! and have it stored, then once what happens is we calculate 5 * 4 and when we hit n == 3, then the method looks up our stored result for 3!, which is 6, so the calculation becomes 5 * 4 * 6 and the result is returned without recalcuating 3 * 2 * 1. This matters if our number is 1000 and we've already calculated 960!. It would save us 960 iterations in our loop. Here's the results of our unit tests: (env) $ python -m unittest calculator_tests.py ........ ---------------------------------------------------------------------- Ran 8 tests in 0.000s OK I'd say that's not too bad for a days work. Of course, I could have gone through all of the steps and written one test at a time, but hopefully you're getting the hang of it. In a larger application I might be a bit more careful.","title":"TDD with Objects"},{"location":"ch4/#conclusion","text":"So by now you should have a sense of what a class is and how we might build a class using a TDD approach. If you want extra practice, you might do this kind of refactoring with the function from Chapter 2. If you're excited about objects, Python 4 Everybody has a great series of lessons on Objects in Python.","title":"Conclusion"},{"location":"ch5/","text":"The Internet This chapter is going to give you a general introduction to the internet, internet traffic, and how applications send and receive data. There won't be much code in this chapter, but I believe you should spend some time getting to know, at very least, the basics of how internet traffic works. When traffic flows over the internet, it is broken into packets. Those packets get routed by routers along the way and the recipient's computer reassembles those packages into a complete message. There are two different protocols for this, one that assembles and loads the message as it is received (UDP) and one that waits for the entire message to be received before loading anything (TCP). Streaming video services generally use UDP because the designers know that we're more frustrated by buffering than reduction in video quality. However, this all occurs below the application level and our FLASK application doesn't deal with unassembled packets. UDP and TCP manage the packets before they're sent to the application. Our applications are concerned with the entire message. When we request a page on a website, the message is that entire page. Likewise, when we send data to a website, the message is that entire data object (even if it is a massive photo that must be broken into lots of packets). When we look at an entire message that is sent over the internet, we are talking about the HTTP protocol. This protocol defines how entire messages are sent from one application (a web server, like Flask) to another (a browser, like Firefox). Within this protocols, there are two actions: Requests and Responses. Requests are made by clients, like web browsers, and either request some content from the server or request that some data be accepted by the server. On the other end, servers make responses. They do this when they receive a request from a client and their response depends upon the request. Requests An HTTP request is send by a client. This could be your web browser or any other application set up to make requests over the internet using the HTTP protocol. For fun, try out the following in your terminal: $ curl --request GET https://dlondonmedina.github.io/tester/ Curl is a program that sends HTTP requests similar to a web browers. What the above says is send a GET request to the address https://dlondonmedina.github.io/tester/ That request leaves curl and goes through my network card, gets sent across a bunch of routers to a DNS server which matches the name dlondonmedina.github.io with this IP address 185.199.109.153. The specific message is something like \"Get me whatever resource is named 'tester.'\" Now curl waits to see if there's a server that can respond to the particular message at the address 185.199.109.153. We'll see that response in just a moment. Before we get there, you'll notice the word --request GET in the command above. GET is a key word, and refers to a particular method in HTTP. Just as a method is a particular operation of an object and performs particular processes, HTTP methods are the particular operations that a request asks the server to do. GET above means get me whatever data is appropriate for the name 'tester.' The following are the most commonly used HTTP methods, but we'll mainly be concerned with GET and POST. Method Effect GET This method retrieves data from the resource at the specified URL or IP Address. GET should not be used to send data. POST This method submits data to the resource at the specified URL or IP Address. It causes a change in state on the server. For instance, when you create an account on a website, the data you enter in their form is sent via a POST request and stored on, or at least processed by, the server. PUT Like POST, this method submits data to the resource at the specified URL or IP address, but the data is an alteration to a preexisting resource on the server. The new data updates the old data. Think of this as resetting a username that is stored in a database on the server. DELETE This method submits data to identify a particular resource on a server at the specified URL or IP Address, and it deletes that data. There are others, but with Flask, you generally only use GET and POST. A crucial thing to know about using the HTTP methods is that some change the state of an object on the server and others do not. GET, for example, only retrieves data from a server, but doesn't change the state of that data. When you open a blog post on a web page, your browser uses GET to request the contents of the blog post. It doesn't change the coontents on the server or have any other side-effects (like placing an order or creating a user). On the other hand, when you submit a comment to that blog post, the broswer uses the POST method, which adds content to a database on the server, thus changing the state of that database resource. If this is all exciting, I encourage you to read more about all the HTTP methods, and perhaps pursue web development further. Responses Let's go back to our sample request above. We sent a GET request to the resource located at the URL dlondonmedina.github.io/ requesting the resource 'tester/'. Along with that request, we sent our IP address so that the server knows where to return the response. There are a few things that happen: Once our request goes to the DNS, which pairs the URL: dlondonmedina.github.io with the IP address: 185.199.109.153. Our request is sent to the IP address (185.199.109.153) If there is not a server listening for requests at 185.199.109.153, then an error message will be returned. If there is a server listening for requests at 185.199.109.153, then the server will receive the request and look for 'tester/' as a named resource. If the server doesn't know 'tester/' as a named resource (static file or method), then it will respond with an error. If the server does know 'tester/', then it will gather whatever resource is identified by that name (sometimes an HTML file). Once the resource is gathered, the server sends that data back to the IP address sent by the client along with the address. Here is the full request/response that I showed you above: $ curl -v --request GET https://dlondonmedina.github.io/tester/ <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>Tester</title> </head> <body> <h1>Welcome</h1> <p>You've successfully tested the site.</p> </body> </html> The first line is the request sent by the curl client. The rest of the lines are the HTML content that the server sent back in response. Of course, it's not showing you the entire HTTP wrapper that goes along with the request. The Responses will be sent along with a code that signifies what happend. Status code 200 means that the request was successful. Most other codes identify one sort of error or another. You don't need to know much about the error codes for Flask, but they might be useful to learn for debugging or if you're excited about web technologies. The status codes are part of the HTTP protocol just as the methods listed above are. So, here again is the entire request/response cycle with the HTTP wrapper displayed (I've cut out the TLS handshake that allows encryption to happen with https). The lines beginning with > are the request from my curl client. The lines beginning with < are the response from the server, and everything after <!DOCTYPE html> until </html> is the body of the response: $ curl -v https://dlondonmedina.github.io/tester/ > GET /tester/ HTTP/2 > Host: dlondonmedina.github.io > User-Agent: curl/7.58.0 > Accept: */* > < HTTP/2 200 < server: GitHub.com < content-type: text/html; charset=utf-8 < last-modified: Sat, 18 Apr 2020 01:54:09 GMT < etag: \"5e9a5dc1-101\" < access-control-allow-origin: * < expires: Sat, 18 Apr 2020 02:06:20 GMT < cache-control: max-age=600 < x-proxy-cache: MISS < x-github-request-id: < accept-ranges: bytes < date: Sun, 19 Apr 2020 00:52:52 GMT < via: 1.1 varnish < age: 14 < x-served-by: cache-yvr1522-YVR < x-cache: HIT < x-cache-hits: 1 < x-timer: S1587257573.591449,VS0,VE0 < vary: Accept-Encoding < x-fastly-request-id: < content-length: 257 < <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>Tester</title> </head> <body> <h1>Welcome</h1> <p>You've successfully tested the site.</p> </body> </html> An Analogy It is quite important to understand the basic flow of traffic on the internet to understand how our Flask app will be working. Hopefully the technical information above is useful. In this section, I'm going to describe the flow with a metaphor--specifically a postal metaphor. Imagine I'm a freelance consultant in the old days where invoices were sent over the mail. I've done $400 worth of work for Tyler in Spokane at 203 W 28th Avenue, Spokane, WA, 99203. I fill out my invoice with all the pertinent data (hours worked, rate, subtotal, taxes, total, etc.). That is like the web form that you fill out online. Then I fold up my invoice and put it in an envelope with Tyler's address and my return address. The envelope is the HTTP layer that's necessary for routing by the postal network. I drop my letter in the mail and the carrier picks it up. They read the letter and look to see if the address is a valid address. If not, they try to return it to me. If you've ever miss addressed a piece of mail, you've seen that they return it to your return address with a stamp on it saying what the error was (wrong address?). In this case, the process at the postal hub trying to find if my address is valid is like the DNS server trying to find out if the URL is valid and related to a particular physical location (IP address is the address of a particular server or maybe router). If the address was valid, then the postal carriers take my invoice to the address that I put on it. It arrives at that address, and someone has to be answering the mail (imagine it is certified mail and needs to be signed for). If nobody picks it up, the postal carrier will return it to sender with an error message. Otherwise, if Tyler is there to sign for it, he takes the letter, opens the envelop (if we're using HTTPS, this is akin to decrypting) and reads the content. Tyler is the server on the other end waiting to respond. If Tyler is unfamiliar with me or rejects the contents of my request, he'll add a note saying something like \"I don't know what you're talking about\" or something else, and then he'll send my request back to me. This would be like a server sending back an error code because it doesn't know what to do with the request. On the other hand, he'll write me a check, which changes the state of his bank account, and put it into a return envelope with the invoice ticket. Then Tyler puts my address on the return envelope and the same transport process occurs as when I sent my invoice to him. If all that works, I get my money and I'm satisfied. If I get an error code, then I might try again or try a different address. In any case, this process of sending and responding with a bunch of address and content checking along the way is very much like a simplified view of internet traffic.","title":"5. The Internet"},{"location":"ch5/#the-internet","text":"This chapter is going to give you a general introduction to the internet, internet traffic, and how applications send and receive data. There won't be much code in this chapter, but I believe you should spend some time getting to know, at very least, the basics of how internet traffic works. When traffic flows over the internet, it is broken into packets. Those packets get routed by routers along the way and the recipient's computer reassembles those packages into a complete message. There are two different protocols for this, one that assembles and loads the message as it is received (UDP) and one that waits for the entire message to be received before loading anything (TCP). Streaming video services generally use UDP because the designers know that we're more frustrated by buffering than reduction in video quality. However, this all occurs below the application level and our FLASK application doesn't deal with unassembled packets. UDP and TCP manage the packets before they're sent to the application. Our applications are concerned with the entire message. When we request a page on a website, the message is that entire page. Likewise, when we send data to a website, the message is that entire data object (even if it is a massive photo that must be broken into lots of packets). When we look at an entire message that is sent over the internet, we are talking about the HTTP protocol. This protocol defines how entire messages are sent from one application (a web server, like Flask) to another (a browser, like Firefox). Within this protocols, there are two actions: Requests and Responses. Requests are made by clients, like web browsers, and either request some content from the server or request that some data be accepted by the server. On the other end, servers make responses. They do this when they receive a request from a client and their response depends upon the request.","title":"The Internet"},{"location":"ch5/#requests","text":"An HTTP request is send by a client. This could be your web browser or any other application set up to make requests over the internet using the HTTP protocol. For fun, try out the following in your terminal: $ curl --request GET https://dlondonmedina.github.io/tester/ Curl is a program that sends HTTP requests similar to a web browers. What the above says is send a GET request to the address https://dlondonmedina.github.io/tester/ That request leaves curl and goes through my network card, gets sent across a bunch of routers to a DNS server which matches the name dlondonmedina.github.io with this IP address 185.199.109.153. The specific message is something like \"Get me whatever resource is named 'tester.'\" Now curl waits to see if there's a server that can respond to the particular message at the address 185.199.109.153. We'll see that response in just a moment. Before we get there, you'll notice the word --request GET in the command above. GET is a key word, and refers to a particular method in HTTP. Just as a method is a particular operation of an object and performs particular processes, HTTP methods are the particular operations that a request asks the server to do. GET above means get me whatever data is appropriate for the name 'tester.' The following are the most commonly used HTTP methods, but we'll mainly be concerned with GET and POST. Method Effect GET This method retrieves data from the resource at the specified URL or IP Address. GET should not be used to send data. POST This method submits data to the resource at the specified URL or IP Address. It causes a change in state on the server. For instance, when you create an account on a website, the data you enter in their form is sent via a POST request and stored on, or at least processed by, the server. PUT Like POST, this method submits data to the resource at the specified URL or IP address, but the data is an alteration to a preexisting resource on the server. The new data updates the old data. Think of this as resetting a username that is stored in a database on the server. DELETE This method submits data to identify a particular resource on a server at the specified URL or IP Address, and it deletes that data. There are others, but with Flask, you generally only use GET and POST. A crucial thing to know about using the HTTP methods is that some change the state of an object on the server and others do not. GET, for example, only retrieves data from a server, but doesn't change the state of that data. When you open a blog post on a web page, your browser uses GET to request the contents of the blog post. It doesn't change the coontents on the server or have any other side-effects (like placing an order or creating a user). On the other hand, when you submit a comment to that blog post, the broswer uses the POST method, which adds content to a database on the server, thus changing the state of that database resource. If this is all exciting, I encourage you to read more about all the HTTP methods, and perhaps pursue web development further.","title":"Requests"},{"location":"ch5/#responses","text":"Let's go back to our sample request above. We sent a GET request to the resource located at the URL dlondonmedina.github.io/ requesting the resource 'tester/'. Along with that request, we sent our IP address so that the server knows where to return the response. There are a few things that happen: Once our request goes to the DNS, which pairs the URL: dlondonmedina.github.io with the IP address: 185.199.109.153. Our request is sent to the IP address (185.199.109.153) If there is not a server listening for requests at 185.199.109.153, then an error message will be returned. If there is a server listening for requests at 185.199.109.153, then the server will receive the request and look for 'tester/' as a named resource. If the server doesn't know 'tester/' as a named resource (static file or method), then it will respond with an error. If the server does know 'tester/', then it will gather whatever resource is identified by that name (sometimes an HTML file). Once the resource is gathered, the server sends that data back to the IP address sent by the client along with the address. Here is the full request/response that I showed you above: $ curl -v --request GET https://dlondonmedina.github.io/tester/ <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>Tester</title> </head> <body> <h1>Welcome</h1> <p>You've successfully tested the site.</p> </body> </html> The first line is the request sent by the curl client. The rest of the lines are the HTML content that the server sent back in response. Of course, it's not showing you the entire HTTP wrapper that goes along with the request. The Responses will be sent along with a code that signifies what happend. Status code 200 means that the request was successful. Most other codes identify one sort of error or another. You don't need to know much about the error codes for Flask, but they might be useful to learn for debugging or if you're excited about web technologies. The status codes are part of the HTTP protocol just as the methods listed above are. So, here again is the entire request/response cycle with the HTTP wrapper displayed (I've cut out the TLS handshake that allows encryption to happen with https). The lines beginning with > are the request from my curl client. The lines beginning with < are the response from the server, and everything after <!DOCTYPE html> until </html> is the body of the response: $ curl -v https://dlondonmedina.github.io/tester/ > GET /tester/ HTTP/2 > Host: dlondonmedina.github.io > User-Agent: curl/7.58.0 > Accept: */* > < HTTP/2 200 < server: GitHub.com < content-type: text/html; charset=utf-8 < last-modified: Sat, 18 Apr 2020 01:54:09 GMT < etag: \"5e9a5dc1-101\" < access-control-allow-origin: * < expires: Sat, 18 Apr 2020 02:06:20 GMT < cache-control: max-age=600 < x-proxy-cache: MISS < x-github-request-id: < accept-ranges: bytes < date: Sun, 19 Apr 2020 00:52:52 GMT < via: 1.1 varnish < age: 14 < x-served-by: cache-yvr1522-YVR < x-cache: HIT < x-cache-hits: 1 < x-timer: S1587257573.591449,VS0,VE0 < vary: Accept-Encoding < x-fastly-request-id: < content-length: 257 < <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>Tester</title> </head> <body> <h1>Welcome</h1> <p>You've successfully tested the site.</p> </body> </html>","title":"Responses"},{"location":"ch5/#an-analogy","text":"It is quite important to understand the basic flow of traffic on the internet to understand how our Flask app will be working. Hopefully the technical information above is useful. In this section, I'm going to describe the flow with a metaphor--specifically a postal metaphor. Imagine I'm a freelance consultant in the old days where invoices were sent over the mail. I've done $400 worth of work for Tyler in Spokane at 203 W 28th Avenue, Spokane, WA, 99203. I fill out my invoice with all the pertinent data (hours worked, rate, subtotal, taxes, total, etc.). That is like the web form that you fill out online. Then I fold up my invoice and put it in an envelope with Tyler's address and my return address. The envelope is the HTTP layer that's necessary for routing by the postal network. I drop my letter in the mail and the carrier picks it up. They read the letter and look to see if the address is a valid address. If not, they try to return it to me. If you've ever miss addressed a piece of mail, you've seen that they return it to your return address with a stamp on it saying what the error was (wrong address?). In this case, the process at the postal hub trying to find if my address is valid is like the DNS server trying to find out if the URL is valid and related to a particular physical location (IP address is the address of a particular server or maybe router). If the address was valid, then the postal carriers take my invoice to the address that I put on it. It arrives at that address, and someone has to be answering the mail (imagine it is certified mail and needs to be signed for). If nobody picks it up, the postal carrier will return it to sender with an error message. Otherwise, if Tyler is there to sign for it, he takes the letter, opens the envelop (if we're using HTTPS, this is akin to decrypting) and reads the content. Tyler is the server on the other end waiting to respond. If Tyler is unfamiliar with me or rejects the contents of my request, he'll add a note saying something like \"I don't know what you're talking about\" or something else, and then he'll send my request back to me. This would be like a server sending back an error code because it doesn't know what to do with the request. On the other hand, he'll write me a check, which changes the state of his bank account, and put it into a return envelope with the invoice ticket. Then Tyler puts my address on the return envelope and the same transport process occurs as when I sent my invoice to him. If all that works, I get my money and I'm satisfied. If I get an error code, then I might try again or try a different address. In any case, this process of sending and responding with a bunch of address and content checking along the way is very much like a simplified view of internet traffic.","title":"An Analogy"},{"location":"ch6/","text":"Test Driven Design and the Web Before we move into Flask, I want to walk through an exercise of how we might develop a quick web client using the requests library and the test driven design approach. First, I have set up a resource at http://computingconcepts.herokuapp.com that returns status codes based on the request it receives. I built this as a toy to help students experiment with the requests library, and so it does the following: If it receives a GET request it will respond. If that GET request is accompanied by a user-agent called 'DICE' then it will return the string 44260953 in the body of the response The application is set up to handle POST requests at the resource named 'post', so the complete URL should be https://computingconcepts.herokuapp.com/post and if it received a POST request it will check the data. If the data is {'username': 'bobby', 'email': 'bobby@bobby.com'} then it will return the string 44261853 in the body of the response. If the data is wrong, it will return \"You didn't submit the right data\" The specifications of my assignment is the following: Build three functions: basic_request(), request_user_agent(), and request_post() basic_request takes one parameter: a URL. Uses requests to make a GET request to the URL. It returns -1 if the status code response from the URL is anything but 200, otherwise it returns 200. request_user_agent() takes 2 parameters, a URL and a user agent. It uses requests to make a GET request to the URL with the user agent defined. If the URL is bad or the user agent is not set, it will return -1. Otherwise, it will return the content of the response. I know the server above, so I can test this. request_post() takes 2 parameters, a URL and a data object (probably dictionary). If the URL is bad or if no data is included, it should return -1. Otherwise, it should return the content of the response. I know the server above so I can test this. Just arbitrarily, I want my functions to define a good url as anything that ends with '.com' (Again, this is a toy, so I'm trying to keep it really simple.) I know that I'm doing TDD so I need to start with some tests. I will begin with a setUp() and some tests to test the basic_request() method. requester_tests.py import unittest import requester as target class TestRequester(unittest.TestCase): def setUp(self): self.url = 'http://computingconcepts.herokuapp.com' self.bad_url = 'http://computingconcepts.gopher' self.data = { 'username': 'bobby', 'email': 'bobby@bobby.com' } def test_basic_request_bad_url(self): response = target.basic_request(self.bad_url) self.assertEqual(-1, response) def test_basic_request_good_url(self): response = target.basic_request(self.url) self.assertEqual(200, response) I'll need to install the requests library, so I'll do that right now and create the file requester.py. I'll then run my tests. (env) $ touch requester.py (env) $ pip install requests (env) $ python -m unittest requester_tests.py EE ====================================================================== ERROR: test_basic_request_bad_url (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/requester_tests.py\", line 16, in test_basic_request_bad_url response = target.basic_request(self.bad_url) AttributeError: module 'requester' has no attribute 'basic_request' ====================================================================== ERROR: test_basic_request_good_url (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/requester_tests.py\", line 20, in test_basic_request_good_url response = target.basic_request(self.url) AttributeError: module 'requester' has no attribute 'basic_request' ---------------------------------------------------------------------- Ran 2 tests in 0.001s FAILED (errors=2) Of course we don't have anything in our file, so let's get it set up so that the tests fail the right way. requester.py import requests def basic_request(url): pass I know this will make my tests fail the right way because there is the correct function to call and it returns nothing. Sure enough, when I run my tests: $ python -m unittest requester_tests.py FF ====================================================================== FAIL: test_basic_request_bad_url (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 17, in test_basic_request_bad_url self.assertEqual(-1, response) AssertionError: -1 != None ====================================================================== FAIL: test_basic_request_good_url (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 21, in test_basic_request_good_url self.assertEqual(200, response) AssertionError: 200 != None ---------------------------------------------------------------------- Ran 2 tests in 0.000s FAILED (failures=2) That's exactly the errors we want, so now we want to get it to pass. I know I want the function to check that the URL is valid first (by our silly arbitrary definition of valid as ending with .com). Second, I want it to use requests to call the valid URL. Third, I want to check the status code and return it if it is 200. If 200 is not the status code or there is a problem with the URL, we should return -1. I've done all that in the code below: requester.py import requests def basic_request(url): if url[-4:] != '.com': return -1 resp = requests.get(url) if resp.status_code == 200: return resp.status_code return -1 We run our tests and you'll notice that they hang for a minute on the second test. That's because Python waits on line requests line until it gets a response. The server we're calling is really wimpy, so this might take some time. On my machine, the tests take 10.451 seconds to run. $ python -m unittest requester_tests.py .200 . ---------------------------------------------------------------------- Ran 2 tests in 10.451s OK Now we need to move on to our next function. We need to test that request_user_agent first checks the validity of the url. We also need to check that it returns -1 if the user agent is not set, and finally that it returns the content if the user agent is set. I've built the app on heroku specifically to do this. I know that if the user agent is 'DICE' the response will be 44260953. The idea is that you should be able to predict the output based on the input, and that's what you are testing. requester_tests.py import unittest import requester as target class TestRequester(unittest.TestCase): def setUp(self): self.url = 'https://computingconcepts.herokuapp.com' self.bad_url = 'https://computingconcepts.gopher' self.data = { 'username': 'bobby', 'email': 'bobby@bobby.com' } def test_basic_request_bad_url(self): response = target.basic_request(self.bad_url) self.assertEqual(-1, response) def test_basic_request_good_url(self): response = target.basic_request(self.url) self.assertEqual(200, response) def test_user_agent_bad_url(self): resp = target.request_user_agent(self.bad_url, 'DICE') self.assertEqual(-1, resp) def test_user_agent_no_user_agent(self): resp = target.request_user_agent(self.url, None) self.assertEqual(-1, resp) def test_user_agent_success(self): resp = target.request_user_agent(self.url, 'DICE') self.assertEqual('44260953', resp) I'm also going to quickly add a function to requester.py called request_user_agent() and have it pass so I don't have to go through the errors. We'll see that the tests fail. $ python -m unittest requester_tests.py ..FFF ====================================================================== FAIL: test_user_agent_bad_url (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 25, in test_user_agent_bad_url self.assertEqual(-1, resp) AssertionError: -1 != None ====================================================================== FAIL: test_user_agent_no_user_agent (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 29, in test_user_agent_no_user_agent self.assertEqual(-1, resp) AssertionError: -1 != None ====================================================================== FAIL: test_user_agent_success (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 33, in test_user_agent_success self.assertEqual(44260953, resp) AssertionError: 44260953 != None ---------------------------------------------------------------------- Ran 5 tests in 5.449s FAILED (failures=3) So now we need to write the code to make these tests pass. We can copy our url check from basic_request() and maybe add some or logic to it to catch when our user_agent is None. Then we just need to handle the request. Please do take a moment to look at the documentation for requests to figure out how you might pass a user_agent to the request object. requester.py import requests def basic_request(url): if url[-4:] != '.com': return -1 resp = requests.get(url) if resp.status_code == 200: return resp.status_code return -1 def request_user_agent(url, agent): if url[-4:] != '.com' or agent == None: return -1 headers = { 'User-Agent': agent } resp = requests.get(url, headers = headers) if resp.status_code == 200: return resp.text return -1 What's interesting here is that I ran into an unexpected error. Initially I returned resp.content but that yielded these results: (env) $ python -m unittest requester_tests.py ....F ====================================================================== FAIL: test_user_agent_success (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 33, in test_user_agent_success self.assertEqual(44260953, resp) AssertionError: 44260953 != b'44260953' ---------------------------------------------------------------------- Ran 5 tests in 9.271s FAILED (failures=1) I forgot that the data in the content is returned as bytes, so I had to use the text property instead. Now all my tests pass: (env) $ python -m unittest requester_tests.py ..... ---------------------------------------------------------------------- Ran 5 tests in 10.985s OK Now the last bit that we have to do is build our requests_post() function. Once again, I know that I need to test both of the parameters with the wrong data and both parameters with good data. However, instead of using the GET method, I know my function needs to call requests.post() instead. Again since I built the server to run tests against, I can predict the appropriate input and output for my function if it is working correctly. requester_tests.py import unittest import requester as target class TestRequester(unittest.TestCase): def setUp(self): self.url = 'https://computingconcepts.herokuapp.com' self.bad_url = 'https://computingconcepts.gopher' self.data = { 'username': 'bobby', 'email': 'bobby@bobby.com' } self.bad_data = { } def test_basic_request_bad_url(self): response = target.basic_request(self.bad_url) self.assertEqual(-1, response) def test_basic_request_good_url(self): response = target.basic_request(self.url) self.assertEqual(200, response) def test_user_agent_bad_url(self): resp = target.request_user_agent(self.bad_url, 'DICE') self.assertEqual(-1, resp) def test_user_agent_no_user_agent(self): resp = target.request_user_agent(self.url, None) self.assertEqual(-1, resp) def test_user_agent_success(self): resp = target.request_user_agent(self.url, 'DICE') self.assertEqual('44260953', resp) def test_post_bad_url(self): resp = target.request_post(self.bad_url, self.data) self.assertEqual(-1, resp) def test_post_no_data(self): resp = target.request_post(self.url, None) self.assertEqual(-1, resp) def test_post_bad_data(self): data = {'username': 'bad', 'email':'bad'} resp = target.request_post(self.url, data) self.assertEqual(\"You didn't submit the right data\", resp) def test_post_good_data(self): resp = target.request_post(self.url, self.data) self.assertEqual('44261853', resp) Then we add the request_post() function to requester.py and run our tests: $ python -m unittest requester_tests.py ..FFFF... ====================================================================== FAIL: test_post_bad_data (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 49, in test_post_bad_data self.assertEqual(\"You didn't submit the right data\", resp) AssertionError: \"You didn't submit the right data\" != None ====================================================================== FAIL: test_post_bad_url (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 40, in test_post_bad_url self.assertEqual(-1, resp) AssertionError: -1 != None ====================================================================== FAIL: test_post_good_data (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 53, in test_post_good_data self.assertEqual('44261853', resp) AssertionError: '44261853' != None ====================================================================== FAIL: test_post_no_data (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 44, in test_post_no_data self.assertEqual(-1, resp) AssertionError: -1 != None ---------------------------------------------------------------------- Ran 9 tests in 0.733s FAILED (failures=4) Excellent! Again it's failing like we want it to fail. Again, I've set up my tests to fail in a particular way so that when they pass, I know the code is doing exactly what I want it to be doing. I'm going to build out the code next. Again, I leave you to read up on how to send data with requests. It uses the post() method. requester.py import requests def basic_request(url): if url[-4:] != '.com': return -1 resp = requests.get(url) if resp.status_code == 200: return resp.status_code return -1 def request_user_agent(url, agent): if url[-4:] != '.com' or agent == None: return -1 headers = { 'User-Agent': agent } resp = requests.get(url, headers = headers) if resp.status_code == 200: return resp.text return -1 def request_post(url, data): if url[-4:] != '.com' or data == None: return -1 url = url + '/post' resp = requests.post(url, data = data) if resp.status_code == 200: return resp.text return -1 You'll notice that I'm concatenating '/post' to the url so that the right resource is being called by the request. Then we run our tests and we're good to go. (env) $ python -m unittest requester_tests.py ......... ---------------------------------------------------------------------- Ran 9 tests in 2.363s OK In the next chapter we'll finally be able to get into building our Flask app with TDD. We'll be building a miniature blog over the remaining chapters.","title":"6. TDD Online"},{"location":"ch6/#test-driven-design-and-the-web","text":"Before we move into Flask, I want to walk through an exercise of how we might develop a quick web client using the requests library and the test driven design approach. First, I have set up a resource at http://computingconcepts.herokuapp.com that returns status codes based on the request it receives. I built this as a toy to help students experiment with the requests library, and so it does the following: If it receives a GET request it will respond. If that GET request is accompanied by a user-agent called 'DICE' then it will return the string 44260953 in the body of the response The application is set up to handle POST requests at the resource named 'post', so the complete URL should be https://computingconcepts.herokuapp.com/post and if it received a POST request it will check the data. If the data is {'username': 'bobby', 'email': 'bobby@bobby.com'} then it will return the string 44261853 in the body of the response. If the data is wrong, it will return \"You didn't submit the right data\" The specifications of my assignment is the following: Build three functions: basic_request(), request_user_agent(), and request_post() basic_request takes one parameter: a URL. Uses requests to make a GET request to the URL. It returns -1 if the status code response from the URL is anything but 200, otherwise it returns 200. request_user_agent() takes 2 parameters, a URL and a user agent. It uses requests to make a GET request to the URL with the user agent defined. If the URL is bad or the user agent is not set, it will return -1. Otherwise, it will return the content of the response. I know the server above, so I can test this. request_post() takes 2 parameters, a URL and a data object (probably dictionary). If the URL is bad or if no data is included, it should return -1. Otherwise, it should return the content of the response. I know the server above so I can test this. Just arbitrarily, I want my functions to define a good url as anything that ends with '.com' (Again, this is a toy, so I'm trying to keep it really simple.) I know that I'm doing TDD so I need to start with some tests. I will begin with a setUp() and some tests to test the basic_request() method. requester_tests.py import unittest import requester as target class TestRequester(unittest.TestCase): def setUp(self): self.url = 'http://computingconcepts.herokuapp.com' self.bad_url = 'http://computingconcepts.gopher' self.data = { 'username': 'bobby', 'email': 'bobby@bobby.com' } def test_basic_request_bad_url(self): response = target.basic_request(self.bad_url) self.assertEqual(-1, response) def test_basic_request_good_url(self): response = target.basic_request(self.url) self.assertEqual(200, response) I'll need to install the requests library, so I'll do that right now and create the file requester.py. I'll then run my tests. (env) $ touch requester.py (env) $ pip install requests (env) $ python -m unittest requester_tests.py EE ====================================================================== ERROR: test_basic_request_bad_url (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/requester_tests.py\", line 16, in test_basic_request_bad_url response = target.basic_request(self.bad_url) AttributeError: module 'requester' has no attribute 'basic_request' ====================================================================== ERROR: test_basic_request_good_url (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"exercises/requester_tests.py\", line 20, in test_basic_request_good_url response = target.basic_request(self.url) AttributeError: module 'requester' has no attribute 'basic_request' ---------------------------------------------------------------------- Ran 2 tests in 0.001s FAILED (errors=2) Of course we don't have anything in our file, so let's get it set up so that the tests fail the right way. requester.py import requests def basic_request(url): pass I know this will make my tests fail the right way because there is the correct function to call and it returns nothing. Sure enough, when I run my tests: $ python -m unittest requester_tests.py FF ====================================================================== FAIL: test_basic_request_bad_url (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 17, in test_basic_request_bad_url self.assertEqual(-1, response) AssertionError: -1 != None ====================================================================== FAIL: test_basic_request_good_url (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 21, in test_basic_request_good_url self.assertEqual(200, response) AssertionError: 200 != None ---------------------------------------------------------------------- Ran 2 tests in 0.000s FAILED (failures=2) That's exactly the errors we want, so now we want to get it to pass. I know I want the function to check that the URL is valid first (by our silly arbitrary definition of valid as ending with .com). Second, I want it to use requests to call the valid URL. Third, I want to check the status code and return it if it is 200. If 200 is not the status code or there is a problem with the URL, we should return -1. I've done all that in the code below: requester.py import requests def basic_request(url): if url[-4:] != '.com': return -1 resp = requests.get(url) if resp.status_code == 200: return resp.status_code return -1 We run our tests and you'll notice that they hang for a minute on the second test. That's because Python waits on line requests line until it gets a response. The server we're calling is really wimpy, so this might take some time. On my machine, the tests take 10.451 seconds to run. $ python -m unittest requester_tests.py .200 . ---------------------------------------------------------------------- Ran 2 tests in 10.451s OK Now we need to move on to our next function. We need to test that request_user_agent first checks the validity of the url. We also need to check that it returns -1 if the user agent is not set, and finally that it returns the content if the user agent is set. I've built the app on heroku specifically to do this. I know that if the user agent is 'DICE' the response will be 44260953. The idea is that you should be able to predict the output based on the input, and that's what you are testing. requester_tests.py import unittest import requester as target class TestRequester(unittest.TestCase): def setUp(self): self.url = 'https://computingconcepts.herokuapp.com' self.bad_url = 'https://computingconcepts.gopher' self.data = { 'username': 'bobby', 'email': 'bobby@bobby.com' } def test_basic_request_bad_url(self): response = target.basic_request(self.bad_url) self.assertEqual(-1, response) def test_basic_request_good_url(self): response = target.basic_request(self.url) self.assertEqual(200, response) def test_user_agent_bad_url(self): resp = target.request_user_agent(self.bad_url, 'DICE') self.assertEqual(-1, resp) def test_user_agent_no_user_agent(self): resp = target.request_user_agent(self.url, None) self.assertEqual(-1, resp) def test_user_agent_success(self): resp = target.request_user_agent(self.url, 'DICE') self.assertEqual('44260953', resp) I'm also going to quickly add a function to requester.py called request_user_agent() and have it pass so I don't have to go through the errors. We'll see that the tests fail. $ python -m unittest requester_tests.py ..FFF ====================================================================== FAIL: test_user_agent_bad_url (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 25, in test_user_agent_bad_url self.assertEqual(-1, resp) AssertionError: -1 != None ====================================================================== FAIL: test_user_agent_no_user_agent (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 29, in test_user_agent_no_user_agent self.assertEqual(-1, resp) AssertionError: -1 != None ====================================================================== FAIL: test_user_agent_success (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 33, in test_user_agent_success self.assertEqual(44260953, resp) AssertionError: 44260953 != None ---------------------------------------------------------------------- Ran 5 tests in 5.449s FAILED (failures=3) So now we need to write the code to make these tests pass. We can copy our url check from basic_request() and maybe add some or logic to it to catch when our user_agent is None. Then we just need to handle the request. Please do take a moment to look at the documentation for requests to figure out how you might pass a user_agent to the request object. requester.py import requests def basic_request(url): if url[-4:] != '.com': return -1 resp = requests.get(url) if resp.status_code == 200: return resp.status_code return -1 def request_user_agent(url, agent): if url[-4:] != '.com' or agent == None: return -1 headers = { 'User-Agent': agent } resp = requests.get(url, headers = headers) if resp.status_code == 200: return resp.text return -1 What's interesting here is that I ran into an unexpected error. Initially I returned resp.content but that yielded these results: (env) $ python -m unittest requester_tests.py ....F ====================================================================== FAIL: test_user_agent_success (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 33, in test_user_agent_success self.assertEqual(44260953, resp) AssertionError: 44260953 != b'44260953' ---------------------------------------------------------------------- Ran 5 tests in 9.271s FAILED (failures=1) I forgot that the data in the content is returned as bytes, so I had to use the text property instead. Now all my tests pass: (env) $ python -m unittest requester_tests.py ..... ---------------------------------------------------------------------- Ran 5 tests in 10.985s OK Now the last bit that we have to do is build our requests_post() function. Once again, I know that I need to test both of the parameters with the wrong data and both parameters with good data. However, instead of using the GET method, I know my function needs to call requests.post() instead. Again since I built the server to run tests against, I can predict the appropriate input and output for my function if it is working correctly. requester_tests.py import unittest import requester as target class TestRequester(unittest.TestCase): def setUp(self): self.url = 'https://computingconcepts.herokuapp.com' self.bad_url = 'https://computingconcepts.gopher' self.data = { 'username': 'bobby', 'email': 'bobby@bobby.com' } self.bad_data = { } def test_basic_request_bad_url(self): response = target.basic_request(self.bad_url) self.assertEqual(-1, response) def test_basic_request_good_url(self): response = target.basic_request(self.url) self.assertEqual(200, response) def test_user_agent_bad_url(self): resp = target.request_user_agent(self.bad_url, 'DICE') self.assertEqual(-1, resp) def test_user_agent_no_user_agent(self): resp = target.request_user_agent(self.url, None) self.assertEqual(-1, resp) def test_user_agent_success(self): resp = target.request_user_agent(self.url, 'DICE') self.assertEqual('44260953', resp) def test_post_bad_url(self): resp = target.request_post(self.bad_url, self.data) self.assertEqual(-1, resp) def test_post_no_data(self): resp = target.request_post(self.url, None) self.assertEqual(-1, resp) def test_post_bad_data(self): data = {'username': 'bad', 'email':'bad'} resp = target.request_post(self.url, data) self.assertEqual(\"You didn't submit the right data\", resp) def test_post_good_data(self): resp = target.request_post(self.url, self.data) self.assertEqual('44261853', resp) Then we add the request_post() function to requester.py and run our tests: $ python -m unittest requester_tests.py ..FFFF... ====================================================================== FAIL: test_post_bad_data (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 49, in test_post_bad_data self.assertEqual(\"You didn't submit the right data\", resp) AssertionError: \"You didn't submit the right data\" != None ====================================================================== FAIL: test_post_bad_url (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 40, in test_post_bad_url self.assertEqual(-1, resp) AssertionError: -1 != None ====================================================================== FAIL: test_post_good_data (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 53, in test_post_good_data self.assertEqual('44261853', resp) AssertionError: '44261853' != None ====================================================================== FAIL: test_post_no_data (requester_tests.TestRequester) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/home/user1/SU/everyday/week3/exercises/requester_tests.py\", line 44, in test_post_no_data self.assertEqual(-1, resp) AssertionError: -1 != None ---------------------------------------------------------------------- Ran 9 tests in 0.733s FAILED (failures=4) Excellent! Again it's failing like we want it to fail. Again, I've set up my tests to fail in a particular way so that when they pass, I know the code is doing exactly what I want it to be doing. I'm going to build out the code next. Again, I leave you to read up on how to send data with requests. It uses the post() method. requester.py import requests def basic_request(url): if url[-4:] != '.com': return -1 resp = requests.get(url) if resp.status_code == 200: return resp.status_code return -1 def request_user_agent(url, agent): if url[-4:] != '.com' or agent == None: return -1 headers = { 'User-Agent': agent } resp = requests.get(url, headers = headers) if resp.status_code == 200: return resp.text return -1 def request_post(url, data): if url[-4:] != '.com' or data == None: return -1 url = url + '/post' resp = requests.post(url, data = data) if resp.status_code == 200: return resp.text return -1 You'll notice that I'm concatenating '/post' to the url so that the right resource is being called by the request. Then we run our tests and we're good to go. (env) $ python -m unittest requester_tests.py ......... ---------------------------------------------------------------------- Ran 9 tests in 2.363s OK In the next chapter we'll finally be able to get into building our Flask app with TDD. We'll be building a miniature blog over the remaining chapters.","title":"Test Driven Design and the Web"},{"location":"ch7/","text":"Introduction to Flask Flask is a Python microframework that is amazingly easy to use and still relatively powerful. But before we get ahead of ourselves, what the heck is a framework? Think about it this way: If I wanted to build a brick wall from scratch, I would need to first be able to make bricks from clay. I'd also need to know how to mix mortar to the appropriate consistency. I'd also probably need to know a bit about the general physics behind wall building. Etc. Of course, I don't do that. I'd probably get plans off the internet, buy bricks from Mutual Materials or Home Depot or Salmon Bay, I'd also buy mortar mix (cuz mixing real mortar, while cool, is a pain), and all the tools I need to assemble the wall. A framework is kind of like that. A web framework is a set of classes and functions that have been built for you that you assemble and tweak as you see fit. For instance, you could write a server to listen for HTTP requests. You could also write your own database interface, and so on. But you probably don't need to because one out there already exists that's been tested and optimized for your use case. That's what frameworks do. A framework is a set of tools that manages the common operations of applications freeing up your time to develop within those frameworks the specific features of your application. There are numerous web frameworks to choose from in many languages, most popular include PHP, Python, Javascript, and Ruby. Some popular ones include Wordpress, Drupal, Laravel and CodeIgniter in PHP, and Django and Flask in Python. Wordpress and Drupal are both CMS' rather than web frameworks, but they are often used to develop applications. They provide great tools for people who don't necessarily want to get their hands dirty writing code. That being said, they are much more limited in terms of what you can do unless you want to write your own modules. The rest are more true to the web framework idea. You will have to code something, but much of your coding will involve using build in functions and classes. Laravel and Django are both full frameworks, whereas CodeIgniter and Flask are micro-frameworks. You will notice that I don't mention any Javascript frameworks. That's in part because we won't touch much Javascript, and in part because that material is covered in the WATS program. We're not going to learn Laravel or CodeIgniter because they are in PHP, we learn Python, and PHP is a strange and ugly language that powers much of the web, but doesn't do much else. Once you've learned developing apps in Python, you could easily take a few weeks and learn how to do it in PHP. Here is a chart comparing their popularity based Google Search trends. trends.embed.renderExploreWidget(\"TIMESERIES\", {\"comparisonItem\":[{\"keyword\":\"/m/0dgs72v\",\"geo\":\"US\",\"time\":\"today 5-y\"},{\"keyword\":\"/m/06y_qx\",\"geo\":\"US\",\"time\":\"today 5-y\"},{\"keyword\":\"/m/0jwy148\",\"geo\":\"US\",\"time\":\"today 5-y\"}],\"category\":0,\"property\":\"\"}, {\"exploreQuery\":\"date=today%205-y&amp;geo=US&amp;q=%2Fm%2F0dgs72v,%2Fm%2F06y_qx,%2Fm%2F0jwy148\",\"guestPath\":\"https://trends.google.com:443/trends/embed/\"}); In searching for the top skills that a Python developer ought to have after being familiar with Python, Django and Flask come up as the first and second regularly. We're learning Flask in this class because it's a lot smaller and because it does less of its work automagically. To write a really complicated app in Flask would be more time consuming than it would be in Django because Django is so comprehensive, but we're not building complicated apps, and once you've learned Flask, you can go pick up Django pretty easily. The concepts are the same, but Django has more features built in. Design Patterns Web frameworks are built on a design pattern that separates concerns: for instance, separating the user interface from the processing. Separating concerns is a crucial concept of programming. An example might be the functions we've built so far. You'll notice that we didn't use a single input() function or print() function. This is because we were building general functions whose aim was to perform a single operation. Keeping the processing logic separate from the user interface is useful. My calculator can work with any user interface and is not dependent upon a single user interface to work. I could link it to a command line user interface just as easily as I could link it to a web application. As long as my functions are getting the right parameters, they will return the appropriate values. Additionally, I can have separate design teams working on the data processing and the user interface. This is a good practice in general and makes whatever we build significantly more flexible. Code that keeps elements tightly linked so that the processing is dependent upon the user interface and vice versa is called tightly coupled. For instance, if I used input() to get an integer from my user in the prime_factors() function instead of the parameters, I would have written a user interface that was tightly coupled to the function that processes the input from the user. On the other hand when our components are not necessarily dependent on the design of the other components, we would call them loosely coupled. Generally, loosely coupled components are better. Model View Controller Web frameworks generally separate concerns following a pattern similar to Model-View-Controller, or MVC. The Model-View-Controller pattern separates our concerns into three components. The Model is the component responsible for managing data and usually interfaces with some database where the data will be stored. Likewise, the Model might do some data processing. The View or Views is the component responsible for the user interface. The Views in Web Frameworks usually use some templating language that is rendered into HTML/CSS and Javascript to be sent over the network to the client. Likewise, Views usually include the forms that allow the user to send data to the application. The Controller is the component that links the Models and the Views. Let's say you've created a blog. When the user requests a particular post, they make a GET request through a link in one of the pages rendered in their web browser. The routing mechanism in the framework listens for the particular request and calls the appropriate Controller. The Controller calls the function in the Model that retrieves the requested post. It then takes that data returned by the Model function and puts that into the appropriate view (probably a template for displaying a single blog post on a page). It assembles the data and the template and sends that as an HTML/CSS and Javascript web page for the user to see. There are MVC frameworks written in Python, PHP, C++, Java, and C#. The strength is they are well developed and have all the components you need to build a large website and set of applications. Sometimes the design pattern is slightly different. Django, for instance, follows a Model, View, Template pattern. In this case, the View acts more like a controller. It calls functions from the Model and populates the Template. Regardless of the slight variations, this design pattern that separates concerns is common across frameworks. One cool trick about separating concerns is that you can replace with little difficulty the View component, and one strategy is replacing the View component built into the framework with a Javascript frontend framework like React or Vue or Angular. Generally this is done by having the MVC framework generate JSON objects that get sent to the frontend framework. What this has to do with Flask Flask is not a traditional Framework. It is a microframework, so it does things slightly differently. Traditional frameworks assume that you'll need things like a database and user authentication and so on. As a result, those components are built in and make the framework pretty large. Flask's philosophy is to include only the bare minimum. As a result, it does not come with a database system or user authentication and so on. That doesn't mean you can't add it later, but it does mean that if you don't need a database, it's not there to take up space and get in the way. When the server running Flask gets a request, it sends that request to Flask. Flask's routes listen for known requests. If one of the routes is requested properly, the route function collects all of the resources including the database objects (if using) and the templates, and returns those to the client. This will make more sense when we start building, so let's get started. In the next chapter, we'll seet up the bare minimum web application possible in Flask. It will contain 7 lines of code and we'll developing using TDD.","title":"7. Intro to Flask"},{"location":"ch7/#introduction-to-flask","text":"Flask is a Python microframework that is amazingly easy to use and still relatively powerful. But before we get ahead of ourselves, what the heck is a framework? Think about it this way: If I wanted to build a brick wall from scratch, I would need to first be able to make bricks from clay. I'd also need to know how to mix mortar to the appropriate consistency. I'd also probably need to know a bit about the general physics behind wall building. Etc. Of course, I don't do that. I'd probably get plans off the internet, buy bricks from Mutual Materials or Home Depot or Salmon Bay, I'd also buy mortar mix (cuz mixing real mortar, while cool, is a pain), and all the tools I need to assemble the wall. A framework is kind of like that. A web framework is a set of classes and functions that have been built for you that you assemble and tweak as you see fit. For instance, you could write a server to listen for HTTP requests. You could also write your own database interface, and so on. But you probably don't need to because one out there already exists that's been tested and optimized for your use case. That's what frameworks do. A framework is a set of tools that manages the common operations of applications freeing up your time to develop within those frameworks the specific features of your application. There are numerous web frameworks to choose from in many languages, most popular include PHP, Python, Javascript, and Ruby. Some popular ones include Wordpress, Drupal, Laravel and CodeIgniter in PHP, and Django and Flask in Python. Wordpress and Drupal are both CMS' rather than web frameworks, but they are often used to develop applications. They provide great tools for people who don't necessarily want to get their hands dirty writing code. That being said, they are much more limited in terms of what you can do unless you want to write your own modules. The rest are more true to the web framework idea. You will have to code something, but much of your coding will involve using build in functions and classes. Laravel and Django are both full frameworks, whereas CodeIgniter and Flask are micro-frameworks. You will notice that I don't mention any Javascript frameworks. That's in part because we won't touch much Javascript, and in part because that material is covered in the WATS program. We're not going to learn Laravel or CodeIgniter because they are in PHP, we learn Python, and PHP is a strange and ugly language that powers much of the web, but doesn't do much else. Once you've learned developing apps in Python, you could easily take a few weeks and learn how to do it in PHP. Here is a chart comparing their popularity based Google Search trends. trends.embed.renderExploreWidget(\"TIMESERIES\", {\"comparisonItem\":[{\"keyword\":\"/m/0dgs72v\",\"geo\":\"US\",\"time\":\"today 5-y\"},{\"keyword\":\"/m/06y_qx\",\"geo\":\"US\",\"time\":\"today 5-y\"},{\"keyword\":\"/m/0jwy148\",\"geo\":\"US\",\"time\":\"today 5-y\"}],\"category\":0,\"property\":\"\"}, {\"exploreQuery\":\"date=today%205-y&amp;geo=US&amp;q=%2Fm%2F0dgs72v,%2Fm%2F06y_qx,%2Fm%2F0jwy148\",\"guestPath\":\"https://trends.google.com:443/trends/embed/\"}); In searching for the top skills that a Python developer ought to have after being familiar with Python, Django and Flask come up as the first and second regularly. We're learning Flask in this class because it's a lot smaller and because it does less of its work automagically. To write a really complicated app in Flask would be more time consuming than it would be in Django because Django is so comprehensive, but we're not building complicated apps, and once you've learned Flask, you can go pick up Django pretty easily. The concepts are the same, but Django has more features built in.","title":"Introduction to Flask"},{"location":"ch7/#design-patterns","text":"Web frameworks are built on a design pattern that separates concerns: for instance, separating the user interface from the processing. Separating concerns is a crucial concept of programming. An example might be the functions we've built so far. You'll notice that we didn't use a single input() function or print() function. This is because we were building general functions whose aim was to perform a single operation. Keeping the processing logic separate from the user interface is useful. My calculator can work with any user interface and is not dependent upon a single user interface to work. I could link it to a command line user interface just as easily as I could link it to a web application. As long as my functions are getting the right parameters, they will return the appropriate values. Additionally, I can have separate design teams working on the data processing and the user interface. This is a good practice in general and makes whatever we build significantly more flexible. Code that keeps elements tightly linked so that the processing is dependent upon the user interface and vice versa is called tightly coupled. For instance, if I used input() to get an integer from my user in the prime_factors() function instead of the parameters, I would have written a user interface that was tightly coupled to the function that processes the input from the user. On the other hand when our components are not necessarily dependent on the design of the other components, we would call them loosely coupled. Generally, loosely coupled components are better.","title":"Design Patterns"},{"location":"ch7/#model-view-controller","text":"Web frameworks generally separate concerns following a pattern similar to Model-View-Controller, or MVC. The Model-View-Controller pattern separates our concerns into three components. The Model is the component responsible for managing data and usually interfaces with some database where the data will be stored. Likewise, the Model might do some data processing. The View or Views is the component responsible for the user interface. The Views in Web Frameworks usually use some templating language that is rendered into HTML/CSS and Javascript to be sent over the network to the client. Likewise, Views usually include the forms that allow the user to send data to the application. The Controller is the component that links the Models and the Views. Let's say you've created a blog. When the user requests a particular post, they make a GET request through a link in one of the pages rendered in their web browser. The routing mechanism in the framework listens for the particular request and calls the appropriate Controller. The Controller calls the function in the Model that retrieves the requested post. It then takes that data returned by the Model function and puts that into the appropriate view (probably a template for displaying a single blog post on a page). It assembles the data and the template and sends that as an HTML/CSS and Javascript web page for the user to see. There are MVC frameworks written in Python, PHP, C++, Java, and C#. The strength is they are well developed and have all the components you need to build a large website and set of applications. Sometimes the design pattern is slightly different. Django, for instance, follows a Model, View, Template pattern. In this case, the View acts more like a controller. It calls functions from the Model and populates the Template. Regardless of the slight variations, this design pattern that separates concerns is common across frameworks. One cool trick about separating concerns is that you can replace with little difficulty the View component, and one strategy is replacing the View component built into the framework with a Javascript frontend framework like React or Vue or Angular. Generally this is done by having the MVC framework generate JSON objects that get sent to the frontend framework.","title":"Model View Controller"},{"location":"ch7/#what-this-has-to-do-with-flask","text":"Flask is not a traditional Framework. It is a microframework, so it does things slightly differently. Traditional frameworks assume that you'll need things like a database and user authentication and so on. As a result, those components are built in and make the framework pretty large. Flask's philosophy is to include only the bare minimum. As a result, it does not come with a database system or user authentication and so on. That doesn't mean you can't add it later, but it does mean that if you don't need a database, it's not there to take up space and get in the way. When the server running Flask gets a request, it sends that request to Flask. Flask's routes listen for known requests. If one of the routes is requested properly, the route function collects all of the resources including the database objects (if using) and the templates, and returns those to the client. This will make more sense when we start building, so let's get started. In the next chapter, we'll seet up the bare minimum web application possible in Flask. It will contain 7 lines of code and we'll developing using TDD.","title":"What this has to do with Flask"},{"location":"ch8/","text":"Getting Started with Flask Ok, so I said in the last chapter that we would begin by writing a Flask web application in 7 lines of code, but that's getting a bit ahead of ourselves. There is some setup that we need to do first. Then we have to write a unittest or two. Then once we get our unittest to fail, we'll build our app and get that unittest to pass. Over the next series of chapters we'll be building a simple blogging platform. To do that, we'll be reusing our code, refactoring, and adding to it as we go. Expect to have to make changes to the code that you've already written. Setup the Environment Our first step is to create a directory where all of our code for this project will go. This will be the project root and nothing for this project should exist outside of this directory. To do this enter your terminal, navigate to a convenient location, and create a directory. For me, I have a directory called Projects where I put all of my projects. So I navigate to that directory, create a new one called blog , which is totally arbitrary, and then change directories into that new directory: ~$ cd Projects ~/Projects/$ mkdir blog && cd blog ~/Projects/blog$ Next, I want to set up a virtual environment and version control. If you've never used git before for version control, I recommend this tutorial: git tutorial . Likewise, if you want to be able to share your code using Github, you can add a remote repository that you can push your changes to. I'll be doing both. I like to do this before I set up the virtual environment because I'm going to tell git to ignore all of the virtual environment files. I'll show you all of the steps first, and then I'll explain each of them. ~/Projects/blog$ git init Initialized empty Git repository in /home/user1/Projects/blog/.git/ ~/Projects/blog$ git remote add origin git@github.com:dlondonmedina/blog.git ~/Projects/blog$ touch .gitignore ~/Projects/blog$ python3 -m venv env ~/Projects/blog$ source env/bin/activate (env) ~/Projects/blog$ pip install flask Collecting flask Downloading https://files.pythonhosted.org/packages/f2/28/2a03252dfb9ebf377f40fba6a7841b47083260bf8bd8e737b0c6952df83f/Flask-1.1.2-py2.py3-none-any.whl (94kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 102kB 1.3MB/s Collecting click>=5.1 (from flask) Downloading https://files.pythonhosted.org/packages/dd/c0/4d8f43a9b16e289f36478422031b8a63b54b6ac3b1ba605d602f10dd54d6/click-7.1.1-py2.py3-none-any.whl (82kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 92kB 2.9MB/s Collecting Werkzeug>=0.15 (from flask) Downloading https://files.pythonhosted.org/packages/cc/94/5f7079a0e00bd6863ef8f1da638721e9da21e5bacee597595b318f71d62e/Werkzeug-1.0.1-py2.py3-none-any.whl (298kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 307kB 3.3MB/s Collecting itsdangerous>=0.24 (from flask) Using cached https://files.pythonhosted.org/packages/76/ae/44b03b253d6fade317f32c24d100b3b35c2239807046a4c953c7b89fa49e/itsdangerous-1.1.0-py2.py3-none-any.whl Collecting Jinja2>=2.10.1 (from flask) Downloading https://files.pythonhosted.org/packages/30/9e/f663a2aa66a09d838042ae1a2c5659828bb9b41ea3a6efa20a20fd92b121/Jinja2-2.11.2-py2.py3-none-any.whl (125kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 133kB 1.6MB/s Collecting MarkupSafe>=0.23 (from Jinja2>=2.10.1->flask) Using cached https://files.pythonhosted.org/packages/b2/5f/23e0023be6bb885d00ffbefad2942bc51a620328ee910f64abe5a8d18dd1/MarkupSafe-1.1.1-cp36-cp36m-manylinux1_x86_64.whl Installing collected packages: click, Werkzeug, itsdangerous, MarkupSafe, Jinja2, flask Successfully installed Jinja2-2.11.2 MarkupSafe-1.1.1 Werkzeug-1.0.1 click-7.1.1 flask-1.1.2 itsdangerous-1.1.0 (env) ~/Projects/blog$ pip freeze > requirements.txt (env) ~/Projects/blog$ ls env requirements.txt git init This initializes the directory as a git repository. This means that I can use git to track the changes made to this directory. What happens is git creates \"snapshots\" of the directory and each time we commit a new \"snapshot\" of the changes from the previous version is saved. If we want to rollback changes, then all that has to happen is for git to restore to the previous snapshot. git remote add origin ... This links my local repository created in the previous line to a remote repository on Github that I already created. It is an empty repository online, so I just need to add the remote link. You'll notice I'm using ssh instead of https. When I want to copy my local repository to my remote repository, I'll use the git push command. touch .gitignore I create a .gitignore file. This tells git that some files should be ignored from the version tracking. I'll add content that next and then I'll commit my changes and push to github. python3 -m venv env This uses the venv module, which is part of Python, to create a virtual environment in a directory called env If you only have Python 3 installed and not Python 2, then your command might be different. On Unix (OSX, Linux) based operating systems you'll probably have Python 2 installed by default. source env/bin/activate This activates the virtual environment. The command is different if you are on Windows ( env\\Scripts\\activate without source ). pip install flask This installs Flask in this virtual environment. If you read the output of this command you'll see that flask, click, Werkzeug, itsdangerous, Jinja2, and MarkupSafe are all also installed. These are the dependencies that flask requires. Since we activated the virutal environment in the last step, Flask is only installed to this environment and not globally. pip freeze > requirements.txt This tells pip to write the list of dependencies that we've installed in this virtual environment to a file called requirements.txt. This will make it easy to reinstall our application elsewhere and make sure our requirements are all correct. Finally, I'm listing out the content of my blog directory. Now we need to get our .gitignore in working order. If you create your repository on Github first and then clone it from there. You can have Github initialize the repository with a README, a License, and a .gitignore files. This is convenient, but I chose not to do that here. So, I need to create the gitignore file. I like to copy the one that Github uses, so I just visit: Github Python.gitignore and copy it into my .gitignore file. .gitignore # Byte-compiled / optimized / DLL files __pycache__/ *.py[cod] *$py.class # C extensions *.so # Distribution / packaging .Python build/ develop-eggs/ dist/ downloads/ eggs/ .eggs/ lib/ lib64/ parts/ sdist/ var/ wheels/ share/python-wheels/ *.egg-info/ .installed.cfg *.egg MANIFEST # PyInstaller # Usually these files are written by a python script from a template # before PyInstaller builds the exe, so as to inject date/other infos into it. *.manifest *.spec # Installer logs pip-log.txt pip-delete-this-directory.txt # Unit test / coverage reports htmlcov/ .tox/ .nox/ .coverage .coverage.* .cache nosetests.xml coverage.xml *.cover *.py,cover .hypothesis/ .pytest_cache/ cover/ # Translations *.mo *.pot # Django stuff: *.log local_settings.py db.sqlite3 db.sqlite3-journal # Flask stuff: instance/ .webassets-cache # Scrapy stuff: .scrapy # Sphinx documentation docs/_build/ # PyBuilder .pybuilder/ target/ # Jupyter Notebook .ipynb_checkpoints # IPython profile_default/ ipython_config.py # pyenv # For a library or package, you might want to ignore these files since the code is # intended to run in multiple environments; otherwise, check them in: # .python-version # pipenv # According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control. # However, in case of collaboration, if having platform-specific dependencies or dependencies # having no cross-platform support, pipenv may install dependencies that don't work, or not # install all needed dependencies. #Pipfile.lock # PEP 582; used by e.g. github.com/David-OConnor/pyflow __pypackages__/ # Celery stuff celerybeat-schedule celerybeat.pid # SageMath parsed files *.sage.py # Environments .env .venv env/ venv/ ENV/ env.bak/ venv.bak/ # Spyder project settings .spyderproject .spyproject # Rope project settings .ropeproject # mkdocs documentation /site # mypy .mypy_cache/ .dmypy.json dmypy.json # Pyre type checker .pyre/ # pytype static type analyzer .pytype/ # Cython debug symbols cython_debug/ I might go through and remove all of the lines that I know I won't use, but for now, this works. For instance, I know that my virtual environment directory is called env/ , so I could remove all of the other ones in the .gitignore. Now I'm almost done. I've created my environment, I just need to commit it to git and push it to Github. This is pretty simple: (env) ~/Projects/blog$ git status On branch master No commits yet Untracked files: (use \"git add <file>...\" to include in what will be committed) .gitignore requirements.txt nothing added to commit but untracked files present (use \"git add\" to track) (env) ~/Projects/blog$ git add . (env) ~/Projects/blog$ git commit -m \"initial commit\" [master (root-commit) c83fa38] initial commit 2 files changed, 146 insertions(+) create mode 100644 .gitignore create mode 100644 requirements.txt (env) ~/Projects/blog$ git push origin master Counting objects: 4, done. Delta compression using up to 4 threads. Compressing objects: 100% (4/4), done. Writing objects: 100% (4/4), 1.40 KiB | 1.40 MiB/s, done. Total 4 (delta 0), reused 0 (delta 0) To github.com:dlondonmedina/blog.git * [new branch] master -> master (env) ~/Projects/blog$ git status This tells me what the status is of my git repositiory. You'll see that .gitignore and requirements.txt are not being tracked yet. I like to check this before I commit because sometimes I am not paying perfect attention to all the changes I've made. git add . This adds all of the untracked files and changes to git tracking. This can be undone at this point. You can also specify which files to track by replacing the dot with the file name. git commit -m \"initial commit\" This line commits the changes I just made to the git repository. In other words, it makes a \"snapshot\" of the repository in this current condition. The \"initial commit\" part is an arbitrary message. It should say briefly what the commit changed. I'm a fan of many smaller commits, so these messages should be short. You'll see as we go. git push origin master This finally pushes the changes we made to our local repository up to our remote repository. It says literally, git, please push the changes made on the master branch to the origin (you'll notice we added the remote as origin in the previous series of commands). Okay. Our environment is set up. Now we're ready to turn to our tests. Building our tests and app Flask is a web application microframework, so what we'll be testing is the features we've built with Flask. Unlike the functions we've tested so far, we'll be testing an application designed to receive its input from clients on the internet. This means we need to think about how our tests are going to access our application. We have two ways to do this: we could run our web application and then have our tests make requests to the test server that runs the web application, or we can use the built in test client and make our requests through the test client. I'm going to walk through both approaches. For the former, we'll be using the requests library, but in the future, we'll be using selenium to simulate requests made by a web browser. More about that in the next chapter. Our first step is to set up our test directory and our app directory. These will keep our application and our tests contained. Both of these directories should be children of blog/ and siblings of env . We're also going to create a few files to get set up. I've included the output from ls to show you what is in each directory. (env) ~/Projects/blog$ mkdir app tests (env) ~/Projects/blog$ touch app.py app/__init__.py (env) ~/Projects/blog$ touch tests/blog_tests.py tests/blog_web_tests.py (env) ~/Projects/blog$ ls app app.py env __pycache__ requirements.txt tests (env) ~/Projects/blog$ ls app __init__.py (env) ~/Projects/blog$ ls tests blog_tests.py blog_web_tests.py Now we're going to get our first test setup. The basic Flask application listens at various different routes. If you recall from the chapters on the Internet, when we navigate the web, we visit URLs. A URL includes the domain and subdomain, followed by any parameters that are sent to the server. So, https://example.com/index.html is a resource at example.com and the specific name of the resource is index.html, which is an html file that the server should be able to return. Web servers are usually setup to serve index.html or index.js or index.php, etc. by default, so a request to https://example.com by default should return index.html. With web frameworks, our servers, however, are not serving up static html files. Instead, they are building the html dynamically. So, https://example.com/posts would make a call to the server listening at the address identified by example.com, and it would call the posts method or route. I'd assume based on the name that the posts method would return a web page containing a list of the current posts. We'll discuss this in depth in the next few chapters, but for now, know that our Flask app has specific routes or methods that are registered and will respond if they are called. This will become more apparent as we start. For now, though, lets set up our first tests. Using Requests I'm going to start by writing the tests that would simulate a user making a request across a network. Then I'll create the test that uses the built-in test_client() feature of Flask. To simulate the requests, I'll use the requests library. To do that I install the library. (env) ~/Projects/blog$ pip install requests and then fix my dependencies with this command (env) ~/Projects/blog$ pip freeze > requirements.txt Now I need to consider what I'm going to test. The easiest way would be to see if the application returns a particular text value. I also need to know what URL the test server uses to host Flask. It happens to be http://127.0.0.1:5000. With that in mind, let's set up our test. blog_web_tests.py import unittest import requests class TestBlog(unittest.TestCase): def setUp(self): self.url = 'http://127.0.0.1:5000/' def test_hello_flask(self): resp = requests.get(self.url) self.assertEquals('Hello Flask!', resp.text) First, I import the two modules--unittest and requests--and then as we've been doing we set up our test class. setUp(self) This method is called automatically by the test runner and it sets a class property called url to the string of the IP address that the Flask test server will be listening at. test_hello_flask(self) This test first uses requests to call the Flask server. It then tests that the server responded with the string 'Hello Flask!'. This is an arbitrary string that I will use when I build the app. Run our tests and let's see where we're at. There will be many errors, so I'm removing the traceback for efficiency sake. ~/Projects/blog$ python -m unittest tests/blog_web_tests.py E ====================================================================== ERROR: test_hello_flask (tests.blog_web_tests.TestBlog) ---------------------------------------------------------------------- Traceback (most recent call last): ... [Removed for brevity] ... ConnectionRefusedError: [Errno 111] Connection refused ---------------------------------------------------------------------- Ran 1 test in 0.033s FAILED (errors=1) The ConnectionRefusedError suggests that when requests tried to make a request to the url, the server at the URL refused it. This makes sense because I don't have an app yet. So let me get some things set up so that at least there's an app. app.py from app import app This is a simple script that initializes our instance of Flask. It will try to import from our app directory, which will automatically run __init__.py.py in that directory, which will contain our Flask application code. So let's go there next. __init__.py from flask import Flask app = Flask(__name__) @app.route('/') def hello_flask(): return '' from flask import Flask We're importing the Flask class which contains our basic web microframework object. app = Flask(__name__) This line instantiates Flask as a variable named \"app.\" If you remember from app.py, the app here is the one that is imported in app.py. @app.route('/') is a decorator that passes the following function to the route() method. Next chapter we will discuss this in depth. For now, think of this as the way hello_flask() is called when a user requests the route. I'm not quite ready to run my tests yet. If I were to do so, I would get the same errors because my Flask app isn't running yet. To do this, I need to launch the Flask app and then run my tests. (env) ~/Projects/blog$ export FLASK_APP=app.py (env) ~/Projects/blog$ python -m flask run * Serving Flask app \"app.py\" * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Debug mode: off * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) export FLASK_APP=app.py This line creates an environmental variable called FLASK_APP. When we call flask run on the next line, the program looks for this variable and then runs the assigned script (app.py). In the following output, we can see some information about the server running our Flask app. Don't worry about the WARNING for now, but the key is to not set up flask on a live web server using this method. Now we open a second terminal, launch our virtual environment, and run our tests again. (env) ~/Projects/blog$ python -m unittest tests/blog_web_tests.py F ====================================================================== FAIL: test_hello_flask (tests.blog_web_tests.TestBlog) ---------------------------------------------------------------------- Traceback (most recent call last): File \"blog/tests/blog_web_tests.py\", line 11, in test_hello_flask self.assertIn('Hello Flask!', resp.text) AssertionError: 'Hello Flask!' not found in '' ---------------------------------------------------------------------- Ran 1 test in 0.005s FAILED (failures=1) This is the kind of failure we're looking for. We'll notice that our flask app is returning an empty string. All we need to do now is change that return and run our tests again. __init__.py from flask import Flask app = Flask(__name__) @app.route('/') def hello_flask(): return 'Hello Flask!' and it fails again. We need to relaunch our flask app. To do this, open the terminal that is running our flask app, and use CTRL+C to stop the process. Then type python -m flask run again and our tests pass: (env) ~/Projects/blog$ python -m unittest tests/blog_web_tests.py. ---------------------------------------------------------------------- Ran 1 test in 0.006s OK Using Test Client Now, I'm going to build tests using the test_client(). I won't rewrite the Flask app, so I'll just show you the new tests. My first step is to shut down the test server I launched in the last section. Just as the test server ran our Flask app, the test_client gives us access to make calls to our app directly without launching a test server. blog_tests.py import unittest from app import app class TestBlog(unittest.TestCase): def setUp(self): self.client = app.test_client() def test_hello_flask(self): resp = self.client.get('/') self.assertEqual(b'Hello Flask!', resp.data) def setUp(self) In this setUp method, we create a test client. This test client can make calls directly to the app without launching the test server as we did in the last section. test_hello_flask() This method is only slightly different. Instead of making the request to the app via requests to the test server, this makes a GET request to the test_client. The major difference that is worth noticing is that the data property of the response is a byte-string so we need to compare 'Hello Flask!' as a byte-string to the data. Now we can run our tests and see them pass again. Conclusion One last step that we need to do is commit all this work we did. (env) ~/Projects/blog$ git status On branch master Changes not staged for commit: (use \"git add <file>...\" to update what will be committed) (use \"git checkout -- <file>...\" to discard changes in working directory) modified: requirements.txt Untracked files: (use \"git add <file>...\" to include in what will be committed) app.py app/ tests/ no changes added to commit (use \"git add\" and/or \"git commit -a\") (env) ~/Projects/blog$ git add . (env) ~/Projects/blog$ git commit -m \"built hello flask\" [master 5a061ab] built hello flask 5 files changed, 36 insertions(+) create mode 100644 app.py create mode 100644 app/__init__.py create mode 100644 tests/blog_tests.py create mode 100644 tests/blog_web_tests.py (env) user1@Desktop1:~/Projects/blog$ git push origin master Counting objects: 9, done. Delta compression using up to 4 threads. Compressing objects: 100% (7/7), done. Writing objects: 100% (9/9), 1.08 KiB | 553.00 KiB/s, done. Total 9 (delta 0), reused 0 (delta 0) To github.com:dlondonmedina/blog.git c83fa38..5a061ab master -> master At this point we have a very simple application. It returns the string 'Hello Flask!' at one route. However, this is a full web application and we'll be building on this as we work towards a fully functional blog. I'll be showing you how to use both the test_client and requests or selenium to test your application.","title":"8. Smallest App"},{"location":"ch8/#getting-started-with-flask","text":"Ok, so I said in the last chapter that we would begin by writing a Flask web application in 7 lines of code, but that's getting a bit ahead of ourselves. There is some setup that we need to do first. Then we have to write a unittest or two. Then once we get our unittest to fail, we'll build our app and get that unittest to pass. Over the next series of chapters we'll be building a simple blogging platform. To do that, we'll be reusing our code, refactoring, and adding to it as we go. Expect to have to make changes to the code that you've already written.","title":"Getting Started with Flask"},{"location":"ch8/#setup-the-environment","text":"Our first step is to create a directory where all of our code for this project will go. This will be the project root and nothing for this project should exist outside of this directory. To do this enter your terminal, navigate to a convenient location, and create a directory. For me, I have a directory called Projects where I put all of my projects. So I navigate to that directory, create a new one called blog , which is totally arbitrary, and then change directories into that new directory: ~$ cd Projects ~/Projects/$ mkdir blog && cd blog ~/Projects/blog$ Next, I want to set up a virtual environment and version control. If you've never used git before for version control, I recommend this tutorial: git tutorial . Likewise, if you want to be able to share your code using Github, you can add a remote repository that you can push your changes to. I'll be doing both. I like to do this before I set up the virtual environment because I'm going to tell git to ignore all of the virtual environment files. I'll show you all of the steps first, and then I'll explain each of them. ~/Projects/blog$ git init Initialized empty Git repository in /home/user1/Projects/blog/.git/ ~/Projects/blog$ git remote add origin git@github.com:dlondonmedina/blog.git ~/Projects/blog$ touch .gitignore ~/Projects/blog$ python3 -m venv env ~/Projects/blog$ source env/bin/activate (env) ~/Projects/blog$ pip install flask Collecting flask Downloading https://files.pythonhosted.org/packages/f2/28/2a03252dfb9ebf377f40fba6a7841b47083260bf8bd8e737b0c6952df83f/Flask-1.1.2-py2.py3-none-any.whl (94kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 102kB 1.3MB/s Collecting click>=5.1 (from flask) Downloading https://files.pythonhosted.org/packages/dd/c0/4d8f43a9b16e289f36478422031b8a63b54b6ac3b1ba605d602f10dd54d6/click-7.1.1-py2.py3-none-any.whl (82kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 92kB 2.9MB/s Collecting Werkzeug>=0.15 (from flask) Downloading https://files.pythonhosted.org/packages/cc/94/5f7079a0e00bd6863ef8f1da638721e9da21e5bacee597595b318f71d62e/Werkzeug-1.0.1-py2.py3-none-any.whl (298kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 307kB 3.3MB/s Collecting itsdangerous>=0.24 (from flask) Using cached https://files.pythonhosted.org/packages/76/ae/44b03b253d6fade317f32c24d100b3b35c2239807046a4c953c7b89fa49e/itsdangerous-1.1.0-py2.py3-none-any.whl Collecting Jinja2>=2.10.1 (from flask) Downloading https://files.pythonhosted.org/packages/30/9e/f663a2aa66a09d838042ae1a2c5659828bb9b41ea3a6efa20a20fd92b121/Jinja2-2.11.2-py2.py3-none-any.whl (125kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 133kB 1.6MB/s Collecting MarkupSafe>=0.23 (from Jinja2>=2.10.1->flask) Using cached https://files.pythonhosted.org/packages/b2/5f/23e0023be6bb885d00ffbefad2942bc51a620328ee910f64abe5a8d18dd1/MarkupSafe-1.1.1-cp36-cp36m-manylinux1_x86_64.whl Installing collected packages: click, Werkzeug, itsdangerous, MarkupSafe, Jinja2, flask Successfully installed Jinja2-2.11.2 MarkupSafe-1.1.1 Werkzeug-1.0.1 click-7.1.1 flask-1.1.2 itsdangerous-1.1.0 (env) ~/Projects/blog$ pip freeze > requirements.txt (env) ~/Projects/blog$ ls env requirements.txt git init This initializes the directory as a git repository. This means that I can use git to track the changes made to this directory. What happens is git creates \"snapshots\" of the directory and each time we commit a new \"snapshot\" of the changes from the previous version is saved. If we want to rollback changes, then all that has to happen is for git to restore to the previous snapshot. git remote add origin ... This links my local repository created in the previous line to a remote repository on Github that I already created. It is an empty repository online, so I just need to add the remote link. You'll notice I'm using ssh instead of https. When I want to copy my local repository to my remote repository, I'll use the git push command. touch .gitignore I create a .gitignore file. This tells git that some files should be ignored from the version tracking. I'll add content that next and then I'll commit my changes and push to github. python3 -m venv env This uses the venv module, which is part of Python, to create a virtual environment in a directory called env If you only have Python 3 installed and not Python 2, then your command might be different. On Unix (OSX, Linux) based operating systems you'll probably have Python 2 installed by default. source env/bin/activate This activates the virtual environment. The command is different if you are on Windows ( env\\Scripts\\activate without source ). pip install flask This installs Flask in this virtual environment. If you read the output of this command you'll see that flask, click, Werkzeug, itsdangerous, Jinja2, and MarkupSafe are all also installed. These are the dependencies that flask requires. Since we activated the virutal environment in the last step, Flask is only installed to this environment and not globally. pip freeze > requirements.txt This tells pip to write the list of dependencies that we've installed in this virtual environment to a file called requirements.txt. This will make it easy to reinstall our application elsewhere and make sure our requirements are all correct. Finally, I'm listing out the content of my blog directory. Now we need to get our .gitignore in working order. If you create your repository on Github first and then clone it from there. You can have Github initialize the repository with a README, a License, and a .gitignore files. This is convenient, but I chose not to do that here. So, I need to create the gitignore file. I like to copy the one that Github uses, so I just visit: Github Python.gitignore and copy it into my .gitignore file. .gitignore # Byte-compiled / optimized / DLL files __pycache__/ *.py[cod] *$py.class # C extensions *.so # Distribution / packaging .Python build/ develop-eggs/ dist/ downloads/ eggs/ .eggs/ lib/ lib64/ parts/ sdist/ var/ wheels/ share/python-wheels/ *.egg-info/ .installed.cfg *.egg MANIFEST # PyInstaller # Usually these files are written by a python script from a template # before PyInstaller builds the exe, so as to inject date/other infos into it. *.manifest *.spec # Installer logs pip-log.txt pip-delete-this-directory.txt # Unit test / coverage reports htmlcov/ .tox/ .nox/ .coverage .coverage.* .cache nosetests.xml coverage.xml *.cover *.py,cover .hypothesis/ .pytest_cache/ cover/ # Translations *.mo *.pot # Django stuff: *.log local_settings.py db.sqlite3 db.sqlite3-journal # Flask stuff: instance/ .webassets-cache # Scrapy stuff: .scrapy # Sphinx documentation docs/_build/ # PyBuilder .pybuilder/ target/ # Jupyter Notebook .ipynb_checkpoints # IPython profile_default/ ipython_config.py # pyenv # For a library or package, you might want to ignore these files since the code is # intended to run in multiple environments; otherwise, check them in: # .python-version # pipenv # According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control. # However, in case of collaboration, if having platform-specific dependencies or dependencies # having no cross-platform support, pipenv may install dependencies that don't work, or not # install all needed dependencies. #Pipfile.lock # PEP 582; used by e.g. github.com/David-OConnor/pyflow __pypackages__/ # Celery stuff celerybeat-schedule celerybeat.pid # SageMath parsed files *.sage.py # Environments .env .venv env/ venv/ ENV/ env.bak/ venv.bak/ # Spyder project settings .spyderproject .spyproject # Rope project settings .ropeproject # mkdocs documentation /site # mypy .mypy_cache/ .dmypy.json dmypy.json # Pyre type checker .pyre/ # pytype static type analyzer .pytype/ # Cython debug symbols cython_debug/ I might go through and remove all of the lines that I know I won't use, but for now, this works. For instance, I know that my virtual environment directory is called env/ , so I could remove all of the other ones in the .gitignore. Now I'm almost done. I've created my environment, I just need to commit it to git and push it to Github. This is pretty simple: (env) ~/Projects/blog$ git status On branch master No commits yet Untracked files: (use \"git add <file>...\" to include in what will be committed) .gitignore requirements.txt nothing added to commit but untracked files present (use \"git add\" to track) (env) ~/Projects/blog$ git add . (env) ~/Projects/blog$ git commit -m \"initial commit\" [master (root-commit) c83fa38] initial commit 2 files changed, 146 insertions(+) create mode 100644 .gitignore create mode 100644 requirements.txt (env) ~/Projects/blog$ git push origin master Counting objects: 4, done. Delta compression using up to 4 threads. Compressing objects: 100% (4/4), done. Writing objects: 100% (4/4), 1.40 KiB | 1.40 MiB/s, done. Total 4 (delta 0), reused 0 (delta 0) To github.com:dlondonmedina/blog.git * [new branch] master -> master (env) ~/Projects/blog$ git status This tells me what the status is of my git repositiory. You'll see that .gitignore and requirements.txt are not being tracked yet. I like to check this before I commit because sometimes I am not paying perfect attention to all the changes I've made. git add . This adds all of the untracked files and changes to git tracking. This can be undone at this point. You can also specify which files to track by replacing the dot with the file name. git commit -m \"initial commit\" This line commits the changes I just made to the git repository. In other words, it makes a \"snapshot\" of the repository in this current condition. The \"initial commit\" part is an arbitrary message. It should say briefly what the commit changed. I'm a fan of many smaller commits, so these messages should be short. You'll see as we go. git push origin master This finally pushes the changes we made to our local repository up to our remote repository. It says literally, git, please push the changes made on the master branch to the origin (you'll notice we added the remote as origin in the previous series of commands). Okay. Our environment is set up. Now we're ready to turn to our tests.","title":"Setup the Environment"},{"location":"ch8/#building-our-tests-and-app","text":"Flask is a web application microframework, so what we'll be testing is the features we've built with Flask. Unlike the functions we've tested so far, we'll be testing an application designed to receive its input from clients on the internet. This means we need to think about how our tests are going to access our application. We have two ways to do this: we could run our web application and then have our tests make requests to the test server that runs the web application, or we can use the built in test client and make our requests through the test client. I'm going to walk through both approaches. For the former, we'll be using the requests library, but in the future, we'll be using selenium to simulate requests made by a web browser. More about that in the next chapter. Our first step is to set up our test directory and our app directory. These will keep our application and our tests contained. Both of these directories should be children of blog/ and siblings of env . We're also going to create a few files to get set up. I've included the output from ls to show you what is in each directory. (env) ~/Projects/blog$ mkdir app tests (env) ~/Projects/blog$ touch app.py app/__init__.py (env) ~/Projects/blog$ touch tests/blog_tests.py tests/blog_web_tests.py (env) ~/Projects/blog$ ls app app.py env __pycache__ requirements.txt tests (env) ~/Projects/blog$ ls app __init__.py (env) ~/Projects/blog$ ls tests blog_tests.py blog_web_tests.py Now we're going to get our first test setup. The basic Flask application listens at various different routes. If you recall from the chapters on the Internet, when we navigate the web, we visit URLs. A URL includes the domain and subdomain, followed by any parameters that are sent to the server. So, https://example.com/index.html is a resource at example.com and the specific name of the resource is index.html, which is an html file that the server should be able to return. Web servers are usually setup to serve index.html or index.js or index.php, etc. by default, so a request to https://example.com by default should return index.html. With web frameworks, our servers, however, are not serving up static html files. Instead, they are building the html dynamically. So, https://example.com/posts would make a call to the server listening at the address identified by example.com, and it would call the posts method or route. I'd assume based on the name that the posts method would return a web page containing a list of the current posts. We'll discuss this in depth in the next few chapters, but for now, know that our Flask app has specific routes or methods that are registered and will respond if they are called. This will become more apparent as we start. For now, though, lets set up our first tests.","title":"Building our tests and app"},{"location":"ch8/#using-requests","text":"I'm going to start by writing the tests that would simulate a user making a request across a network. Then I'll create the test that uses the built-in test_client() feature of Flask. To simulate the requests, I'll use the requests library. To do that I install the library. (env) ~/Projects/blog$ pip install requests and then fix my dependencies with this command (env) ~/Projects/blog$ pip freeze > requirements.txt Now I need to consider what I'm going to test. The easiest way would be to see if the application returns a particular text value. I also need to know what URL the test server uses to host Flask. It happens to be http://127.0.0.1:5000. With that in mind, let's set up our test. blog_web_tests.py import unittest import requests class TestBlog(unittest.TestCase): def setUp(self): self.url = 'http://127.0.0.1:5000/' def test_hello_flask(self): resp = requests.get(self.url) self.assertEquals('Hello Flask!', resp.text) First, I import the two modules--unittest and requests--and then as we've been doing we set up our test class. setUp(self) This method is called automatically by the test runner and it sets a class property called url to the string of the IP address that the Flask test server will be listening at. test_hello_flask(self) This test first uses requests to call the Flask server. It then tests that the server responded with the string 'Hello Flask!'. This is an arbitrary string that I will use when I build the app. Run our tests and let's see where we're at. There will be many errors, so I'm removing the traceback for efficiency sake. ~/Projects/blog$ python -m unittest tests/blog_web_tests.py E ====================================================================== ERROR: test_hello_flask (tests.blog_web_tests.TestBlog) ---------------------------------------------------------------------- Traceback (most recent call last): ... [Removed for brevity] ... ConnectionRefusedError: [Errno 111] Connection refused ---------------------------------------------------------------------- Ran 1 test in 0.033s FAILED (errors=1) The ConnectionRefusedError suggests that when requests tried to make a request to the url, the server at the URL refused it. This makes sense because I don't have an app yet. So let me get some things set up so that at least there's an app. app.py from app import app This is a simple script that initializes our instance of Flask. It will try to import from our app directory, which will automatically run __init__.py.py in that directory, which will contain our Flask application code. So let's go there next. __init__.py from flask import Flask app = Flask(__name__) @app.route('/') def hello_flask(): return '' from flask import Flask We're importing the Flask class which contains our basic web microframework object. app = Flask(__name__) This line instantiates Flask as a variable named \"app.\" If you remember from app.py, the app here is the one that is imported in app.py. @app.route('/') is a decorator that passes the following function to the route() method. Next chapter we will discuss this in depth. For now, think of this as the way hello_flask() is called when a user requests the route. I'm not quite ready to run my tests yet. If I were to do so, I would get the same errors because my Flask app isn't running yet. To do this, I need to launch the Flask app and then run my tests. (env) ~/Projects/blog$ export FLASK_APP=app.py (env) ~/Projects/blog$ python -m flask run * Serving Flask app \"app.py\" * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Debug mode: off * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) export FLASK_APP=app.py This line creates an environmental variable called FLASK_APP. When we call flask run on the next line, the program looks for this variable and then runs the assigned script (app.py). In the following output, we can see some information about the server running our Flask app. Don't worry about the WARNING for now, but the key is to not set up flask on a live web server using this method. Now we open a second terminal, launch our virtual environment, and run our tests again. (env) ~/Projects/blog$ python -m unittest tests/blog_web_tests.py F ====================================================================== FAIL: test_hello_flask (tests.blog_web_tests.TestBlog) ---------------------------------------------------------------------- Traceback (most recent call last): File \"blog/tests/blog_web_tests.py\", line 11, in test_hello_flask self.assertIn('Hello Flask!', resp.text) AssertionError: 'Hello Flask!' not found in '' ---------------------------------------------------------------------- Ran 1 test in 0.005s FAILED (failures=1) This is the kind of failure we're looking for. We'll notice that our flask app is returning an empty string. All we need to do now is change that return and run our tests again. __init__.py from flask import Flask app = Flask(__name__) @app.route('/') def hello_flask(): return 'Hello Flask!' and it fails again. We need to relaunch our flask app. To do this, open the terminal that is running our flask app, and use CTRL+C to stop the process. Then type python -m flask run again and our tests pass: (env) ~/Projects/blog$ python -m unittest tests/blog_web_tests.py. ---------------------------------------------------------------------- Ran 1 test in 0.006s OK","title":"Using Requests"},{"location":"ch8/#using-test-client","text":"Now, I'm going to build tests using the test_client(). I won't rewrite the Flask app, so I'll just show you the new tests. My first step is to shut down the test server I launched in the last section. Just as the test server ran our Flask app, the test_client gives us access to make calls to our app directly without launching a test server. blog_tests.py import unittest from app import app class TestBlog(unittest.TestCase): def setUp(self): self.client = app.test_client() def test_hello_flask(self): resp = self.client.get('/') self.assertEqual(b'Hello Flask!', resp.data) def setUp(self) In this setUp method, we create a test client. This test client can make calls directly to the app without launching the test server as we did in the last section. test_hello_flask() This method is only slightly different. Instead of making the request to the app via requests to the test server, this makes a GET request to the test_client. The major difference that is worth noticing is that the data property of the response is a byte-string so we need to compare 'Hello Flask!' as a byte-string to the data. Now we can run our tests and see them pass again.","title":"Using Test Client"},{"location":"ch8/#conclusion","text":"One last step that we need to do is commit all this work we did. (env) ~/Projects/blog$ git status On branch master Changes not staged for commit: (use \"git add <file>...\" to update what will be committed) (use \"git checkout -- <file>...\" to discard changes in working directory) modified: requirements.txt Untracked files: (use \"git add <file>...\" to include in what will be committed) app.py app/ tests/ no changes added to commit (use \"git add\" and/or \"git commit -a\") (env) ~/Projects/blog$ git add . (env) ~/Projects/blog$ git commit -m \"built hello flask\" [master 5a061ab] built hello flask 5 files changed, 36 insertions(+) create mode 100644 app.py create mode 100644 app/__init__.py create mode 100644 tests/blog_tests.py create mode 100644 tests/blog_web_tests.py (env) user1@Desktop1:~/Projects/blog$ git push origin master Counting objects: 9, done. Delta compression using up to 4 threads. Compressing objects: 100% (7/7), done. Writing objects: 100% (9/9), 1.08 KiB | 553.00 KiB/s, done. Total 9 (delta 0), reused 0 (delta 0) To github.com:dlondonmedina/blog.git c83fa38..5a061ab master -> master At this point we have a very simple application. It returns the string 'Hello Flask!' at one route. However, this is a full web application and we'll be building on this as we work towards a fully functional blog. I'll be showing you how to use both the test_client and requests or selenium to test your application.","title":"Conclusion"},{"location":"ch9/","text":"Web Application Anatomy At the end of Chapter 8, you should have an extremely basic web application built in Flask. That said, your application does the functions necessary for any web application: it listens for requests, if the requests are valid, it returns a reliable kind of data. That said, the web apps that you see online seem to do so much more. This chapter looks a little bit at the anatomy of web applications so that we understand what's going on when we move into Flask Templates in the next chapter. Anatomy of a Web Application Web applications have two main components. They have the backend, which is a program or set of programs that run on a server someplace. They also have a frontend that runs in the client (e.g. the user's web browser). The backend of a web application deals with databases, processing, listening for requests, and assembling data that will be sent to the frontend. Also, it might collect the HTML/CSS and JavaScript that is sent to the client. The frontend of the application is the code that is run by the web browser or is the app that the user interacts with on their device. You might think of the frontend as the user interface and the backend is the business logic. Let's begin by thinking about a simple, static website. By static, I mean the content that is displayed to the user is hardcoded into HTML/CSS and Javascript files. The server is a web server, possibly Apache or NGINX or even Github Pages. The server listens for requests (probably just GET requests because it is static) that have addresses like: https://example.github.io/about.html This would tell the server to look for an HTML file called about.html. If that file is present, the server sends that file back to the client. The backend is the server that listens for and then sends the appropriate resources, in this case an HTML file back to the client. The frontend component is the HTML page and any CSS and Javascript that is interpreted by the web browser into the lovely page you see. Many sites on the internet do a bit more than send static HTML files in part because we want the sites to be dynamic and flexible. Most backend components now do not serve up static HTML files, but rather generate HTML in real time based on the parameters of our request. For instance, in our example from last chapter, our Flask app sent out the string 'Hello Flask!' if a request was sent to the domain name without any parameters. Generally backends will either create the HTML/CSS and Javascript to be sent to the client, which makes the frontend and backend tightly coupled, or they create a data object, perhaps JSON, which can be sent to either a web frontend or a mobile app. The latter are loosely coupled because the frontend is separate from the backend and they communicate through a set of protocols and established paths. This pattern is similar to most APIs. As you might suspect, frontends are either code that can be read by the web browser or a mobile application. They are the user interface that displays content to the user and collects input from the user. HTML/CSS and Javascript are frontend technologies (though we can write Javascript for the backend, too). These programming languages are designed to be interpreted by a web browser, and they contain the content, display rules, and actions that the web app wants to provide to the user. The same content, display rules, and actions can be developed into a mobile app as well. In either case, these allow the user to send and receive requests from the backend in predictable and stylized ways. We're going to be doing very little with frontends in this book, but since Flask does come with a way to develop frontends, we will learn a bit. To do so, we're going to digress into HTML. A short introduction to HTML HTML, or HyperText Markup Language, is not really a programming language, but rather a way of tagging text so that it can be displayed in an attractive fashion by a web browser (Firefox, Chrome, Edge, Safari, Opera, etc...). A fun experiment to see HTML in action is to visit your favorite website and inspect the source code (Right Click -> View Page Source in most browsers). This will reveal what is sent from the server to your web browser. HTML is simply a long string that is sent by the server and interpreted by your browser. That string is almost always encoded in UTF-8, which is a way of converting characters into 4-8 bit units (bytes or octets), which is the binary data that actually travels across the network. You don't need to worry about the encoding, just about the strings that are being sent from your server to the user using your app. The best way to start thinking about HTML is to imagine a Word document. In that word document, you might have a single word that is in bold font. How does Word know that that single word should be bolded? Well, because behind the scenes, there are tags surrounding that word that indicate that it should be bold. Something like this: This is a bold word. Of course, we don't see all of these tags because it would make it tricky to deal with our word documents. Instead, the User Interface renders the text as we would expect to see it. The tags tell the User Interface how the thing they surround should be displayed. HTML is exactly the same. We have our main text of our website. That text is \"marked up\" or sections of it are surrounded by tags that tell the browser how that bit of text should be displayed. Basic Anatomy The basic anatomy of HTML includes an opening tag and a closing tag. Let's take this one: <p> This is an opening tag that marks the beginning of a paragraph. This paragraph that you are reading now is started by this tag. When the paragraph ends, there is a closing tag that looks like this: </p> This tag marks the ending of a paragraph. Everything between the matching opening and closing tags will be part of the same paragraph and most browsers display a paragraph as a block of text with hard breaks on either side. You'll notice a couple things: first, the human readable characters inside of the greater than and less than signs are intuitive and matching. \"p\" stands for paragraph. If I want to make something bold, I'd use the tags <strong> and </strong> where \"strong\" means the font should be strong, or bold. The web browser reads this tag-pair and displays the text between them in a bold font. The second thing to notice is that the closing tag is the same as the opening tag except it has a \"/\" character inside it. This is required and almost all tags have an opening and closing tag. In addition to the opening and closing tags, the opening tag may contain some additional information. For instance, let's look at a link: <a href=\"www.google.com\">This text between these \"a\" tags will be a link to www.google.com</a> 'href=\"...\"' means hyperlink reference. The \"a\" tag is an anchor tag that anchors a bit of text to some other site. In other words, the \"a\" tag creates a link to some other location. The extra parameter associated with the \"a\" tag is \"href\" and that tells the browser where this link should go. By default, most web browsers display a link as blue, underlined text. You will also see styles, classes, and id's being added to various elements in HTML. These are used to tell the browser what special styling (or font/color/positioning) should be added to the content between the tags. Classes are used to identify a group of elements which will all receive the same styling. Ids are used to identify a particular tag (this paragraph). As you go through the lessons for this week, pay attention to the various tags and parameters that are added to those tags. There won't be a test, and there are plenty of cheat sheets online to help you. Types of tags Block level elements Block level elements are HTML tags that define blocks of text. These are usually displayed starting on new lines. Paragraphs are an example of a block level element. These elements are used to do the major positioning of the text on the page. For instance, all of the headings on this page are wrapped with some sort of heading tag. These are block level elements and they create a line break before and after the surrounded text. This is important to remember because even if you have line breaks in your HTML document, the only way for the browser to know that the line should be broken is with some sort of block element. So if you were to look at the source of this paragraph, you'd see that right now I have six line breaks, but none of those are displayed in the browser because they are within a single paragraph block and I don't have any tags to tell the browser to put in line breaks. This is the hardest thing to get with block elements. If you want a line break, you need to tell the browser either with the <br> tag, which tells the browser to put in a line break here, or by surrounding your text with block level tags. Inline Tags The other kind of tags are \"inline tags.\" These tags do not tell the browser to create line breaks or a block, but rather effect the styling of a particular bit of text. Links, as you saw above, are inline elements. They tell the browser to put a hyperlink on a particular span of text, but they don't break the line. Strong tags are also inline tags. The more tricky ones are the <button> tag, which turns the surrounded text into a button, like so: HI or image tags, which drop an image into the document. Inline style tags are less frequently used in contemporary web development, I think, because we can do much more effective styling with CSS and block elements. Basic Layout of HTML document An html document is a file with the .html extension. In general, it's layout is like this: <!DOCTYPE html> <html lang=\"en\"> <head> <title>Document</title> </head> <body> The body of your webpage goes here. </body> </html> Everything in between the head tags is not displayed except for the title. That is displayed on the browser tab. The title of this page is \"Everyday Coding -- HTML\". Everything between the body tags makes up the body of the page that you see in the window. Generally, css, links, and javascript is put into the head of the document and the content you want the user to see, of course, must go in the body section. Older HTML pages might have additional information in the first line, but this sample is the convention for HTML5. Differences Between Browsers One note that's pretty important in thinking about HTML: each browser renders HTML in a slightly different manner, so it's important to test your markup in the major browsers and on various devices. We're not going into design or the complexity of front end development in this class, as that would be the topic of an entire program (WATS). If you are excited about that sort of thing, the sky's the limit, so to speak, and it's a rapidly growing and changing field.","title":"9. Intro to HTML"},{"location":"ch9/#web-application-anatomy","text":"At the end of Chapter 8, you should have an extremely basic web application built in Flask. That said, your application does the functions necessary for any web application: it listens for requests, if the requests are valid, it returns a reliable kind of data. That said, the web apps that you see online seem to do so much more. This chapter looks a little bit at the anatomy of web applications so that we understand what's going on when we move into Flask Templates in the next chapter.","title":"Web Application Anatomy"},{"location":"ch9/#anatomy-of-a-web-application","text":"Web applications have two main components. They have the backend, which is a program or set of programs that run on a server someplace. They also have a frontend that runs in the client (e.g. the user's web browser). The backend of a web application deals with databases, processing, listening for requests, and assembling data that will be sent to the frontend. Also, it might collect the HTML/CSS and JavaScript that is sent to the client. The frontend of the application is the code that is run by the web browser or is the app that the user interacts with on their device. You might think of the frontend as the user interface and the backend is the business logic. Let's begin by thinking about a simple, static website. By static, I mean the content that is displayed to the user is hardcoded into HTML/CSS and Javascript files. The server is a web server, possibly Apache or NGINX or even Github Pages. The server listens for requests (probably just GET requests because it is static) that have addresses like: https://example.github.io/about.html This would tell the server to look for an HTML file called about.html. If that file is present, the server sends that file back to the client. The backend is the server that listens for and then sends the appropriate resources, in this case an HTML file back to the client. The frontend component is the HTML page and any CSS and Javascript that is interpreted by the web browser into the lovely page you see. Many sites on the internet do a bit more than send static HTML files in part because we want the sites to be dynamic and flexible. Most backend components now do not serve up static HTML files, but rather generate HTML in real time based on the parameters of our request. For instance, in our example from last chapter, our Flask app sent out the string 'Hello Flask!' if a request was sent to the domain name without any parameters. Generally backends will either create the HTML/CSS and Javascript to be sent to the client, which makes the frontend and backend tightly coupled, or they create a data object, perhaps JSON, which can be sent to either a web frontend or a mobile app. The latter are loosely coupled because the frontend is separate from the backend and they communicate through a set of protocols and established paths. This pattern is similar to most APIs. As you might suspect, frontends are either code that can be read by the web browser or a mobile application. They are the user interface that displays content to the user and collects input from the user. HTML/CSS and Javascript are frontend technologies (though we can write Javascript for the backend, too). These programming languages are designed to be interpreted by a web browser, and they contain the content, display rules, and actions that the web app wants to provide to the user. The same content, display rules, and actions can be developed into a mobile app as well. In either case, these allow the user to send and receive requests from the backend in predictable and stylized ways. We're going to be doing very little with frontends in this book, but since Flask does come with a way to develop frontends, we will learn a bit. To do so, we're going to digress into HTML.","title":"Anatomy of a Web Application"},{"location":"ch9/#a-short-introduction-to-html","text":"HTML, or HyperText Markup Language, is not really a programming language, but rather a way of tagging text so that it can be displayed in an attractive fashion by a web browser (Firefox, Chrome, Edge, Safari, Opera, etc...). A fun experiment to see HTML in action is to visit your favorite website and inspect the source code (Right Click -> View Page Source in most browsers). This will reveal what is sent from the server to your web browser. HTML is simply a long string that is sent by the server and interpreted by your browser. That string is almost always encoded in UTF-8, which is a way of converting characters into 4-8 bit units (bytes or octets), which is the binary data that actually travels across the network. You don't need to worry about the encoding, just about the strings that are being sent from your server to the user using your app. The best way to start thinking about HTML is to imagine a Word document. In that word document, you might have a single word that is in bold font. How does Word know that that single word should be bolded? Well, because behind the scenes, there are tags surrounding that word that indicate that it should be bold. Something like this: This is a bold word. Of course, we don't see all of these tags because it would make it tricky to deal with our word documents. Instead, the User Interface renders the text as we would expect to see it. The tags tell the User Interface how the thing they surround should be displayed. HTML is exactly the same. We have our main text of our website. That text is \"marked up\" or sections of it are surrounded by tags that tell the browser how that bit of text should be displayed. Basic Anatomy The basic anatomy of HTML includes an opening tag and a closing tag. Let's take this one: <p> This is an opening tag that marks the beginning of a paragraph. This paragraph that you are reading now is started by this tag. When the paragraph ends, there is a closing tag that looks like this: </p> This tag marks the ending of a paragraph. Everything between the matching opening and closing tags will be part of the same paragraph and most browsers display a paragraph as a block of text with hard breaks on either side. You'll notice a couple things: first, the human readable characters inside of the greater than and less than signs are intuitive and matching. \"p\" stands for paragraph. If I want to make something bold, I'd use the tags <strong> and </strong> where \"strong\" means the font should be strong, or bold. The web browser reads this tag-pair and displays the text between them in a bold font. The second thing to notice is that the closing tag is the same as the opening tag except it has a \"/\" character inside it. This is required and almost all tags have an opening and closing tag. In addition to the opening and closing tags, the opening tag may contain some additional information. For instance, let's look at a link: <a href=\"www.google.com\">This text between these \"a\" tags will be a link to www.google.com</a> 'href=\"...\"' means hyperlink reference. The \"a\" tag is an anchor tag that anchors a bit of text to some other site. In other words, the \"a\" tag creates a link to some other location. The extra parameter associated with the \"a\" tag is \"href\" and that tells the browser where this link should go. By default, most web browsers display a link as blue, underlined text. You will also see styles, classes, and id's being added to various elements in HTML. These are used to tell the browser what special styling (or font/color/positioning) should be added to the content between the tags. Classes are used to identify a group of elements which will all receive the same styling. Ids are used to identify a particular tag (this paragraph). As you go through the lessons for this week, pay attention to the various tags and parameters that are added to those tags. There won't be a test, and there are plenty of cheat sheets online to help you. Types of tags Block level elements Block level elements are HTML tags that define blocks of text. These are usually displayed starting on new lines. Paragraphs are an example of a block level element. These elements are used to do the major positioning of the text on the page. For instance, all of the headings on this page are wrapped with some sort of heading tag. These are block level elements and they create a line break before and after the surrounded text. This is important to remember because even if you have line breaks in your HTML document, the only way for the browser to know that the line should be broken is with some sort of block element. So if you were to look at the source of this paragraph, you'd see that right now I have six line breaks, but none of those are displayed in the browser because they are within a single paragraph block and I don't have any tags to tell the browser to put in line breaks. This is the hardest thing to get with block elements. If you want a line break, you need to tell the browser either with the <br> tag, which tells the browser to put in a line break here, or by surrounding your text with block level tags. Inline Tags The other kind of tags are \"inline tags.\" These tags do not tell the browser to create line breaks or a block, but rather effect the styling of a particular bit of text. Links, as you saw above, are inline elements. They tell the browser to put a hyperlink on a particular span of text, but they don't break the line. Strong tags are also inline tags. The more tricky ones are the <button> tag, which turns the surrounded text into a button, like so: HI or image tags, which drop an image into the document. Inline style tags are less frequently used in contemporary web development, I think, because we can do much more effective styling with CSS and block elements. Basic Layout of HTML document An html document is a file with the .html extension. In general, it's layout is like this: <!DOCTYPE html> <html lang=\"en\"> <head> <title>Document</title> </head> <body> The body of your webpage goes here. </body> </html> Everything in between the head tags is not displayed except for the title. That is displayed on the browser tab. The title of this page is \"Everyday Coding -- HTML\". Everything between the body tags makes up the body of the page that you see in the window. Generally, css, links, and javascript is put into the head of the document and the content you want the user to see, of course, must go in the body section. Older HTML pages might have additional information in the first line, but this sample is the convention for HTML5.","title":"A short introduction to HTML"},{"location":"ch9/#differences-between-browsers","text":"One note that's pretty important in thinking about HTML: each browser renders HTML in a slightly different manner, so it's important to test your markup in the major browsers and on various devices. We're not going into design or the complexity of front end development in this class, as that would be the topic of an entire program (WATS). If you are excited about that sort of thing, the sky's the limit, so to speak, and it's a rapidly growing and changing field.","title":"Differences Between Browsers"},{"location":"chx/","text":"Getting Flask Set Up and Your First Functional Test The first functional test checks three things: Is the selenium library installed and can we import webdriver Is there a server serving listening and responding at localhost on port 5000 This is different from the Django. Is that server responding with the page_source attribute set to \"Flask\" Here is the code: from selenium import webdriver browser = webdriver.Firefox() browser.get('http://localhost:5000') assert 'Flask' in browser.page_source functional_tests.py As I follow along with this, I get this error: $ python functional_tests.py Traceback (most recent call last): File \"functional_tests.py\", line 1, in <module> from selenium import webdriver ModuleNotFoundError: No module named 'selenium' Notice that the test failed, but not in the way we expected. Should I have written a separate test that selenium was installed? I could have, but since Python throws an import error anyway, it's not that big of a problem to not have a separate test for it. If you're getting this error as well, then the following should fix things up: (env) $ pip install selenium After Selenium is installed, then you should get the expected error message. We should expect a connection error because we haven't set up Flask yet, so there's no server listening. Getting Flask Up and Running I know I haven't installed Flask in this virtual environment, yet, so I know I'll need to do that first. Django has a CLI to help you build your core site, but since Flask is a lightweight Framework with few moving parts, we don't get that. At the same time, we have far fewer files to deal with and far fewer moving parts, so it's a toss up. Flask is a great tool for smaller projects. Step One: Install Flask Installing Flask is pretty easy. Using pip package manager we just need to install Flask. Make sure that your virtual environment is activated (env) $ pip install Flask At this point, it would also be valuable to create a requirements.txt file. This file allows you to easily set up your app on a different machine without having to move all of the dependencies. You will be using the \"freeze\" command that is build into pip. This command echos the list of dependencies that have been installed in this virtual environment using pip install. Try it out in the terminal and you'll see something like this: (env) $ pip freeze Click==7.0 Flask==1.1.1 itsdangerous==1.1.0 Jinja2==2.11.1 MarkupSafe==1.1.1 selenium==3.141.0 urllib3==1.25.8 Werkzeug==1.0.0 When I installed Flask, I also installed its dependencies (Click, itsdangerous, Jinja2, urllib3, werkzeug). You don't need to do this every time, this was just to show you how pip freeze works. Now you'll need to somehow write the output of pip freeze into a text file called requirements.txt You could copy and past from the terminal, but that's too much work. Instead, you can use the > or >> symbol to write the output of a command directly to a file like so: (env) $ pip freeze > requirements.txt If I use the > symbol, it will either create or overwrite the file to the right of the symbol. NOTICE: if you overwrite data will be lost This is the correct choice in this case because each time we update our requirements.txt file, we want to overwrite it. If we were appending to a file for some other reason, then we would use >> which either creates or appends to the file to the right of the symbol. Step Two: Set Up Your Directory Understanding where your files live is crucial in programming. If the files are not in the right place or if your directory is misshapen, you'll have lots of problems. Django's CLI tool does much of this for you. In Flask, we're on our own. Right now your folder structure within your flask directory should look like this: |--functional_tests.py |--geckodriver.log |--requirements.txt |--env (Virtual Environment Directory) | |--[...] We need to create a directory and three files. We need to create a directory called \"app\" and a file called superlists.py that are both siblings of functional_tests.py. This means they are direct children of our flask directory. We also need to create two files called __init__.py and routes.py that is a child of the \"app\" directory. Here are the commands in the terminal. (env) $ mkdir app && touch superlists.py app/__init__.py app/routes.py You can also enter them as three separate commands if you wish. If this was successful, your flask directory should look like this: |--functional_tests.py |--geckodriver.log |--requirements.txt |--superlists.py |--app | |--__init__.py | |--routes.py |--env (Virtual Environment Directory) | |--[...] If your directory doesn't look exactly like this then go back and check for mistakes before you move on. Now that those files are all created, you can start coding so that the tests will pass. You will be editing superlists.py, __init__.py and routes.py. The first is the script that launches the Flask application. from app import app superlists.py The second is the core of the app (for now). from flask import Flask app = Flask(__name__) from app import routes __init__.py The third is a file that manages the routes. from app import app @app.route('/') @app.route('/index') def index(): return \"Hello, Flask!\" We'll be discussing all of these later on in great detail. Once you've created all of these files, you'll need to start your Flask app so that you can run your tests again. This will require you to have 2 terminals open. In the first terminal, start the Flask app: (env) $ flask run and in the second terminal (make sure you've navigated to your project directory and activated your virtual environment): (env) $ python functional_tests.py At this point, the functional tests will open a new browser and call the Flask app. As soon as that loads, you can close the browser. In your terminal, you should get no error messages. If that's the case, you've successfully completed this. If not, you'll need to go through and revise your code until it works. Make sure to read any error messages for a clue as to what to fix. Now, you'll want to initialize your flask project directory as a git repository. Create a gitignore file that contains at least the following: # Byte-compiled / optimized / DLL files __pycache__/ # Unit test / coverage reports .pytest_cache/ # Flask stuff: db.sqlite3 db.sqlite3-journal instance/ .webassets-cache # Environments env/ # Visual Studio Code .vscode/ .gitignore Then create a new github repository and push your local repository to github. You're done with getting started!","title":"Getting Flask Set Up and Your First Functional Test"},{"location":"chx/#getting-flask-set-up-and-your-first-functional-test","text":"The first functional test checks three things: Is the selenium library installed and can we import webdriver Is there a server serving listening and responding at localhost on port 5000 This is different from the Django. Is that server responding with the page_source attribute set to \"Flask\" Here is the code: from selenium import webdriver browser = webdriver.Firefox() browser.get('http://localhost:5000') assert 'Flask' in browser.page_source functional_tests.py As I follow along with this, I get this error: $ python functional_tests.py Traceback (most recent call last): File \"functional_tests.py\", line 1, in <module> from selenium import webdriver ModuleNotFoundError: No module named 'selenium' Notice that the test failed, but not in the way we expected. Should I have written a separate test that selenium was installed? I could have, but since Python throws an import error anyway, it's not that big of a problem to not have a separate test for it. If you're getting this error as well, then the following should fix things up: (env) $ pip install selenium After Selenium is installed, then you should get the expected error message. We should expect a connection error because we haven't set up Flask yet, so there's no server listening.","title":"Getting Flask Set Up and Your First Functional Test"},{"location":"chx/#getting-flask-up-and-running","text":"I know I haven't installed Flask in this virtual environment, yet, so I know I'll need to do that first. Django has a CLI to help you build your core site, but since Flask is a lightweight Framework with few moving parts, we don't get that. At the same time, we have far fewer files to deal with and far fewer moving parts, so it's a toss up. Flask is a great tool for smaller projects.","title":"Getting Flask Up and Running"},{"location":"chx/#step-one-install-flask","text":"Installing Flask is pretty easy. Using pip package manager we just need to install Flask. Make sure that your virtual environment is activated (env) $ pip install Flask At this point, it would also be valuable to create a requirements.txt file. This file allows you to easily set up your app on a different machine without having to move all of the dependencies. You will be using the \"freeze\" command that is build into pip. This command echos the list of dependencies that have been installed in this virtual environment using pip install. Try it out in the terminal and you'll see something like this: (env) $ pip freeze Click==7.0 Flask==1.1.1 itsdangerous==1.1.0 Jinja2==2.11.1 MarkupSafe==1.1.1 selenium==3.141.0 urllib3==1.25.8 Werkzeug==1.0.0 When I installed Flask, I also installed its dependencies (Click, itsdangerous, Jinja2, urllib3, werkzeug). You don't need to do this every time, this was just to show you how pip freeze works. Now you'll need to somehow write the output of pip freeze into a text file called requirements.txt You could copy and past from the terminal, but that's too much work. Instead, you can use the > or >> symbol to write the output of a command directly to a file like so: (env) $ pip freeze > requirements.txt If I use the > symbol, it will either create or overwrite the file to the right of the symbol. NOTICE: if you overwrite data will be lost This is the correct choice in this case because each time we update our requirements.txt file, we want to overwrite it. If we were appending to a file for some other reason, then we would use >> which either creates or appends to the file to the right of the symbol.","title":"Step One: Install Flask"},{"location":"chx/#step-two-set-up-your-directory","text":"Understanding where your files live is crucial in programming. If the files are not in the right place or if your directory is misshapen, you'll have lots of problems. Django's CLI tool does much of this for you. In Flask, we're on our own. Right now your folder structure within your flask directory should look like this: |--functional_tests.py |--geckodriver.log |--requirements.txt |--env (Virtual Environment Directory) | |--[...] We need to create a directory and three files. We need to create a directory called \"app\" and a file called superlists.py that are both siblings of functional_tests.py. This means they are direct children of our flask directory. We also need to create two files called __init__.py and routes.py that is a child of the \"app\" directory. Here are the commands in the terminal. (env) $ mkdir app && touch superlists.py app/__init__.py app/routes.py You can also enter them as three separate commands if you wish. If this was successful, your flask directory should look like this: |--functional_tests.py |--geckodriver.log |--requirements.txt |--superlists.py |--app | |--__init__.py | |--routes.py |--env (Virtual Environment Directory) | |--[...] If your directory doesn't look exactly like this then go back and check for mistakes before you move on. Now that those files are all created, you can start coding so that the tests will pass. You will be editing superlists.py, __init__.py and routes.py. The first is the script that launches the Flask application. from app import app superlists.py The second is the core of the app (for now). from flask import Flask app = Flask(__name__) from app import routes __init__.py The third is a file that manages the routes. from app import app @app.route('/') @app.route('/index') def index(): return \"Hello, Flask!\" We'll be discussing all of these later on in great detail. Once you've created all of these files, you'll need to start your Flask app so that you can run your tests again. This will require you to have 2 terminals open. In the first terminal, start the Flask app: (env) $ flask run and in the second terminal (make sure you've navigated to your project directory and activated your virtual environment): (env) $ python functional_tests.py At this point, the functional tests will open a new browser and call the Flask app. As soon as that loads, you can close the browser. In your terminal, you should get no error messages. If that's the case, you've successfully completed this. If not, you'll need to go through and revise your code until it works. Make sure to read any error messages for a clue as to what to fix. Now, you'll want to initialize your flask project directory as a git repository. Create a gitignore file that contains at least the following: # Byte-compiled / optimized / DLL files __pycache__/ # Unit test / coverage reports .pytest_cache/ # Flask stuff: db.sqlite3 db.sqlite3-journal instance/ .webassets-cache # Environments env/ # Visual Studio Code .vscode/ .gitignore Then create a new github repository and push your local repository to github. You're done with getting started!","title":"Step Two: Set Up Your Directory"},{"location":"chy/","text":"Introducing the unittest Module A note to begin: One thing to notice before we go much further is that we have a number of tools running at the same time to do our tests. Our Flask server that is launched when we type flask run in our terminal. This web server runs on your local machine, is not visible to the outside world, and listens at the IP address 127.0.0.1 on port 5000. In the URL bar, this will look like 127.0.0.1:5000 . Our Flask app that the Flask server calls when it receives requests. Our functional_test.py script, which opens a web browser to send particular requests to the Flask server, and evaluates the server's responses. I recommend, perhaps, diagramming these for yourself in some fashion if it helps you keep things in order. Unittests Our last iteration of our app was extremely simple. It didn't even use any HTML and didn't properly return a web-page; just the string \"Hello, Flask!\" That's not particularly useful if we're trying to build a little web-app, but it's a start. Now we're moving on to bigger and better things. You'll actually have a proper webpage. Our first step will be to modify our functional test so that it looks for a title property. We'll alo add the story that Percival mentions So let's go to the functional test: from selenium import webdriver browser = webdriver.Firefox() # Edith (our test) has heard about a cool new online to-do app. She goes # to check out its homepage browser.get('http://127.0.0.1:5000') # or http://localhost:5000 # She notices the page title and header mention to-do lists assert 'To-Do' in browser.title # She is invited to enter a to-do item straight away # She types \"Buy peacock feathers\" into a text box (Edith's hobby # is tying fly-fishing lures) # When she hits enter, the page updates, and now the page lists # \"1: Buy peacock feathers\" as an item in a to-do list # There is still a text box inviting her to add another item. She # enters \"Use peacock feathers to make a fly\" (Edith is very methodical) # The page updates again, and now shows both items on her list # Edith wonders whether the site will remember her list. Then she sees # that the site has generated a unique URL for her -- there is some # explanatory text to that effect. # She visits that URL - her to-do list is still there. # Satisfied, she goes back to sleep browser.quit() functional_tests.py Comments There are lot of opinions when it comes to how we add comments to our code. In a traditional CS program, we'd expect students to write extensive comments. This is to help the instructor see what you believe you are doing with a particular line of code or function. Likewise, the practice of writing such comments is useful for you to become conscious of what your code is doing. Comments can also be used as a sort of pseudocode to describe what functions your code will need to accomplish (as in the above example). In professional settings, there is a debate as to how many comments are necessary. On the one hand, some argue that your code should be clearly written enough that you don't need any comments. If your code needs comments to explain what's going on, you probably have a problem with your code. They also argue that if you change your code in the future without changing your comments, the comments can become misleading and more of a hinderance for future developers. On the other hand, some argue that comments provide crucial insight to you and other developers about what the code is supposed to do. They give future developers a sense of what you were thinking when you were writing the code. They are also important if you are writing an API or other code that future developers will extend. Additionally, comments are frequently used to generate documentation. For instance Sphinx and other documentation generation tools can automatically create docs based on the comments. Beyond all of this, if you're working for a company, that company will likely have its own approach to comments, and probably a majority of your first period there will be reading the code and comments that you will later be working on. This is all to say, you'll have to decide how much you want to comment your code based on the project. A general rule of thumb is that if the code doesn't obviously tell you what is happening, it's worth commenting. For example the first comment is probably not needed, but the second is (I also probably wouldn't write that generator just to save a few lines of code anyway): # Increment age by 1 age += 1 n = int(input(\"How many players? \")) # prompt users for name and age for each player age_map = {input(\"Name?\"): int(input(\"Age?\")) for i in range(n)} Back to our Tests If we start up our Flask server: (env) $ flask run and in another shell run our functional tests, you'll get an error like this: (env) $ python functional_tests.py Traceback (most recent call last): File \"functional_tests.py\", line 6, in <module> assert 'To-Do' in browser.title AssertionError We are getting the error that we are expecting! However, we want to move over to the unittest framework to make our test a little bit more robust. After all, we'll be building an entire testing suite for our application: every operation we want should be tested. This will be very similar to the test in Percival's book, but before that, take a moment to consider the unittest library. unittest The unittest library is a framework for writing unit tests. A unit test is an automated test that checks the functionality of one unit of a particular application. For instance, one unit of our webpage is the title that shows up on the browser tab. A unit test will test that that is as it should be. Likewise, it might test a single function of our application. When writing a unit test, we need to provide all of the conditions or dependencies except the one variable that is being tested. So our browser title test needs to just test that the browser title contains particular content. It shouldn't check that the browser starts up or anything that appears on the page or that the URL is correct. A functional test is a test that checks a particular functionality of our application. For instance, a functional test might check that we can input a new item into a list and when we do so the item gets added to the database. Unlike a unit test that might have distinct tests for user input and writing to the database, the functional test tries to see that the components work together properly. Another way to think of this: unit tests check a discrete section of code. Functional tests simulate user experience. So, now lets update our functional_tests.py file. You'll notice that this is a functional test because it tests a component of our application as a user would encounter it. We'll write unittests later. from selenium import webdriver import unittest class NewVisitorTest(unittest.TestCase): def setUp(self): self.browser = webdriver.Firefox() def tearDown(self): self.browser.quit() def test_can_start_a_list_and_retrieve_it_later(self): # Call homepage self.browser.get('http://127.0.0.1:5000') # Old way: # assert 'To-Do' in browser.title # Using unittest methods self.assertIn('To-Do', self.browser.title) self.fail('Finish writing the test!') # She is invited to enter a to-do item straight away # She types \"Buy peacock feathers\" into a text box (Edith's hobby # is tying fly-fishing lures) # When she hits enter, the page updates, and now the page lists # \"1: Buy peacock feathers\" as an item in a to-do list # There is still a text box inviting her to add another item. She # enters \"Use peacock feathers to make a fly\" (Edith is very methodical) # The page updates again, and now shows both items on her list # Edith wonders whether the site will remember her list. Then she sees # that the site has generated a unique URL for her -- there is some # explanatory text to that effect. # She visits that URL - her to-do list is still there. # Satisfied, she goes back to sleep if __name__ in '__main__': unittest.main(warnings='ignore') Once again, we want to test it. If you stopped your Flask server, launch it again. Then let's run our functional tests and see the results: (env) $ python functional_tests.py F ====================================================================== FAIL: test_can_start_a_list_and_retrieve_it_later (__main__.NewVisitorTest) ---------------------------------------------------------------------- Traceback (most recent call last): File \"functional_tests.py\", line 20, in test_can_start_a_list_and_retrieve_it_later self.assertIn('To-Do', self.browser.title) AssertionError: 'To-Do' not found in '' ---------------------------------------------------------------------- Ran 1 test in 37.913s FAILED (failures=1) Woo! Our tests are failing as they should be. Notice, we haven't added anything to our app in this chapter, and that's intentional. We now have a test that will pass once our app is returning a page that has the correct title and that will be our next step. For now, it would be a good moment to commit your project and push it to github.","title":"Introducing the unittest Module"},{"location":"chy/#introducing-the-unittest-module","text":"","title":"Introducing the unittest Module"},{"location":"chy/#a-note-to-begin","text":"One thing to notice before we go much further is that we have a number of tools running at the same time to do our tests. Our Flask server that is launched when we type flask run in our terminal. This web server runs on your local machine, is not visible to the outside world, and listens at the IP address 127.0.0.1 on port 5000. In the URL bar, this will look like 127.0.0.1:5000 . Our Flask app that the Flask server calls when it receives requests. Our functional_test.py script, which opens a web browser to send particular requests to the Flask server, and evaluates the server's responses. I recommend, perhaps, diagramming these for yourself in some fashion if it helps you keep things in order.","title":"A note to begin:"},{"location":"chy/#unittests","text":"Our last iteration of our app was extremely simple. It didn't even use any HTML and didn't properly return a web-page; just the string \"Hello, Flask!\" That's not particularly useful if we're trying to build a little web-app, but it's a start. Now we're moving on to bigger and better things. You'll actually have a proper webpage. Our first step will be to modify our functional test so that it looks for a title property. We'll alo add the story that Percival mentions So let's go to the functional test: from selenium import webdriver browser = webdriver.Firefox() # Edith (our test) has heard about a cool new online to-do app. She goes # to check out its homepage browser.get('http://127.0.0.1:5000') # or http://localhost:5000 # She notices the page title and header mention to-do lists assert 'To-Do' in browser.title # She is invited to enter a to-do item straight away # She types \"Buy peacock feathers\" into a text box (Edith's hobby # is tying fly-fishing lures) # When she hits enter, the page updates, and now the page lists # \"1: Buy peacock feathers\" as an item in a to-do list # There is still a text box inviting her to add another item. She # enters \"Use peacock feathers to make a fly\" (Edith is very methodical) # The page updates again, and now shows both items on her list # Edith wonders whether the site will remember her list. Then she sees # that the site has generated a unique URL for her -- there is some # explanatory text to that effect. # She visits that URL - her to-do list is still there. # Satisfied, she goes back to sleep browser.quit() functional_tests.py","title":"Unittests"},{"location":"chy/#comments","text":"There are lot of opinions when it comes to how we add comments to our code. In a traditional CS program, we'd expect students to write extensive comments. This is to help the instructor see what you believe you are doing with a particular line of code or function. Likewise, the practice of writing such comments is useful for you to become conscious of what your code is doing. Comments can also be used as a sort of pseudocode to describe what functions your code will need to accomplish (as in the above example). In professional settings, there is a debate as to how many comments are necessary. On the one hand, some argue that your code should be clearly written enough that you don't need any comments. If your code needs comments to explain what's going on, you probably have a problem with your code. They also argue that if you change your code in the future without changing your comments, the comments can become misleading and more of a hinderance for future developers. On the other hand, some argue that comments provide crucial insight to you and other developers about what the code is supposed to do. They give future developers a sense of what you were thinking when you were writing the code. They are also important if you are writing an API or other code that future developers will extend. Additionally, comments are frequently used to generate documentation. For instance Sphinx and other documentation generation tools can automatically create docs based on the comments. Beyond all of this, if you're working for a company, that company will likely have its own approach to comments, and probably a majority of your first period there will be reading the code and comments that you will later be working on. This is all to say, you'll have to decide how much you want to comment your code based on the project. A general rule of thumb is that if the code doesn't obviously tell you what is happening, it's worth commenting. For example the first comment is probably not needed, but the second is (I also probably wouldn't write that generator just to save a few lines of code anyway): # Increment age by 1 age += 1 n = int(input(\"How many players? \")) # prompt users for name and age for each player age_map = {input(\"Name?\"): int(input(\"Age?\")) for i in range(n)}","title":"Comments"},{"location":"chy/#back-to-our-tests","text":"If we start up our Flask server: (env) $ flask run and in another shell run our functional tests, you'll get an error like this: (env) $ python functional_tests.py Traceback (most recent call last): File \"functional_tests.py\", line 6, in <module> assert 'To-Do' in browser.title AssertionError We are getting the error that we are expecting! However, we want to move over to the unittest framework to make our test a little bit more robust. After all, we'll be building an entire testing suite for our application: every operation we want should be tested. This will be very similar to the test in Percival's book, but before that, take a moment to consider the unittest library.","title":"Back to our Tests"},{"location":"chy/#unittest","text":"The unittest library is a framework for writing unit tests. A unit test is an automated test that checks the functionality of one unit of a particular application. For instance, one unit of our webpage is the title that shows up on the browser tab. A unit test will test that that is as it should be. Likewise, it might test a single function of our application. When writing a unit test, we need to provide all of the conditions or dependencies except the one variable that is being tested. So our browser title test needs to just test that the browser title contains particular content. It shouldn't check that the browser starts up or anything that appears on the page or that the URL is correct. A functional test is a test that checks a particular functionality of our application. For instance, a functional test might check that we can input a new item into a list and when we do so the item gets added to the database. Unlike a unit test that might have distinct tests for user input and writing to the database, the functional test tries to see that the components work together properly. Another way to think of this: unit tests check a discrete section of code. Functional tests simulate user experience. So, now lets update our functional_tests.py file. You'll notice that this is a functional test because it tests a component of our application as a user would encounter it. We'll write unittests later. from selenium import webdriver import unittest class NewVisitorTest(unittest.TestCase): def setUp(self): self.browser = webdriver.Firefox() def tearDown(self): self.browser.quit() def test_can_start_a_list_and_retrieve_it_later(self): # Call homepage self.browser.get('http://127.0.0.1:5000') # Old way: # assert 'To-Do' in browser.title # Using unittest methods self.assertIn('To-Do', self.browser.title) self.fail('Finish writing the test!') # She is invited to enter a to-do item straight away # She types \"Buy peacock feathers\" into a text box (Edith's hobby # is tying fly-fishing lures) # When she hits enter, the page updates, and now the page lists # \"1: Buy peacock feathers\" as an item in a to-do list # There is still a text box inviting her to add another item. She # enters \"Use peacock feathers to make a fly\" (Edith is very methodical) # The page updates again, and now shows both items on her list # Edith wonders whether the site will remember her list. Then she sees # that the site has generated a unique URL for her -- there is some # explanatory text to that effect. # She visits that URL - her to-do list is still there. # Satisfied, she goes back to sleep if __name__ in '__main__': unittest.main(warnings='ignore') Once again, we want to test it. If you stopped your Flask server, launch it again. Then let's run our functional tests and see the results: (env) $ python functional_tests.py F ====================================================================== FAIL: test_can_start_a_list_and_retrieve_it_later (__main__.NewVisitorTest) ---------------------------------------------------------------------- Traceback (most recent call last): File \"functional_tests.py\", line 20, in test_can_start_a_list_and_retrieve_it_later self.assertIn('To-Do', self.browser.title) AssertionError: 'To-Do' not found in '' ---------------------------------------------------------------------- Ran 1 test in 37.913s FAILED (failures=1) Woo! Our tests are failing as they should be. Notice, we haven't added anything to our app in this chapter, and that's intentional. We now have a test that will pass once our app is returning a page that has the correct title and that will be our next step. For now, it would be a good moment to commit your project and push it to github.","title":"unittest"},{"location":"chz/","text":"Your Flask App We will be building the Superlists app in Flask. The approach and the code will be a bit different, but our tests will be pretty close to the Django Superlists apps discussed in Percival's book . Since Flask is a microframework, we don't have the same CLI to build a new application or feature within our app. In Django, when you run the command $ python manage.py startapp lists Django creates a brand new app with a bunch of files associated with that application. It includes an admin interface, all of your database models, and your views. This makes building with Django relatively easy and quick, but on the other hand, if you are, say, building an app that doesn't require a database or admin interface or users, then Django gives you a lot of extra stuff that you don't need, still needs to be maintained, and might contain vulnerabilities that will be patched in the future. How do we start our app with Flask?","title":"Your Flask App"},{"location":"chz/#your-flask-app","text":"We will be building the Superlists app in Flask. The approach and the code will be a bit different, but our tests will be pretty close to the Django Superlists apps discussed in Percival's book . Since Flask is a microframework, we don't have the same CLI to build a new application or feature within our app. In Django, when you run the command $ python manage.py startapp lists Django creates a brand new app with a bunch of files associated with that application. It includes an admin interface, all of your database models, and your views. This makes building with Django relatively easy and quick, but on the other hand, if you are, say, building an app that doesn't require a database or admin interface or users, then Django gives you a lot of extra stuff that you don't need, still needs to be maintained, and might contain vulnerabilities that will be patched in the future. How do we start our app with Flask?","title":"Your Flask App"}]}