# Introduction to Flask

Flask is a Python microframework that is amazingly easy to use and still relatively powerful. But before we get ahead of ourselves, what the heck is a framework?

Think about it this way: If I wanted to build a brick wall from scratch, I would need to first be able to make bricks from clay. I'd also need to know how to mix mortar to the appropriate consistency. I'd also probably need to know a bit about the general physics behind wall building. Etc. Of course, I don't do that. I'd probably get plans off the internet, buy bricks from Mutual Materials or Home Depot or Salmon Bay, I'd also buy mortar mix (cuz mixing real mortar, while cool, is a pain), and all the tools I need to assemble the wall. A framework is kind of like that.

A web framework is a set of classes and functions that have been built for you that you assemble and tweak as you see fit. For instance, you could write a server to listen for HTTP requests. You could also write your own database interface, and so on. But you probably don't need to because one out there already exists that's been tested and optimized for your use case. That's what frameworks do. A framework is a set of tools that manages the common operations of applications freeing up your time to develop within those frameworks the specific features of your application.

There are numerous web frameworks to choose from in many languages, most popular include PHP, Python, Javascript, and Ruby. Some popular ones include Wordpress, Drupal, Laravel and CodeIgniter in PHP, and Django and Flask in Python. Wordpress and Drupal are both CMS' rather than web frameworks, but they are often used to develop applications. They provide great tools for people who don't necessarily want to get their hands dirty writing code. That being said, they are much more limited in terms of what you can do unless you want to write your own modules. The rest are more true to the web framework idea. You will have to code something, but much of your coding will involve using build in functions and classes.  Laravel and Django are both full frameworks, whereas CodeIgniter and Flask are micro-frameworks. You will notice that I don't mention any Javascript frameworks. That's in part because we won't touch much Javascript, and in part because that material is covered in the WATS program. We're not going to learn Laravel or CodeIgniter because they are in PHP, we learn Python, and PHP is a strange and ugly language that powers much of the web, but doesn't do much else. Once you've learned developing apps in Python, you could easily take a few weeks and learn how to do it in PHP. Here is a chart comparing their popularity based Google Search trends.

   <script type="text/javascript" src="https://ssl.gstatic.com/trends_nrtr/2152_RC04/embed_loader.js"></script>
  <script type="text/javascript">
    trends.embed.renderExploreWidget("TIMESERIES", {"comparisonItem":[{"keyword":"/m/0dgs72v","geo":"US","time":"today 5-y"},{"keyword":"/m/06y_qx","geo":"US","time":"today 5-y"},{"keyword":"/m/0jwy148","geo":"US","time":"today 5-y"}],"category":0,"property":""}, {"exploreQuery":"date=today%205-y&geo=US&q=%2Fm%2F0dgs72v,%2Fm%2F06y_qx,%2Fm%2F0jwy148","guestPath":"https://trends.google.com:443/trends/embed/"});
  </script>

In searching for the top skills that a Python developer ought to have after being familiar with Python, Django and Flask come up as the first and second regularly. We're learning Flask in this class because it's a lot smaller and because it does less of its work automagically. To write a really complicated app in Flask would be more time consuming than it would be in Django because Django is so comprehensive, but we're not building complicated apps, and once you've learned Flask, you can go pick up Django pretty easily. The concepts are the same, but Django has more features built in.

## Design Patterns

Web frameworks are built on a design pattern that separates concerns: for instance, separating the user interface from the processing. Separating concerns is a crucial concept of programming. An example might be the functions we've built so far. You'll notice that we didn't use a single input() function or print() function. This is because we were building general functions whose aim was to perform a single operation. Keeping the processing logic separate from the user interface is useful. My calculator can work with any user interface and is not dependent upon a single user interface to work. I could link it to a command line user interface just as easily as I could link it to a web application. As long as my functions are getting the right parameters, they will return the appropriate values. Additionally, I can have separate design teams working on the data processing and the user interface. This is a good practice in general and makes whatever we build significantly more flexible. Code that keeps elements tightly linked so that the processing is dependent upon the user interface and vice versa is called tightly coupled. For instance, if I used input() to get an integer from my user in the prime_factors() function instead of the parameters, I would have written a user interface that was tightly coupled to the function that processes the input from the user. On the other hand when our components are not necessarily dependent on the design of the other components, we would call them loosely coupled. Generally, loosely coupled components are better.

## Model View Controller

Web frameworks generally separate concerns following a pattern similar to Model-View-Controller, or MVC. The Model-View-Controller pattern separates our concerns into three components. The Model is the component responsible for managing data and usually interfaces with some database where the data will be stored. Likewise, the Model might do some data processing. The View or Views is the component responsible for the user interface. The Views in Web Frameworks usually use some templating language that is rendered into HTML/CSS and Javascript to be sent over the network to the client. Likewise, Views usually include the forms that allow the user to send data to the application. The Controller is the component that links the Models and the Views. Let's say you've created a blog. When the user requests a particular post, they make a GET request through a link in one of the pages rendered in their web browser. The routing mechanism in the framework listens for the particular request and calls the appropriate Controller. The Controller calls the function in the Model that retrieves the requested post. It then takes that data returned by the Model function and puts that into the appropriate view (probably a template for displaying a single blog post on a page). It assembles the data and the template and sends that as an HTML/CSS and Javascript web page for the user to see. There are MVC frameworks written in Python, PHP, C++, Java, and C#. The strength is they are well developed and have all the components you need to build a large website and set of applications. Sometimes the design pattern is slightly different. Django, for instance, follows a Model, View, Template pattern. In this case, the View acts more like a controller. It calls functions from the Model and populates the Template. Regardless of the slight variations, this design pattern that separates concerns is common across frameworks. One cool trick about separating concerns is that you can replace with little difficulty the View component, and one strategy is replacing the View component built into the framework with a Javascript frontend framework like React or Vue or Angular. Generally this is done by having the MVC framework generate JSON objects that get sent to the frontend framework. 

## What this has to do with Flask

Flask is not a traditional Framework. It is a microframework, so it does things slightly differently. Traditional frameworks assume that you'll need things like a database and user authentication and so on. As a result, those components are built in and make the framework pretty large. Flask's philosophy is to include only the bare minimum. As a result, it does not come with a database system or user authentication and so on. That doesn't mean you can't add it later, but it does mean that if you don't need a database, it's not there to take up space and get in the way. 

When the server running Flask gets a request, it sends that request to Flask. Flask's routes listen for known requests. If one of the routes is requested properly, the route function collects all of the resources including the database objects (if using) and the templates, and returns those to the client. 

This will make more sense when we start building, so let's get started. In the next chapter, we'll seet up the bare minimum web application possible in Flask. It will contain 7 lines of code and we'll developing using TDD.
